/* Generated from Java with JSweet 2.3.5 - http://www.jsweet.org */
var java;
(function (java) {
    var beans;
    (function (beans) {
        /**
         * General-purpose beans control methods. GWT only supports a limited subset of these methods. Only
         * the documented methods are available.
         * @class
         */
        class Beans {
            /**
             * @return {boolean} <code>true</code> if we are running in the design time mode.
             */
            static isDesignTime() {
                return false;
            }
        }
        beans.Beans = Beans;
        Beans["__class"] = "java.beans.Beans";
    })(beans = java.beans || (java.beans = {}));
})(java || (java = {}));
(function (java) {
    var io;
    (function (io) {
        /**
         * This constructor does nothing. It is provided for signature
         * compatibility.
         * @class
         * @extends *
         */
        class InputStream {
            constructor() {
            }
            /**
             * Returns an estimated number of bytes that can be read or skipped without blocking for more
             * input.
             *
             * <p>Note that this method provides such a weak guarantee that it is not very useful in
             * practice.
             *
             * <p>Firstly, the guarantee is "without blocking for more input" rather than "without
             * blocking": a read may still block waiting for I/O to complete&nbsp;&mdash; the guarantee is
             * merely that it won't have to wait indefinitely for data to be written. The result of this
             * method should not be used as a license to do I/O on a thread that shouldn't be blocked.
             *
             * <p>Secondly, the result is a
             * conservative estimate and may be significantly smaller than the actual number of bytes
             * available. In particular, an implementation that always returns 0 would be correct.
             * In general, callers should only use this method if they'd be satisfied with
             * treating the result as a boolean yes or no answer to the question "is there definitely
             * data ready?".
             *
             * <p>Thirdly, the fact that a given number of bytes is "available" does not guarantee that a
             * read or skip will actually read or skip that many bytes: they may read or skip fewer.
             *
             * <p>It is particularly important to realize that you <i>must not</i> use this method to
             * size a container and assume that you can read the entirety of the stream without needing
             * to resize the container. Such callers should probably write everything they read to a
             * {@link ByteArrayOutputStream} and convert that to a byte array. Alternatively, if you're
             * reading from a file, {@link File#length} returns the current length of the file (though
             * assuming the file's length can't change may be incorrect, reading a file is inherently
             * racy).
             *
             * <p>The default implementation of this method in {@code InputStream} always returns 0.
             * Subclasses should override this method if they are able to indicate the number of bytes
             * available.
             *
             * @return {number} the estimated number of bytes available
             * @throws IOException if this stream is closed or an error occurs
             */
            available() {
                return 0;
            }
            /**
             * Closes this stream. Concrete implementations of this class should free
             * any resources during close. This implementation does nothing.
             *
             * @throws IOException
             * if an error occurs while closing this stream.
             */
            close() {
            }
            /**
             * Sets a mark position in this InputStream. The parameter {@code readlimit}
             * indicates how many bytes can be read before the mark is invalidated.
             * Sending {@code reset()} will reposition the stream back to the marked
             * position provided {@code readLimit} has not been surpassed.
             * <p>
             * This default implementation does nothing and concrete subclasses must
             * provide their own implementation.
             *
             * @param {number} readlimit
             * the number of bytes that can be read from this stream before
             * the mark is invalidated.
             * @see #markSupported()
             * @see #reset()
             */
            mark(readlimit) {
            }
            /**
             * Indicates whether this stream supports the {@code mark()} and
             * {@code reset()} methods. The default implementation returns {@code false}.
             *
             * @return {boolean} always {@code false}.
             * @see #mark(int)
             * @see #reset()
             */
            markSupported() {
                return false;
            }
            read$() { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); }
            read$byte_A(buffer) {
                javaemul.internal.InternalPreconditions.checkNotNull(buffer);
                return this.read$byte_A$int$int(buffer, 0, buffer.length);
            }
            read$byte_A$int$int(buffer, byteOffset, byteCount) {
                java.io.IOUtils.checkOffsetAndCount$byte_A$int$int(buffer, byteOffset, byteCount);
                for (let i = 0; i < byteCount; ++i) {
                    {
                        let c;
                        try {
                            if ((c = this.read()) === -1) {
                                return i === 0 ? -1 : i;
                            }
                        }
                        catch (e) {
                            if (i !== 0) {
                                return i;
                            }
                            throw e;
                        }
                        ;
                        buffer[byteOffset + i] = (c | 0);
                    }
                    ;
                }
                return byteCount;
            }
            /**
             * Reads up to {@code byteCount} bytes from this stream and stores them in
             * the byte array {@code buffer} starting at {@code byteOffset}.
             * Returns the number of bytes actually read or -1 if the end of the stream
             * has been reached.
             *
             * @throws IndexOutOfBoundsException
             * if {@code byteOffset < 0 || byteCount < 0 || byteOffset + byteCount > buffer.length}.
             * @throws IOException
             * if the stream is closed or another IOException occurs.
             * @param {Array} buffer
             * @param {number} byteOffset
             * @param {number} byteCount
             * @return {number}
             */
            read(buffer, byteOffset, byteCount) {
                if (((buffer != null && buffer instanceof Array && (buffer.length == 0 || buffer[0] == null || (typeof buffer[0] === 'number'))) || buffer === null) && ((typeof byteOffset === 'number') || byteOffset === null) && ((typeof byteCount === 'number') || byteCount === null)) {
                    return this.read$byte_A$int$int(buffer, byteOffset, byteCount);
                }
                else if (((buffer != null && buffer instanceof Array && (buffer.length == 0 || buffer[0] == null || (typeof buffer[0] === 'number'))) || buffer === null) && byteOffset === undefined && byteCount === undefined) {
                    return this.read$byte_A(buffer);
                }
                else if (buffer === undefined && byteOffset === undefined && byteCount === undefined) {
                    return this.read$();
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             * Resets this stream to the last marked location. Throws an
             * {@code IOException} if the number of bytes read since the mark has been
             * set is greater than the limit provided to {@code mark}, or if no mark
             * has been set.
             * <p>
             * This implementation always throws an {@code IOException} and concrete
             * subclasses should provide the proper implementation.
             *
             * @throws IOException
             * if this stream is closed or another IOException occurs.
             */
            reset() {
                throw new java.io.IOException();
            }
            /**
             * Skips at most {@code byteCount} bytes in this stream. The number of actual
             * bytes skipped may be anywhere between 0 and {@code byteCount}. If
             * {@code byteCount} is negative, this method does nothing and returns 0, but
             * some subclasses may throw.
             *
             * <p>Note the "at most" in the description of this method: this method may
             * choose to skip fewer bytes than requested. Callers should <i>always</i>
             * check the return value.
             *
             * <p>This default implementation reads bytes into a temporary buffer. Concrete
             * subclasses should provide their own implementation.
             *
             * @return {number} the number of bytes actually skipped.
             * @throws IOException if this stream is closed or another IOException
             * occurs.
             * @param {number} byteCount
             */
            skip(byteCount) {
                if (byteCount <= 0) {
                    return 0;
                }
                let bSize = (Math.min(InputStream.MAX_SKIP_BUFFER_SIZE, byteCount) | 0);
                let b = (s => { let a = []; while (s-- > 0)
                    a.push(0); return a; })(bSize);
                let skipped = 0;
                while ((skipped < byteCount)) {
                    {
                        let toRead = (Math.min(byteCount - skipped, b.length) | 0);
                        let readCount = this.read$byte_A$int$int(b, 0, toRead);
                        if (readCount === -1) {
                            break;
                        }
                        skipped += readCount;
                        if (readCount < toRead) {
                            break;
                        }
                    }
                }
                ;
                return skipped;
            }
        }
        /**
         * Size of the temporary buffer used when skipping bytes with {@link skip(long)}.
         */
        InputStream.MAX_SKIP_BUFFER_SIZE = 4096;
        io.InputStream = InputStream;
        InputStream["__class"] = "java.io.InputStream";
        InputStream["__interfaces"] = ["java.io.Closeable", "java.lang.AutoCloseable"];
    })(io = java.io || (java.io = {}));
})(java || (java = {}));
(function (java) {
    var io;
    (function (io) {
        /**
         * Provides a series of utilities to be reused between IO classes.
         *
         * TODO(chehayeb): move these checks to InternalPreconditions.
         * @class
         */
        class IOUtils {
            constructor() {
            }
            static checkOffsetAndCount$byte_A$int$int(buffer, byteOffset, byteCount) {
                javaemul.internal.InternalPreconditions.checkNotNull(buffer);
                IOUtils.checkOffsetAndCount$int$int$int(buffer.length, byteOffset, byteCount);
            }
            /**
             * Validates the offset and the byte count for the given array of bytes.
             *
             * @param {Array} buffer Array of bytes to be checked.
             * @param {number} byteOffset Starting offset in the array.
             * @param {number} byteCount Total number of bytes to be accessed.
             * @throws NullPointerException if the given reference to the buffer is null.
             * @throws IndexOutOfBoundsException if {@code byteOffset} is negative, {@code byteCount} is
             * negative or their sum exceeds the buffer length.
             */
            static checkOffsetAndCount(buffer, byteOffset, byteCount) {
                if (((buffer != null && buffer instanceof Array && (buffer.length == 0 || buffer[0] == null || (typeof buffer[0] === 'number'))) || buffer === null) && ((typeof byteOffset === 'number') || byteOffset === null) && ((typeof byteCount === 'number') || byteCount === null)) {
                    return java.io.IOUtils.checkOffsetAndCount$byte_A$int$int(buffer, byteOffset, byteCount);
                }
                else if (((buffer != null && buffer instanceof Array && (buffer.length == 0 || buffer[0] == null || (typeof buffer[0] === 'string'))) || buffer === null) && ((typeof byteOffset === 'number') || byteOffset === null) && ((typeof byteCount === 'number') || byteCount === null)) {
                    return java.io.IOUtils.checkOffsetAndCount$char_A$int$int(buffer, byteOffset, byteCount);
                }
                else if (((typeof buffer === 'number') || buffer === null) && ((typeof byteOffset === 'number') || byteOffset === null) && ((typeof byteCount === 'number') || byteCount === null)) {
                    return java.io.IOUtils.checkOffsetAndCount$int$int$int(buffer, byteOffset, byteCount);
                }
                else
                    throw new Error('invalid overload');
            }
            static checkOffsetAndCount$char_A$int$int(buffer, charOffset, charCount) {
                javaemul.internal.InternalPreconditions.checkNotNull(buffer);
                IOUtils.checkOffsetAndCount$int$int$int(buffer.length, charOffset, charCount);
            }
            /*private*/ static checkOffsetAndCount$int$int$int(length, offset, count) {
                if ((offset < 0) || (count < 0) || ((offset + count) > length)) {
                    throw new java.lang.IndexOutOfBoundsException();
                }
            }
        }
        io.IOUtils = IOUtils;
        IOUtils["__class"] = "java.io.IOUtils";
    })(io = java.io || (java.io = {}));
})(java || (java = {}));
(function (java) {
    var io;
    (function (io) {
        /**
         * Default constructor.
         * @class
         */
        class OutputStream {
            constructor() {
            }
            /**
             * Closes this stream. Implementations of this method should free any
             * resources used by the stream. This implementation does nothing.
             *
             * @throws IOException
             * if an error occurs while closing this stream.
             */
            close() {
            }
            /**
             * Flushes this stream. Implementations of this method should ensure that
             * any buffered data is written out. This implementation does nothing.
             *
             * @throws IOException
             * if an error occurs while flushing this stream.
             */
            flush() {
            }
            write$byte_A(buffer) {
                javaemul.internal.InternalPreconditions.checkNotNull(buffer);
                this.write$byte_A$int$int(buffer, 0, buffer.length);
            }
            write$byte_A$int$int(buffer, offset, count) {
                java.io.IOUtils.checkOffsetAndCount$byte_A$int$int(buffer, offset, count);
                for (let i = offset; i < offset + count; i++) {
                    {
                        this.write$int(buffer[i]);
                    }
                    ;
                }
            }
            /**
             * Writes {@code count} bytes from the byte array {@code buffer} starting at
             * position {@code offset} to this stream.
             *
             * @param {Array} buffer
             * the buffer to be written.
             * @param {number} offset
             * the start position in {@code buffer} from where to get bytes.
             * @param {number} count
             * the number of bytes from {@code buffer} to write to this
             * stream.
             * @throws IOException
             * if an error occurs while writing to this stream.
             * @throws IndexOutOfBoundsException
             * if {@code offset < 0} or {@code count < 0}, or if
             * {@code offset + count} is bigger than the length of
             * {@code buffer}.
             */
            write(buffer, offset, count) {
                if (((buffer != null && buffer instanceof Array && (buffer.length == 0 || buffer[0] == null || (typeof buffer[0] === 'number'))) || buffer === null) && ((typeof offset === 'number') || offset === null) && ((typeof count === 'number') || count === null)) {
                    return this.write$byte_A$int$int(buffer, offset, count);
                }
                else if (((buffer != null && buffer instanceof Array && (buffer.length == 0 || buffer[0] == null || (typeof buffer[0] === 'number'))) || buffer === null) && offset === undefined && count === undefined) {
                    return this.write$byte_A(buffer);
                }
                else if (((typeof buffer === 'number') || buffer === null) && offset === undefined && count === undefined) {
                    return this.write$int(buffer);
                }
                else
                    throw new Error('invalid overload');
            }
            write$int(oneByte) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); }
        }
        io.OutputStream = OutputStream;
        OutputStream["__class"] = "java.io.OutputStream";
        OutputStream["__interfaces"] = ["java.io.Closeable", "java.lang.AutoCloseable", "java.io.Flushable"];
    })(io = java.io || (java.io = {}));
})(java || (java = {}));
(function (java) {
    var io;
    (function (io) {
        /**
         * JSweet implementation.
         * @class
         */
        class Reader {
            constructor(lock) {
                /**
                 * Skip buffer, null until allocated
                 */
                /*private*/ this.skipBuffer = null;
                if (((lock != null) || lock === null)) {
                    let __args = arguments;
                    if (this.lock === undefined)
                        this.lock = null;
                    this.skipBuffer = null;
                    if (this.lock === undefined)
                        this.lock = null;
                    (() => {
                        if (lock == null) {
                            throw new java.lang.NullPointerException();
                        }
                        this.lock = lock;
                    })();
                }
                else if (lock === undefined) {
                    let __args = arguments;
                    if (this.lock === undefined)
                        this.lock = null;
                    this.skipBuffer = null;
                    if (this.lock === undefined)
                        this.lock = null;
                    (() => {
                        this.lock = this;
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            read$() {
                let cb = [null];
                if (this.read$char_A$int$int(cb, 0, 1) === -1)
                    return -1;
                else
                    return (cb[0]).charCodeAt(0);
            }
            read$char_A(cbuf) {
                return this.read$char_A$int$int(cbuf, 0, cbuf.length);
            }
            read$char_A$int$int(cbuf, off, len) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); }
            read(cbuf, off, len) {
                if (((cbuf != null && cbuf instanceof Array && (cbuf.length == 0 || cbuf[0] == null || (typeof cbuf[0] === 'string'))) || cbuf === null) && ((typeof off === 'number') || off === null) && ((typeof len === 'number') || len === null)) {
                    return this.read$char_A$int$int(cbuf, off, len);
                }
                else if (((cbuf != null && cbuf instanceof Array && (cbuf.length == 0 || cbuf[0] == null || (typeof cbuf[0] === 'string'))) || cbuf === null) && off === undefined && len === undefined) {
                    return this.read$char_A(cbuf);
                }
                else if (cbuf === undefined && off === undefined && len === undefined) {
                    return this.read$();
                }
                else
                    throw new Error('invalid overload');
            }
            skip(n) {
                if (n < 0)
                    throw new java.lang.IllegalArgumentException("skip value is negative");
                let nn = (Math.min(n, Reader.maxSkipBufferSize) | 0);
                if ((this.skipBuffer == null) || (this.skipBuffer.length < nn))
                    this.skipBuffer = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(nn);
                let r = n;
                while ((r > 0)) {
                    {
                        let nc = this.read$char_A$int$int(this.skipBuffer, 0, (Math.min(r, nn) | 0));
                        if (nc === -1)
                            break;
                        r -= nc;
                    }
                }
                ;
                return n - r;
            }
            ready() {
                return false;
            }
            markSupported() {
                return false;
            }
            mark(readAheadLimit) {
                throw new java.io.IOException("mark() not supported");
            }
            reset() {
                throw new java.io.IOException("reset() not supported");
            }
        }
        /**
         * Maximum skip-buffer size
         */
        Reader.maxSkipBufferSize = 8192;
        io.Reader = Reader;
        Reader["__class"] = "java.io.Reader";
        Reader["__interfaces"] = ["java.io.Closeable", "java.lang.AutoCloseable"];
    })(io = java.io || (java.io = {}));
})(java || (java = {}));
(function (java) {
    var io;
    (function (io) {
        /**
         * JSweet implementation.
         * @class
         */
        class Writer {
            constructor(lock) {
                if (((lock != null) || lock === null)) {
                    let __args = arguments;
                    if (this.writeBuffer === undefined)
                        this.writeBuffer = null;
                    if (this.lock === undefined)
                        this.lock = null;
                    if (this.writeBuffer === undefined)
                        this.writeBuffer = null;
                    if (this.lock === undefined)
                        this.lock = null;
                    (() => {
                        if (lock == null) {
                            throw new java.lang.NullPointerException();
                        }
                        this.lock = lock;
                    })();
                }
                else if (lock === undefined) {
                    let __args = arguments;
                    if (this.writeBuffer === undefined)
                        this.writeBuffer = null;
                    if (this.lock === undefined)
                        this.lock = null;
                    if (this.writeBuffer === undefined)
                        this.writeBuffer = null;
                    if (this.lock === undefined)
                        this.lock = null;
                    (() => {
                        this.lock = this;
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            write$int(c) {
                {
                    if (this.writeBuffer == null) {
                        this.writeBuffer = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(Writer.WRITE_BUFFER_SIZE);
                    }
                    this.writeBuffer[0] = String.fromCharCode(c);
                    this.write$char_A$int$int(this.writeBuffer, 0, 1);
                }
                ;
            }
            write$char_A(cbuf) {
                this.write$char_A$int$int(cbuf, 0, cbuf.length);
            }
            write$char_A$int$int(cbuf, off, len) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); }
            write$java_lang_String(str) {
                this.write$java_lang_String$int$int(str, 0, str.length);
            }
            write$java_lang_String$int$int(str, off, len) {
                {
                    let cbuf;
                    if (len <= Writer.WRITE_BUFFER_SIZE) {
                        if (this.writeBuffer == null) {
                            this.writeBuffer = (s => { let a = []; while (s-- > 0)
                                a.push(null); return a; })(Writer.WRITE_BUFFER_SIZE);
                        }
                        cbuf = this.writeBuffer;
                    }
                    else {
                        cbuf = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(len);
                    }
                    /* getChars */ ((a, s, e, d, l) => { d.splice.apply(d, [l, e - s].concat(a.substring(s, e).split(''))); })(str, off, (off + len), cbuf, 0);
                    this.write$char_A$int$int(cbuf, 0, len);
                }
                ;
            }
            write(str, off, len) {
                if (((typeof str === 'string') || str === null) && ((typeof off === 'number') || off === null) && ((typeof len === 'number') || len === null)) {
                    return this.write$java_lang_String$int$int(str, off, len);
                }
                else if (((str != null && str instanceof Array && (str.length == 0 || str[0] == null || (typeof str[0] === 'string'))) || str === null) && ((typeof off === 'number') || off === null) && ((typeof len === 'number') || len === null)) {
                    return this.write$char_A$int$int(str, off, len);
                }
                else if (((str != null && str instanceof Array && (str.length == 0 || str[0] == null || (typeof str[0] === 'string'))) || str === null) && off === undefined && len === undefined) {
                    return this.write$char_A(str);
                }
                else if (((typeof str === 'string') || str === null) && off === undefined && len === undefined) {
                    return this.write$java_lang_String(str);
                }
                else if (((typeof str === 'number') || str === null) && off === undefined && len === undefined) {
                    return this.write$int(str);
                }
                else
                    throw new Error('invalid overload');
            }
            append$java_lang_CharSequence(csq) {
                if (csq == null)
                    this.write$java_lang_String("null");
                else
                    this.write$java_lang_String(csq.toString());
                return this;
            }
            append$java_lang_CharSequence$int$int(csq, start, end) {
                let cs = (csq == null ? "null" : csq);
                this.write$java_lang_String(/* subSequence */ cs.substring(start, end).toString());
                return this;
            }
            append(csq, start, end) {
                if (((csq != null && (csq["__interfaces"] != null && csq["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || csq.constructor != null && csq.constructor["__interfaces"] != null && csq.constructor["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || typeof csq === "string")) || csq === null) && ((typeof start === 'number') || start === null) && ((typeof end === 'number') || end === null)) {
                    return this.append$java_lang_CharSequence$int$int(csq, start, end);
                }
                else if (((csq != null && (csq["__interfaces"] != null && csq["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || csq.constructor != null && csq.constructor["__interfaces"] != null && csq.constructor["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || typeof csq === "string")) || csq === null) && start === undefined && end === undefined) {
                    return this.append$java_lang_CharSequence(csq);
                }
                else if (((typeof csq === 'string') || csq === null) && start === undefined && end === undefined) {
                    return this.append$char(csq);
                }
                else
                    throw new Error('invalid overload');
            }
            append$char(c) {
                this.write$int((c).charCodeAt(0));
                return this;
            }
        }
        Writer.WRITE_BUFFER_SIZE = 1024;
        io.Writer = Writer;
        Writer["__class"] = "java.io.Writer";
        Writer["__interfaces"] = ["java.lang.Appendable", "java.io.Closeable", "java.lang.AutoCloseable", "java.io.Flushable"];
    })(io = java.io || (java.io = {}));
})(java || (java = {}));
(function (java) {
    var lang;
    (function (lang) {
        /**
         * A base class to share implementation between {@link StringBuffer} and {@link StringBuilder}.
         * <p>
         * Most methods will give expected performance results. Exception is {@link #setCharAt(int, char)},
         * which is O(n), and thus should not be used many times on the same <code>StringBuffer</code>.
         * @param {string} string
         * @class
         */
        class AbstractStringBuilder {
            constructor(string) {
                if (this.string === undefined)
                    this.string = null;
                this.string = string;
            }
            length() {
                return this.string.length;
            }
            setLength(newLength) {
                let oldLength = this.length();
                if (newLength < oldLength) {
                    this.string = this.string.substring(0, newLength);
                }
                else if (newLength > oldLength) {
                    this.string += new String((s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(newLength - oldLength)).toString();
                }
            }
            capacity() {
                return javaemul.internal.IntegerHelper.MAX_VALUE;
            }
            ensureCapacity(ignoredCapacity) {
            }
            trimToSize() {
            }
            charAt(index) {
                return this.string.charAt(index);
            }
            getChars(srcStart, srcEnd, dst, dstStart) {
                javaemul.internal.InternalPreconditions.checkStringBounds(srcStart, srcEnd, this.length());
                javaemul.internal.InternalPreconditions.checkStringBounds(dstStart, dstStart + (srcEnd - srcStart), dst.length);
                while ((srcStart < srcEnd)) {
                    {
                        dst[dstStart++] = this.string.charAt(srcStart++);
                    }
                }
                ;
            }
            /**
             * Warning! This method is <b>much</b> slower than the JRE implementation. If you need to do
             * character level manipulation, you are strongly advised to use a char[] directly.
             * @param {number} index
             * @param {string} x
             */
            setCharAt(index, x) {
                this.replace0(index, index + 1, /* valueOf */ new String(x).toString());
            }
            subSequence(start, end) {
                return this.string.substring(start, end);
            }
            substring$int(begin) {
                return this.string.substring(begin);
            }
            substring$int$int(begin, end) {
                return this.string.substring(begin, end);
            }
            substring(begin, end) {
                if (((typeof begin === 'number') || begin === null) && ((typeof end === 'number') || end === null)) {
                    return this.substring$int$int(begin, end);
                }
                else if (((typeof begin === 'number') || begin === null) && end === undefined) {
                    return this.substring$int(begin);
                }
                else
                    throw new Error('invalid overload');
            }
            indexOf$java_lang_String(x) {
                return this.string.indexOf(x);
            }
            indexOf$java_lang_String$int(x, start) {
                return this.string.indexOf(x, start);
            }
            indexOf(x, start) {
                if (((typeof x === 'string') || x === null) && ((typeof start === 'number') || start === null)) {
                    return this.indexOf$java_lang_String$int(x, start);
                }
                else if (((typeof x === 'string') || x === null) && start === undefined) {
                    return this.indexOf$java_lang_String(x);
                }
                else
                    throw new Error('invalid overload');
            }
            lastIndexOf$java_lang_String(s) {
                return this.string.lastIndexOf(s);
            }
            lastIndexOf$java_lang_String$int(s, start) {
                return this.string.lastIndexOf(s, start);
            }
            lastIndexOf(s, start) {
                if (((typeof s === 'string') || s === null) && ((typeof start === 'number') || start === null)) {
                    return this.lastIndexOf$java_lang_String$int(s, start);
                }
                else if (((typeof s === 'string') || s === null) && start === undefined) {
                    return this.lastIndexOf$java_lang_String(s);
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             *
             * @return {string}
             */
            toString() {
                return this.string;
            }
            append0(x, start, end) {
                if (x == null) {
                    x = "null";
                }
                this.string += x.substring(start, end);
            }
            appendCodePoint0(x) {
                this.string += new String(/* toChars */ String.fromCharCode(x)).toString();
            }
            replace0(start, end, toInsert) {
                this.string = this.string.substring(0, start) + toInsert + this.string.substring(end);
            }
            reverse0() {
                let length = this.string.length;
                if (length <= 1) {
                    return;
                }
                let buffer = (s => { let a = []; while (s-- > 0)
                    a.push(null); return a; })(length);
                buffer[0] = this.string.charAt(length - 1);
                for (let i = 1; i < length; i++) {
                    {
                        buffer[i] = this.string.charAt(length - 1 - i);
                        if (javaemul.internal.CharacterHelper.isSurrogatePair(buffer[i], buffer[i - 1])) {
                            AbstractStringBuilder.swap(buffer, i - 1, i);
                        }
                    }
                    ;
                }
                this.string = new String(buffer);
            }
            /*private*/ static swap(buffer, f, s) {
                let tmp = buffer[f];
                buffer[f] = buffer[s];
                buffer[s] = tmp;
            }
        }
        lang.AbstractStringBuilder = AbstractStringBuilder;
        AbstractStringBuilder["__class"] = "java.lang.AbstractStringBuilder";
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
(function (java) {
    var lang;
    (function (lang) {
        var annotation;
        (function (annotation) {
            /**
             * Indicates the annotation parser determined the annotation was malformed when
             * reading from the class file <a
             * href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/annotation/AnnotationFormatError.html">[Sun
             * docs]</a>.
             * @class
             * @extends java.lang.Error
             */
            class AnnotationFormatError extends Error {
                constructor() {
                    super();
                    Object.setPrototypeOf(this, AnnotationFormatError.prototype);
                }
            }
            annotation.AnnotationFormatError = AnnotationFormatError;
            AnnotationFormatError["__class"] = "java.lang.annotation.AnnotationFormatError";
            AnnotationFormatError["__interfaces"] = ["java.io.Serializable"];
        })(annotation = lang.annotation || (lang.annotation = {}));
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
(function (java) {
    var lang;
    (function (lang) {
        var annotation;
        (function (annotation) {
            /**
             * Enumerates types of declared elements in a Java program <a
             * href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/annotation/ElementType.html">[Sun
             * docs]</a>.
             * @enum
             * @property {java.lang.annotation.ElementType} ANNOTATION_TYPE
             * @property {java.lang.annotation.ElementType} CONSTRUCTOR
             * @property {java.lang.annotation.ElementType} FIELD
             * @property {java.lang.annotation.ElementType} LOCAL_VARIABLE
             * @property {java.lang.annotation.ElementType} METHOD
             * @property {java.lang.annotation.ElementType} PACKAGE
             * @property {java.lang.annotation.ElementType} PARAMETER
             * @property {java.lang.annotation.ElementType} TYPE
             * @class
             */
            var ElementType;
            (function (ElementType) {
                ElementType[ElementType["ANNOTATION_TYPE"] = 0] = "ANNOTATION_TYPE";
                ElementType[ElementType["CONSTRUCTOR"] = 1] = "CONSTRUCTOR";
                ElementType[ElementType["FIELD"] = 2] = "FIELD";
                ElementType[ElementType["LOCAL_VARIABLE"] = 3] = "LOCAL_VARIABLE";
                ElementType[ElementType["METHOD"] = 4] = "METHOD";
                ElementType[ElementType["PACKAGE"] = 5] = "PACKAGE";
                ElementType[ElementType["PARAMETER"] = 6] = "PARAMETER";
                ElementType[ElementType["TYPE"] = 7] = "TYPE";
            })(ElementType = annotation.ElementType || (annotation.ElementType = {}));
        })(annotation = lang.annotation || (lang.annotation = {}));
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
(function (java) {
    var lang;
    (function (lang) {
        var annotation;
        (function (annotation) {
            /**
             * Enumerates annotation retention policies <a
             * href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/annotation/RetentionPolicy.html">[Sun
             * docs]</a>.
             * @enum
             * @property {java.lang.annotation.RetentionPolicy} CLASS
             * @property {java.lang.annotation.RetentionPolicy} RUNTIME
             * @property {java.lang.annotation.RetentionPolicy} SOURCE
             * @class
             */
            var RetentionPolicy;
            (function (RetentionPolicy) {
                RetentionPolicy[RetentionPolicy["CLASS"] = 0] = "CLASS";
                RetentionPolicy[RetentionPolicy["RUNTIME"] = 1] = "RUNTIME";
                RetentionPolicy[RetentionPolicy["SOURCE"] = 2] = "SOURCE";
            })(RetentionPolicy = annotation.RetentionPolicy || (annotation.RetentionPolicy = {}));
        })(annotation = lang.annotation || (lang.annotation = {}));
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
(function (java) {
    var lang;
    (function (lang) {
        /**
         * Represents an error caused by an assertion failure.
         * @param {string} message
         * @param {java.lang.Throwable} cause
         * @class
         * @extends java.lang.Error
         */
        class AssertionError extends Error {
            constructor(message, cause) {
                if (((typeof message === 'string') || message === null) && ((cause != null && cause instanceof Error) || cause === null)) {
                    let __args = arguments;
                    super(message);
                    this.message = message;
                    Object.setPrototypeOf(this, AssertionError.prototype);
                }
                else if (((typeof message === 'string') || message === null) && cause === undefined) {
                    let __args = arguments;
                    super(message);
                    this.message = message;
                    Object.setPrototypeOf(this, AssertionError.prototype);
                }
                else if (((typeof message === 'boolean') || message === null) && cause === undefined) {
                    let __args = arguments;
                    {
                        let __args = arguments;
                        let message = new String(__args[0]).toString();
                        super(message);
                        this.message = message;
                        Object.setPrototypeOf(this, AssertionError.prototype);
                    }
                }
                else if (((typeof message === 'string') || message === null) && cause === undefined) {
                    let __args = arguments;
                    {
                        let __args = arguments;
                        let message = new String(__args[0]).toString();
                        super(message);
                        this.message = message;
                        Object.setPrototypeOf(this, AssertionError.prototype);
                    }
                }
                else if (((typeof message === 'number') || message === null) && cause === undefined) {
                    let __args = arguments;
                    {
                        let __args = arguments;
                        let message = new String(__args[0]).toString();
                        super(message);
                        this.message = message;
                        Object.setPrototypeOf(this, AssertionError.prototype);
                    }
                }
                else if (((typeof message === 'number') || message === null) && cause === undefined) {
                    let __args = arguments;
                    {
                        let __args = arguments;
                        let message = new String(__args[0]).toString();
                        super(message);
                        this.message = message;
                        Object.setPrototypeOf(this, AssertionError.prototype);
                    }
                }
                else if (((typeof message === 'number') || message === null) && cause === undefined) {
                    let __args = arguments;
                    {
                        let __args = arguments;
                        let message = new String(__args[0]).toString();
                        super(message);
                        this.message = message;
                        Object.setPrototypeOf(this, AssertionError.prototype);
                    }
                }
                else if (((typeof message === 'number') || message === null) && cause === undefined) {
                    let __args = arguments;
                    {
                        let __args = arguments;
                        let message = new String(__args[0]).toString();
                        super(message);
                        this.message = message;
                        Object.setPrototypeOf(this, AssertionError.prototype);
                    }
                }
                else if (((message != null) || message === null) && cause === undefined) {
                    let __args = arguments;
                    super(/* valueOf */ new String(message).toString());
                    this.message = new String(message).toString();
                    Object.setPrototypeOf(this, AssertionError.prototype);
                }
                else if (message === undefined && cause === undefined) {
                    let __args = arguments;
                    super();
                    Object.setPrototypeOf(this, AssertionError.prototype);
                }
                else
                    throw new Error('invalid overload');
            }
        }
        lang.AssertionError = AssertionError;
        AssertionError["__class"] = "java.lang.AssertionError";
        AssertionError["__interfaces"] = ["java.io.Serializable"];
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
(function (java) {
    var lang;
    (function (lang) {
        /**
         * Generally unsupported. This class is provided so that the GWT compiler can
         * choke down class literal references.
         * <p>
         * NOTE: The code in this class is very sensitive and should keep its
         * dependencies upon other classes to a minimum.
         *
         * @param <T>
         * the type of the object
         * @class
         */
        class Class {
            constructor() {
                /*private*/ this.sequentialId = Class.nextSequentialId++;
                if (this.enumValueOfFunc === undefined)
                    this.enumValueOfFunc = null;
                if (this.modifiers === undefined)
                    this.modifiers = 0;
                if (this.componentType === undefined)
                    this.componentType = null;
                if (this.enumConstantsFunc === undefined)
                    this.enumConstantsFunc = null;
                if (this.enumSuperclass === undefined)
                    this.enumSuperclass = null;
                if (this.superclass === undefined)
                    this.superclass = null;
                if (this.simpleName === undefined)
                    this.simpleName = null;
                if (this.typeName === undefined)
                    this.typeName = null;
                if (this.canonicalName === undefined)
                    this.canonicalName = null;
                if (this.packageName === undefined)
                    this.packageName = null;
                if (this.compoundName === undefined)
                    this.compoundName = null;
                if (this.typeId === undefined)
                    this.typeId = null;
                if (this.arrayLiterals === undefined)
                    this.arrayLiterals = null;
                this.typeName = null;
                this.simpleName = null;
                this.packageName = null;
                this.compoundName = null;
                this.canonicalName = null;
                this.typeId = null;
                this.arrayLiterals = null;
            }
            static constructors_$LI$() { if (Class.constructors == null)
                Class.constructors = (new Array()); return Class.constructors; }
            ;
            static classes_$LI$() { if (Class.classes == null)
                Class.classes = (new Array()); return Class.classes; }
            ;
            static getConstructorForClass(clazz) {
                let index = (Class.classes_$LI$().indexOf(clazz) | 0);
                return index === -1 ? null : Class.constructors_$LI$()[index];
            }
            static getClassForConstructor(constructor) {
                let index = (Class.constructors_$LI$().indexOf(constructor) | 0);
                return index === -1 ? null : Class.classes_$LI$()[index];
            }
            static mapConstructorToClass(constructor, clazz) {
                Class.constructors_$LI$().push(constructor);
                Class.classes_$LI$().push(clazz);
            }
            /**
             * Create a Class object for an array.
             * <p>
             *
             * Arrays are not registered in the prototype table and get the class
             * literal explicitly at construction.
             * <p>
             * @param {java.lang.Class} leafClass
             * @param {number} dimensions
             * @return {java.lang.Class}
             * @private
             */
            /*private*/ static getClassLiteralForArray(leafClass, dimensions) {
                let arrayLiterals = leafClass.arrayLiterals = leafClass.arrayLiterals == null ? [] : leafClass.arrayLiterals;
                return arrayLiterals[dimensions] != null ? arrayLiterals[dimensions] : (arrayLiterals[dimensions] = leafClass.createClassLiteralForArray(dimensions));
            }
            /*private*/ createClassLiteralForArray(dimensions) {
                let clazz = (new java.lang.Class());
                clazz.modifiers = Class.ARRAY;
                clazz.superclass = Object;
                if (dimensions > 1) {
                    clazz.componentType = Class.getClassLiteralForArray(this, dimensions - 1);
                }
                else {
                    clazz.componentType = this;
                }
                return clazz;
            }
            /**
             * Create a Class object for a class.
             *
             * @skip
             * @param {string} packageName
             * @param {string} compoundClassName
             * @param {string} typeId
             * @param {java.lang.Class} superclass
             * @return {java.lang.Class}
             */
            static createForClass(packageName, compoundClassName, typeId, superclass) {
                let clazz = Class.createClassObject(packageName, compoundClassName, typeId);
                clazz.superclass = superclass;
                return clazz;
            }
            /**
             * Create a Class object for an enum.
             *
             * @skip
             * @param {string} packageName
             * @param {string} compoundClassName
             * @param {string} typeId
             * @param {java.lang.Class} superclass
             * @param {Function} enumConstantsFunc
             * @param {Function} enumValueOfFunc
             * @return {java.lang.Class}
             */
            static createForEnum(packageName, compoundClassName, typeId, superclass, enumConstantsFunc, enumValueOfFunc) {
                let clazz = Class.createClassObject(packageName, compoundClassName, typeId);
                clazz.modifiers = (enumConstantsFunc != null) ? Class.ENUM : 0;
                clazz.superclass = clazz.enumSuperclass = superclass;
                clazz.enumConstantsFunc = enumConstantsFunc;
                clazz.enumValueOfFunc = enumValueOfFunc;
                return clazz;
            }
            /**
             * Create a Class object for an interface.
             *
             * @skip
             * @param {string} packageName
             * @param {string} compoundClassName
             * @return {java.lang.Class}
             */
            static createForInterface(packageName, compoundClassName) {
                let clazz = Class.createClassObject(packageName, compoundClassName, null);
                clazz.modifiers = Class.INTERFACE;
                return clazz;
            }
            /**
             * Create a Class object for a primitive.
             *
             * @skip
             * @param {string} className
             * @param {string} primitiveTypeId
             * @return {java.lang.Class}
             */
            static createForPrimitive(className, primitiveTypeId) {
                let clazz = Class.createClassObject("", className, primitiveTypeId);
                clazz.modifiers = Class.PRIMITIVE;
                return clazz;
            }
            /**
             * Used by {@link WebModePayloadSink} to create uninitialized instances.
             * @param {java.lang.Class} clazz
             * @return {*}
             */
            static getPrototypeForClass(clazz) {
                if (clazz.isPrimitive()) {
                    return null;
                }
                return Class.getConstructorForClass(clazz).prototype;
            }
            /**
             * Creates the class object for a type and initiliazes its fields.
             * @param {string} packageName
             * @param {string} compoundClassName
             * @param {string} typeId
             * @return {java.lang.Class}
             * @private
             */
            /*private*/ static createClassObject(packageName, compoundClassName, typeId) {
                let clazz = (new java.lang.Class());
                clazz.packageName = packageName;
                clazz.compoundName = compoundClassName;
                return clazz;
            }
            /**
             * Initiliazes {@code clazz} names from metadata.
             * <p>
             * Written in JSNI to minimize dependencies (on String.+).
             * @param {java.lang.Class} clazz
             * @private
             */
            /*private*/ static initializeNames(clazz) {
                if (clazz.isArray()) {
                    let componentType = clazz.componentType;
                    if (componentType.isPrimitive()) {
                        clazz.typeName = "[" + componentType.typeId;
                    }
                    else if (!componentType.isArray()) {
                        clazz.typeName = "[L" + (c => c["__class"] ? c["__class"] : c["name"])(componentType) + ";";
                    }
                    else {
                        clazz.typeName = "[" + (c => c["__class"] ? c["__class"] : c["name"])(componentType);
                    }
                    clazz.canonicalName = componentType.getCanonicalName() + "[]";
                    clazz.simpleName = (c => c["__class"] ? c["__class"].substring(c["__class"].lastIndexOf('.') + 1) : c["name"].substring(c["name"].lastIndexOf('.') + 1))(componentType) + "[]";
                    return;
                }
                let packageName = clazz.packageName;
                let compoundName = clazz.compoundName.split("/");
                clazz.typeName = [packageName, (compoundName).join("$")].join(".");
                clazz.canonicalName = [packageName, (compoundName).join(".")].join(".");
                clazz.simpleName = compoundName[compoundName.length - 1];
            }
            /**
             * Sets the class object for primitives.
             * <p>
             * Written in JSNI to minimize dependencies (on (String)+).
             * @param {java.lang.Class} clazz
             * @param {Object} primitiveTypeId
             */
            static synthesizePrimitiveNamesFromTypeId(clazz, primitiveTypeId) {
                clazz.typeName = "Class$" + primitiveTypeId;
                clazz.canonicalName = clazz.typeName;
                clazz.simpleName = clazz.typeName;
            }
            desiredAssertionStatus() {
                return false;
            }
            /*private*/ ensureNamesAreInitialized() {
                if (this.typeName != null) {
                    return;
                }
                Class.initializeNames(this);
            }
            getCanonicalName() {
                this.ensureNamesAreInitialized();
                return this.canonicalName;
            }
            getComponentType() {
                return this.componentType;
            }
            getEnumConstants() {
                return (this.enumConstantsFunc && (this.enumConstantsFunc)());
            }
            getName() {
                this.ensureNamesAreInitialized();
                return this.typeName;
            }
            getSimpleName() {
                this.ensureNamesAreInitialized();
                return this.simpleName;
            }
            getSuperclass() {
                return this.superclass;
            }
            isArray() {
                return (this.modifiers & Class.ARRAY) !== 0;
            }
            isEnum() {
                return (this.modifiers & Class.ENUM) !== 0;
            }
            isInterface() {
                return (this.modifiers & Class.INTERFACE) !== 0;
            }
            isPrimitive() {
                return (this.modifiers & Class.PRIMITIVE) !== 0;
            }
            /**
             *
             * @return {string}
             */
            toString() {
                return (this.isInterface() ? "interface " : (this.isPrimitive() ? "" : "class ")) + (c => c["__class"] ? c["__class"] : c["name"])(this);
            }
            /**
             * Used by Enum to allow getSuperclass() to be pruned.
             * @return {java.lang.Class}
             */
            getEnumSuperclass() {
                return this.enumSuperclass;
            }
        }
        Class.PRIMITIVE = 1;
        Class.INTERFACE = 2;
        Class.ARRAY = 4;
        Class.ENUM = 8;
        Class.nextSequentialId = 1;
        lang.Class = Class;
        Class["__class"] = "java.lang.Class";
        Class["__interfaces"] = ["java.lang.reflect.Type"];
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
(function (java) {
    var lang;
    (function (lang) {
        /**
         * The first-class representation of an enumeration.
         *
         * @param <E>
         * @class
         */
        class Enum {
            constructor(name, ordinal) {
                if (this.__name === undefined)
                    this.__name = null;
                if (this.__ordinal === undefined)
                    this.__ordinal = 0;
                this.__name = name;
                this.__ordinal = ordinal;
            }
            static valueOf$java_lang_Class$java_lang_String(enumType, name) {
                let enumValueOfFunc = javaemul.internal.InternalPreconditions.checkNotNull(enumType).enumValueOfFunc;
                javaemul.internal.InternalPreconditions.checkCriticalArgument(enumValueOfFunc != null, "EnumValueOfFunc is null at enum class: %s, enum value name: %s", /* getName */ (c => c["__class"] ? c["__class"] : c["name"])(enumType), name);
                javaemul.internal.InternalPreconditions.checkNotNull(name);
                return (Enum.invokeValueOf(enumValueOfFunc, name));
            }
            static valueOf(enumType, name) {
                if (((enumType != null && enumType instanceof java.lang.Class) || enumType === null) && ((typeof name === 'string') || name === null)) {
                    return java.lang.Enum.valueOf$java_lang_Class$java_lang_String(enumType, name);
                }
                else if (((enumType != null && enumType instanceof Object) || enumType === null) && ((typeof name === 'string') || name === null)) {
                    return java.lang.Enum.valueOf$def_js_Object$java_lang_String(enumType, name);
                }
                else
                    throw new Error('invalid overload');
            }
            static createValueOfMap(enumConstants) {
                let result = new Object();
                for (let index121 = 0; index121 < enumConstants.length; index121++) {
                    let value = enumConstants[index121];
                    {
                        Enum.put0(result, ":" + value.name(), value);
                    }
                }
                return result;
            }
            static valueOf$def_js_Object$java_lang_String(map, name) {
                javaemul.internal.InternalPreconditions.checkNotNull(name);
                let result = (java.lang.Enum.get0(map, ":" + name));
                javaemul.internal.InternalPreconditions.checkCriticalArgument(result != null, "Enum constant undefined: %s", name);
                return result;
            }
            /*private*/ static get0(map, name) {
                return (map[name]);
            }
            /*private*/ static invokeValueOf(enumValueOfFunc, name) {
                return (enumValueOfFunc(name));
            }
            /*private*/ static put0(map, name, value) {
                map[name] = value;
            }
            compareTo$java_lang_Enum(other) {
                return this.__ordinal - other.__ordinal;
            }
            /**
             *
             * @param {java.lang.Enum} other
             * @return {number}
             */
            compareTo(other) {
                if (((other != null) || other === null)) {
                    return this.compareTo$java_lang_Enum(other);
                }
                else
                    throw new Error('invalid overload');
            }
            getDeclaringClass() {
                return null;
            }
            name() {
                return this.__name != null ? this.__name : "" + this.__ordinal;
            }
            ordinal() {
                return this.__ordinal;
            }
            /**
             *
             * @return {string}
             */
            toString() {
                return this.name();
            }
        }
        lang.Enum = Enum;
        Enum["__class"] = "java.lang.Enum";
        Enum["__interfaces"] = ["java.lang.Comparable", "java.io.Serializable"];
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
(function (java) {
    var lang;
    (function (lang) {
        /**
         * See <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/Exception.html">the
         * official Java API doc</a> for details.
         * @param {string} message
         * @param {java.lang.Throwable} cause
         * @class
         * @extends java.lang.Throwable
         */
        class Exception extends Error {
            constructor(message, cause, enableSuppression, writableStackTrace) {
                if (((typeof message === 'string') || message === null) && ((cause != null && cause instanceof Error) || cause === null) && ((typeof enableSuppression === 'boolean') || enableSuppression === null) && ((typeof writableStackTrace === 'boolean') || writableStackTrace === null)) {
                    let __args = arguments;
                    super(message);
                    this.message = message;
                    Object.setPrototypeOf(this, Exception.prototype);
                }
                else if (((typeof message === 'string') || message === null) && ((cause != null && cause instanceof Error) || cause === null) && enableSuppression === undefined && writableStackTrace === undefined) {
                    let __args = arguments;
                    super(message);
                    this.message = message;
                    Object.setPrototypeOf(this, Exception.prototype);
                }
                else if (((typeof message === 'string') || message === null) && cause === undefined && enableSuppression === undefined && writableStackTrace === undefined) {
                    let __args = arguments;
                    super(message);
                    this.message = message;
                    Object.setPrototypeOf(this, Exception.prototype);
                }
                else if (((message != null && message instanceof Error) || message === null) && cause === undefined && enableSuppression === undefined && writableStackTrace === undefined) {
                    let __args = arguments;
                    let cause = __args[0];
                    super(cause);
                    this.message = cause;
                    Object.setPrototypeOf(this, Exception.prototype);
                }
                else if (message === undefined && cause === undefined && enableSuppression === undefined && writableStackTrace === undefined) {
                    let __args = arguments;
                    super();
                    Object.setPrototypeOf(this, Exception.prototype);
                }
                else
                    throw new Error('invalid overload');
            }
        }
        lang.Exception = Exception;
        Exception["__class"] = "java.lang.Exception";
        Exception["__interfaces"] = ["java.io.Serializable"];
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
(function (java) {
    var lang;
    (function (lang) {
        class IllegalAccessError extends Error {
            constructor(message, cause) {
                if (((typeof message === 'string') || message === null) && ((cause != null && cause instanceof Error) || cause === null)) {
                    let __args = arguments;
                    super(message);
                    this.message = message;
                    Object.setPrototypeOf(this, IllegalAccessError.prototype);
                }
                else if (((typeof message === 'string') || message === null) && cause === undefined) {
                    let __args = arguments;
                    super(message);
                    this.message = message;
                    Object.setPrototypeOf(this, IllegalAccessError.prototype);
                }
                else if (((message != null && message instanceof Error) || message === null) && cause === undefined) {
                    let __args = arguments;
                    let cause = __args[0];
                    super(cause);
                    this.message = cause;
                    Object.setPrototypeOf(this, IllegalAccessError.prototype);
                }
                else if (message === undefined && cause === undefined) {
                    let __args = arguments;
                    super();
                    Object.setPrototypeOf(this, IllegalAccessError.prototype);
                }
                else
                    throw new Error('invalid overload');
            }
        }
        lang.IllegalAccessError = IllegalAccessError;
        IllegalAccessError["__class"] = "java.lang.IllegalAccessError";
        IllegalAccessError["__interfaces"] = ["java.io.Serializable"];
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
(function (java) {
    var lang;
    (function (lang) {
        class NoSuchMethodError extends Error {
            constructor(message, cause) {
                if (((typeof message === 'string') || message === null) && ((cause != null && cause instanceof Error) || cause === null)) {
                    let __args = arguments;
                    super(message);
                    this.message = message;
                    Object.setPrototypeOf(this, NoSuchMethodError.prototype);
                }
                else if (((typeof message === 'string') || message === null) && cause === undefined) {
                    let __args = arguments;
                    super(message);
                    this.message = message;
                    Object.setPrototypeOf(this, NoSuchMethodError.prototype);
                }
                else if (((message != null && message instanceof Error) || message === null) && cause === undefined) {
                    let __args = arguments;
                    let cause = __args[0];
                    super(cause);
                    this.message = cause;
                    Object.setPrototypeOf(this, NoSuchMethodError.prototype);
                }
                else if (message === undefined && cause === undefined) {
                    let __args = arguments;
                    super();
                    Object.setPrototypeOf(this, NoSuchMethodError.prototype);
                }
                else
                    throw new Error('invalid overload');
            }
        }
        lang.NoSuchMethodError = NoSuchMethodError;
        NoSuchMethodError["__class"] = "java.lang.NoSuchMethodError";
        NoSuchMethodError["__interfaces"] = ["java.io.Serializable"];
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
(function (java) {
    var lang;
    (function (lang) {
        var ref;
        (function (ref) {
            /**
             * This implements the reference API in a minimal way. In JavaScript, there is
             * no control over the reference and the GC. So this implementation's only
             * purpose is for compilation.
             * @class
             */
            class Reference {
                constructor(referent) {
                    if (this.referent === undefined)
                        this.referent = null;
                    this.referent = referent;
                }
                get() {
                    return this.referent;
                }
                clear() {
                    this.referent = null;
                }
            }
            ref.Reference = Reference;
            Reference["__class"] = "java.lang.ref.Reference";
        })(ref = lang.ref || (lang.ref = {}));
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
(function (java) {
    var lang;
    (function (lang) {
        /**
         * Included for hosted mode source compatibility. Partially implemented
         *
         * @skip
         * @param {string} className
         * @param {string} methodName
         * @param {string} fileName
         * @param {number} lineNumber
         * @class
         */
        class StackTraceElement {
            constructor(className, methodName, fileName, lineNumber) {
                if (((typeof className === 'string') || className === null) && ((typeof methodName === 'string') || methodName === null) && ((typeof fileName === 'string') || fileName === null) && ((typeof lineNumber === 'number') || lineNumber === null)) {
                    let __args = arguments;
                    if (this.className === undefined)
                        this.className = null;
                    if (this.fileName === undefined)
                        this.fileName = null;
                    if (this.lineNumber === undefined)
                        this.lineNumber = 0;
                    if (this.methodName === undefined)
                        this.methodName = null;
                    if (this.className === undefined)
                        this.className = null;
                    if (this.fileName === undefined)
                        this.fileName = null;
                    if (this.lineNumber === undefined)
                        this.lineNumber = 0;
                    if (this.methodName === undefined)
                        this.methodName = null;
                    (() => {
                        this.className = className;
                        this.methodName = methodName;
                        this.fileName = fileName;
                        this.lineNumber = lineNumber;
                    })();
                }
                else if (className === undefined && methodName === undefined && fileName === undefined && lineNumber === undefined) {
                    let __args = arguments;
                    if (this.className === undefined)
                        this.className = null;
                    if (this.fileName === undefined)
                        this.fileName = null;
                    if (this.lineNumber === undefined)
                        this.lineNumber = 0;
                    if (this.methodName === undefined)
                        this.methodName = null;
                    if (this.className === undefined)
                        this.className = null;
                    if (this.fileName === undefined)
                        this.fileName = null;
                    if (this.lineNumber === undefined)
                        this.lineNumber = 0;
                    if (this.methodName === undefined)
                        this.methodName = null;
                }
                else
                    throw new Error('invalid overload');
            }
            getClassName() {
                return this.className;
            }
            getFileName() {
                return this.fileName;
            }
            getLineNumber() {
                return this.lineNumber;
            }
            getMethodName() {
                return this.methodName;
            }
            /**
             *
             * @param {*} other
             * @return {boolean}
             */
            equals(other) {
                if (other != null && other instanceof java.lang.StackTraceElement) {
                    let st = other;
                    return this.lineNumber === st.lineNumber && java.util.Objects.equals(this.methodName, st.methodName) && java.util.Objects.equals(this.className, st.className) && java.util.Objects.equals(this.fileName, st.fileName);
                }
                return false;
            }
            /**
             *
             * @return {number}
             */
            hashCode() {
                return java.util.Objects.hash(this.lineNumber, this.className, this.methodName, this.fileName);
            }
            /**
             *
             * @return {string}
             */
            toString() {
                return this.className + "." + this.methodName + "(" + (this.fileName != null ? this.fileName : "Unknown Source") + (this.lineNumber >= 0 ? ":" + this.lineNumber : "") + ")";
            }
        }
        lang.StackTraceElement = StackTraceElement;
        StackTraceElement["__class"] = "java.lang.StackTraceElement";
        StackTraceElement["__interfaces"] = ["java.io.Serializable"];
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
(function (java) {
    var lang;
    (function (lang) {
        /**
         * Constructs a {@code VirtualMachineError} with the specified
         * detail message and cause.  <p>Note that the detail message
         * associated with {@code cause} is <i>not</i> automatically
         * incorporated in this error's detail message.
         *
         * @param  {string} message the detail message (which is saved for later retrieval
         * by the {@link #getMessage()} method).
         * @param  {java.lang.Throwable} cause the cause (which is saved for later retrieval by the
         * {@link #getCause()} method).  (A {@code null} value is
         * permitted, and indicates that the cause is nonexistent or
         * unknown.)
         * @since  1.8
         * @class
         * @extends java.lang.Error
         * @author  Frank Yellin
         */
        class VirtualMachineError extends Error {
            constructor(message, cause) {
                if (((typeof message === 'string') || message === null) && ((cause != null && cause instanceof Error) || cause === null)) {
                    let __args = arguments;
                    super(message);
                    this.message = message;
                    Object.setPrototypeOf(this, VirtualMachineError.prototype);
                }
                else if (((typeof message === 'string') || message === null) && cause === undefined) {
                    let __args = arguments;
                    super(message);
                    this.message = message;
                    Object.setPrototypeOf(this, VirtualMachineError.prototype);
                }
                else if (((message != null && message instanceof Error) || message === null) && cause === undefined) {
                    let __args = arguments;
                    let cause = __args[0];
                    super(cause);
                    this.message = cause;
                    Object.setPrototypeOf(this, VirtualMachineError.prototype);
                }
                else if (message === undefined && cause === undefined) {
                    let __args = arguments;
                    super();
                    Object.setPrototypeOf(this, VirtualMachineError.prototype);
                }
                else
                    throw new Error('invalid overload');
            }
        }
        VirtualMachineError.serialVersionUID = 4161983926571568670;
        lang.VirtualMachineError = VirtualMachineError;
        VirtualMachineError["__class"] = "java.lang.VirtualMachineError";
        VirtualMachineError["__interfaces"] = ["java.io.Serializable"];
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
(function (java) {
    var lang;
    (function (lang) {
        /**
         * For JRE compatibility.
         * @class
         */
        class Void {
            constructor() {
            }
        }
        lang.Void = Void;
        Void["__class"] = "java.lang.Void";
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
(function (java) {
    var net;
    (function (net) {
        class InternalJsURLFactory {
            constructor() {
            }
            static jsURLCtor_$LI$() { if (InternalJsURLFactory.jsURLCtor == null)
                InternalJsURLFactory.jsURLCtor = InternalJsURLFactory.getJsURLConstructor(); return InternalJsURLFactory.jsURLCtor; }
            ;
            /*private*/ static getJsURLConstructor() {
                let URLConstructor;
                if (java.lang.System.ENVIRONMENT_IS_NODE_$LI$()) {
                    URLConstructor = (eval("global.URL || (global.URL = require(\"url\").URL)"));
                }
                else if (java.lang.System.ENVIRONMENT_IS_SHELL_$LI$()) {
                    let internalJsURLForShellClass = java.net.InternalJsURLForShell;
                    URLConstructor = (eval("this.URL || (this.URL = internalJsURLForShellClass)"));
                }
                else {
                    URLConstructor = (() => eval("URL")).call(null);
                }
                return URLConstructor;
            }
            static newJsURL(...objects) {
                let ctor = InternalJsURLFactory.jsURLCtor_$LI$();
                return (new (ctor.bind.apply(ctor, [null].concat(objects)))());
            }
        }
        net.InternalJsURLFactory = InternalJsURLFactory;
        InternalJsURLFactory["__class"] = "java.net.InternalJsURLFactory";
    })(net = java.net || (java.net = {}));
})(java || (java = {}));
(function (java) {
    var net;
    (function (net) {
        class InternalJsURLForShell {
            constructor(data, url) {
                if (((typeof data === 'string') || data === null) && ((url != null && url instanceof Object) || url === null)) {
                    let __args = arguments;
                    {
                        let __args = arguments;
                        let data = url["href"] + __args[0];
                        if (this.href === undefined)
                            this.href = null;
                        if (this.protocol === undefined)
                            this.protocol = null;
                        if (this.username === undefined)
                            this.username = null;
                        if (this.password === undefined)
                            this.password = null;
                        if (this.hostname === undefined)
                            this.hostname = null;
                        if (this.port === undefined)
                            this.port = null;
                        if (this.pathname === undefined)
                            this.pathname = null;
                        if (this.search === undefined)
                            this.search = null;
                        if (this.hash === undefined)
                            this.hash = null;
                        if (this.href === undefined)
                            this.href = null;
                        if (this.protocol === undefined)
                            this.protocol = null;
                        if (this.username === undefined)
                            this.username = null;
                        if (this.password === undefined)
                            this.password = null;
                        if (this.hostname === undefined)
                            this.hostname = null;
                        if (this.port === undefined)
                            this.port = null;
                        if (this.pathname === undefined)
                            this.pathname = null;
                        if (this.search === undefined)
                            this.search = null;
                        if (this.hash === undefined)
                            this.hash = null;
                        (() => {
                            this.href = data;
                            let protocolEnd = data.indexOf("://");
                            if (protocolEnd === -1)
                                throw new Error("Wrong URL, no protocol");
                            this.protocol = data.substring(0, protocolEnd);
                            let userPassEnd = data.indexOf("@", protocolEnd + 3);
                            let userEnd = userPassEnd === -1 ? -1 : data.indexOf(":", protocolEnd + 3);
                            if (userEnd > userPassEnd)
                                userEnd = -1;
                            this.username = userPassEnd === -1 ? null : userEnd === -1 ? data.substring(protocolEnd + 3, userPassEnd) : data.substring(protocolEnd + 3, userEnd);
                            this.password = userPassEnd === -1 || userEnd === -1 ? null : data.substring(userPassEnd + 1, userEnd);
                            let hostStart = userPassEnd === -1 ? protocolEnd + 3 : userPassEnd + 1;
                            let hostPortEnd = data.indexOf("/", hostStart);
                            let portStart = data.indexOf(":", hostStart);
                            this.hostname = portStart === -1 || portStart > hostPortEnd ? data.substring(hostStart, hostPortEnd) : data.substring(hostStart, portStart);
                            this.port = portStart !== -1 && portStart < hostPortEnd ? javaemul.internal.IntegerHelper.parseInt(data.substring(portStart + 1, hostPortEnd)) : null;
                            let searchStart = data.indexOf("?", hostPortEnd);
                            let hashStart = data.indexOf("#", hostPortEnd);
                            this.search = searchStart !== -1 ? hashStart === -1 ? data.substring(searchStart + 1) : data.substring(searchStart + 1, hashStart) : null;
                            this.hash = hashStart !== -1 ? data.substring(hashStart + 1) : null;
                            this.pathname = searchStart === -1 && hashStart === -1 ? data.substring(hostPortEnd + 1) : data.substring(hostPortEnd + 1, searchStart === -1 ? hashStart : searchStart);
                        })();
                    }
                }
                else if (((typeof data === 'string') || data === null) && url === undefined) {
                    let __args = arguments;
                    if (this.href === undefined)
                        this.href = null;
                    if (this.protocol === undefined)
                        this.protocol = null;
                    if (this.username === undefined)
                        this.username = null;
                    if (this.password === undefined)
                        this.password = null;
                    if (this.hostname === undefined)
                        this.hostname = null;
                    if (this.port === undefined)
                        this.port = null;
                    if (this.pathname === undefined)
                        this.pathname = null;
                    if (this.search === undefined)
                        this.search = null;
                    if (this.hash === undefined)
                        this.hash = null;
                    if (this.href === undefined)
                        this.href = null;
                    if (this.protocol === undefined)
                        this.protocol = null;
                    if (this.username === undefined)
                        this.username = null;
                    if (this.password === undefined)
                        this.password = null;
                    if (this.hostname === undefined)
                        this.hostname = null;
                    if (this.port === undefined)
                        this.port = null;
                    if (this.pathname === undefined)
                        this.pathname = null;
                    if (this.search === undefined)
                        this.search = null;
                    if (this.hash === undefined)
                        this.hash = null;
                    (() => {
                        this.href = data;
                        let protocolEnd = data.indexOf("://");
                        if (protocolEnd === -1)
                            throw new Error("Wrong URL, no protocol");
                        this.protocol = data.substring(0, protocolEnd);
                        let userPassEnd = data.indexOf("@", protocolEnd + 3);
                        let userEnd = userPassEnd === -1 ? -1 : data.indexOf(":", protocolEnd + 3);
                        if (userEnd > userPassEnd)
                            userEnd = -1;
                        this.username = userPassEnd === -1 ? null : userEnd === -1 ? data.substring(protocolEnd + 3, userPassEnd) : data.substring(protocolEnd + 3, userEnd);
                        this.password = userPassEnd === -1 || userEnd === -1 ? null : data.substring(userPassEnd + 1, userEnd);
                        let hostStart = userPassEnd === -1 ? protocolEnd + 3 : userPassEnd + 1;
                        let hostPortEnd = data.indexOf("/", hostStart);
                        let portStart = data.indexOf(":", hostStart);
                        this.hostname = portStart === -1 || portStart > hostPortEnd ? data.substring(hostStart, hostPortEnd) : data.substring(hostStart, portStart);
                        this.port = portStart !== -1 && portStart < hostPortEnd ? javaemul.internal.IntegerHelper.parseInt(data.substring(portStart + 1, hostPortEnd)) : null;
                        let searchStart = data.indexOf("?", hostPortEnd);
                        let hashStart = data.indexOf("#", hostPortEnd);
                        this.search = searchStart !== -1 ? hashStart === -1 ? data.substring(searchStart + 1) : data.substring(searchStart + 1, hashStart) : null;
                        this.hash = hashStart !== -1 ? data.substring(hashStart + 1) : null;
                        this.pathname = searchStart === -1 && hashStart === -1 ? data.substring(hostPortEnd + 1) : data.substring(hostPortEnd + 1, searchStart === -1 ? hashStart : searchStart);
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
        }
        net.InternalJsURLForShell = InternalJsURLForShell;
        InternalJsURLForShell["__class"] = "java.net.InternalJsURLForShell";
    })(net = java.net || (java.net = {}));
})(java || (java = {}));
(function (java) {
    var net;
    (function (net) {
        class URL {
            constructor(protocol, host, port, file) {
                if (((typeof protocol === 'string') || protocol === null) && ((typeof host === 'string') || host === null) && ((typeof port === 'number') || port === null) && ((typeof file === 'string') || file === null)) {
                    let __args = arguments;
                    {
                        let __args = arguments;
                        let spec = protocol + "//" + host + ":" + port + "/" + file;
                        if (this.jsUrl === undefined)
                            this.jsUrl = null;
                        if (this.jsUrl === undefined)
                            this.jsUrl = null;
                        (() => {
                            this.jsUrl = java.net.InternalJsURLFactory.newJsURL(spec);
                        })();
                    }
                }
                else if (((typeof protocol === 'string') || protocol === null) && ((typeof host === 'string') || host === null) && ((typeof port === 'string') || port === null) && file === undefined) {
                    let __args = arguments;
                    let file = __args[2];
                    {
                        let __args = arguments;
                        let spec = protocol + "//" + host + "/" + file;
                        if (this.jsUrl === undefined)
                            this.jsUrl = null;
                        if (this.jsUrl === undefined)
                            this.jsUrl = null;
                        (() => {
                            this.jsUrl = java.net.InternalJsURLFactory.newJsURL(spec);
                        })();
                    }
                }
                else if (((protocol != null && protocol instanceof URL) || protocol === null) && ((typeof host === 'string') || host === null) && port === undefined && file === undefined) {
                    let __args = arguments;
                    let url = __args[0];
                    let string = __args[1];
                    if (this.jsUrl === undefined)
                        this.jsUrl = null;
                    if (this.jsUrl === undefined)
                        this.jsUrl = null;
                    (() => {
                        this.jsUrl = java.net.InternalJsURLFactory.newJsURL(string, url.jsUrl);
                    })();
                }
                else if (((typeof protocol === 'string') || protocol === null) && host === undefined && port === undefined && file === undefined) {
                    let __args = arguments;
                    let spec = __args[0];
                    if (this.jsUrl === undefined)
                        this.jsUrl = null;
                    if (this.jsUrl === undefined)
                        this.jsUrl = null;
                    (() => {
                        this.jsUrl = java.net.InternalJsURLFactory.newJsURL(spec);
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            openStream() {
                let request = this.makeConnection();
                switch ((request.responseType)) {
                    case "arraybuffer":
                        return new java.io.ByteArrayInputStream((new Int8Array(request.response)));
                    case "blob":
                        let fileReaderSyncConstructor = (self["FileReaderSync"]);
                        if (((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(typeof fileReaderSyncConstructor, "function")) {
                            return new java.io.ByteArrayInputStream(((fileReaderSyncConstructor["readAsArrayBuffer"])(request.response)));
                        }
                        return new java.io.ByteArrayInputStream(/* getBytes */ (URL.createObjectURL(request.response)).split('').map(s => s.charCodeAt(0)));
                    default:
                        return new java.io.ByteArrayInputStream(/* getBytes */ (request.response.toString()).split('').map(s => s.charCodeAt(0)));
                }
            }
            /*private*/ static createObjectURL(obj) {
                return ((java.net.InternalJsURLFactory.jsURLCtor_$LI$()["createObjectURL"])((obj)));
            }
            /**
             *
             * @param {*} o
             * @return {boolean}
             */
            equals(o) {
                if (this === o)
                    return true;
                if (!(o != null && o instanceof URL))
                    return false;
                let url = o;
                return java.util.Objects.equals(this.jsUrl, url.jsUrl);
            }
            /**
             *
             * @return {number}
             */
            hashCode() {
                return ((o) => { if (o.hashCode) {
                    return o.hashCode();
                }
                else {
                    return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                } })(this.jsUrl);
            }
            getAuthority() {
                let username = (this.jsUrl["username"]);
                let password = (this.jsUrl["password"]);
                if (username == null && password == null)
                    return "";
                if (username != null && password != null)
                    return username + ":" + password;
                return username != null ? username : password;
            }
            getContent() {
                return this.makeConnection().response;
            }
            getDefaultPort() {
                switch ((this.getProtocol().toLowerCase())) {
                    case "http":
                    case "ws":
                        return 80;
                    case "https":
                    case "wss":
                        return 443;
                    case "ftp":
                        return 21;
                    case "sftp":
                        return 22;
                    case "gopher":
                        return 70;
                    case "file":
                        return 0;
                }
                return -1;
            }
            getFile() {
                let wholePath = this.getPath();
                let query = this.getQuery();
                return wholePath + (query.length > 0 ? "?" + query : "");
            }
            getHost() {
                return (this.jsUrl["hostname"]);
            }
            getPath() {
                return (this.jsUrl["pathname"]);
            }
            getPort() {
                return (this.jsUrl["port"]);
            }
            getProtocol() {
                return (this.jsUrl["protocol"]);
            }
            getQuery() {
                return (this.jsUrl["search"]);
            }
            getRef() {
                return (this.jsUrl["hash"]);
            }
            getUserInfo() {
                return (this.jsUrl["username"]);
            }
            sameFile(other) {
                return java.util.Objects.equals(this.getProtocol(), other.getProtocol()) && java.util.Objects.equals(this.getAuthority(), other.getAuthority()) && java.util.Objects.equals(this.getHost(), other.getHost()) && this.getPort() === other.getPort() && java.util.Objects.equals(this.getFile(), other.getFile());
            }
            toExternalForm() {
                return this.jsUrl.toString();
            }
            /*private*/ makeConnection() {
                let request = new XMLHttpRequest();
                request.open("GET", (this.jsUrl["href"]), false);
                request.send();
                return request;
            }
            /**
             *
             * @return {string}
             */
            toString() {
                return (this.jsUrl["href"]);
            }
        }
        net.URL = URL;
        URL["__class"] = "java.net.URL";
        URL["__interfaces"] = ["java.io.Serializable"];
    })(net = java.net || (java.net = {}));
})(java || (java = {}));
(function (java) {
    var nio;
    (function (nio) {
        class Buffer {
            constructor(capacity, readOnly) {
                if (this._capacity === undefined)
                    this._capacity = 0;
                if (this.readOnly === undefined)
                    this.readOnly = false;
                if (this._position === undefined)
                    this._position = 0;
                if (this._limit === undefined)
                    this._limit = 0;
                if (this._mark === undefined)
                    this._mark = 0;
                this._capacity = capacity;
                this.readOnly = readOnly;
                this._position = 0;
                this._limit = capacity;
                this._mark = -1;
            }
            arrayOffset() {
                return 0;
            }
            capacity() {
                return this._capacity;
            }
            clear() {
                this._limit = this._capacity;
                this._position = 0;
                this._mark = -1;
                return this;
            }
            flip() {
                this._limit = this._position;
                this._position = 0;
                this._mark = -1;
                return this;
            }
            hasArray() {
                return this.array() != null;
            }
            hasRemaining() {
                return this._position < this._limit;
            }
            isDirect() {
                return false;
            }
            isReadOnly() {
                return this.readOnly;
            }
            limit$() {
                return this._limit;
            }
            limit$int(newLimit) {
                if (newLimit > this._capacity)
                    throw new java.lang.IllegalArgumentException("limit is bigger than capacity");
                this._limit = newLimit;
                this._position = Math.min(this._position, this._limit);
                if (this._mark > this._limit)
                    this._mark = -1;
                return this;
            }
            limit(newLimit) {
                if (((typeof newLimit === 'number') || newLimit === null)) {
                    return this.limit$int(newLimit);
                }
                else if (newLimit === undefined) {
                    return this.limit$();
                }
                else
                    throw new Error('invalid overload');
            }
            mark() {
                this._mark = this._position;
                return this;
            }
            position$() {
                return this._position;
            }
            position$int(newPosition) {
                if (newPosition > this._limit)
                    throw new java.lang.IllegalArgumentException("position is bigger than limit");
                this._position = newPosition;
                if (this._mark > this._position)
                    this._mark = -1;
                return this;
            }
            position(newPosition) {
                if (((typeof newPosition === 'number') || newPosition === null)) {
                    return this.position$int(newPosition);
                }
                else if (newPosition === undefined) {
                    return this.position$();
                }
                else
                    throw new Error('invalid overload');
            }
            remaining() {
                return this._limit - this._position;
            }
            reset() {
                if (this._mark === -1)
                    throw new java.nio.InvalidMarkException();
                this._position = this._mark;
                return this;
            }
            rewind() {
                this._position = 0;
                this._mark = -1;
                return this;
            }
        }
        nio.Buffer = Buffer;
        Buffer["__class"] = "java.nio.Buffer";
    })(nio = java.nio || (java.nio = {}));
})(java || (java = {}));
(function (java) {
    var nio;
    (function (nio) {
        class ByteOrder {
            constructor() {
            }
            static BIG_ENDIAN_$LI$() { if (ByteOrder.BIG_ENDIAN == null)
                ByteOrder.BIG_ENDIAN = new ByteOrder(); return ByteOrder.BIG_ENDIAN; }
            ;
            static LITTLE_ENDIAN_$LI$() { if (ByteOrder.LITTLE_ENDIAN == null)
                ByteOrder.LITTLE_ENDIAN = new ByteOrder(); return ByteOrder.LITTLE_ENDIAN; }
            ;
            /**
             *
             * @return {string}
             */
            toString() {
                return this === ByteOrder.BIG_ENDIAN_$LI$() ? "BIG_ENDIAN" : "LITTLE_ENDIAN";
            }
            static nativeOrder() {
                if (ByteOrder.NativeInstanceHolder.INSTANCE == null) {
                    ByteOrder.NativeInstanceHolder.INSTANCE = ByteOrder.NativeInstanceHolder.nativeOrderTester();
                }
                return ByteOrder.NativeInstanceHolder.INSTANCE;
            }
        }
        nio.ByteOrder = ByteOrder;
        ByteOrder["__class"] = "java.nio.ByteOrder";
        (function (ByteOrder) {
            class NativeInstanceHolder {
                constructor() {
                }
                static nativeOrderTester() {
                    let arrayBuffer = new ArrayBuffer(2);
                    let uint8Array = new Uint8Array(arrayBuffer);
                    let uint16array = new Uint16Array(arrayBuffer);
                    uint8Array.set(Uint8Array.from([170, 187]), 0);
                    if (uint16array[0] === 48042)
                        return java.nio.ByteOrder.LITTLE_ENDIAN_$LI$();
                    if (uint16array[0] === 43707)
                        return java.nio.ByteOrder.BIG_ENDIAN_$LI$();
                    throw new Error("Something crazy just happened in native order test");
                }
            }
            NativeInstanceHolder.INSTANCE = null;
            ByteOrder.NativeInstanceHolder = NativeInstanceHolder;
            NativeInstanceHolder["__class"] = "java.nio.ByteOrder.NativeInstanceHolder";
        })(ByteOrder = nio.ByteOrder || (nio.ByteOrder = {}));
    })(nio = java.nio || (java.nio = {}));
})(java || (java = {}));
(function (java) {
    var nio;
    (function (nio) {
        var charset;
        (function (charset) {
            /**
             * A minimal emulation of {@link Charset}.
             * @class
             */
            class Charset {
                constructor(name, aliasesIgnored) {
                    if (this.__name === undefined)
                        this.__name = null;
                    this.__name = name;
                }
                static availableCharsets() {
                    if (Charset.AvailableCharsets.CHARSETS == null) {
                        let map = (new java.util.TreeMap());
                        map.put(javaemul.internal.EmulatedCharset.ISO_8859_1_$LI$().name(), javaemul.internal.EmulatedCharset.ISO_8859_1_$LI$());
                        map.put(javaemul.internal.EmulatedCharset.ISO_LATIN_1_$LI$().name(), javaemul.internal.EmulatedCharset.ISO_LATIN_1_$LI$());
                        map.put(javaemul.internal.EmulatedCharset.UTF_8_$LI$().name(), javaemul.internal.EmulatedCharset.UTF_8_$LI$());
                        Charset.AvailableCharsets.CHARSETS = java.util.Collections.unmodifiableSortedMap(map);
                    }
                    return Charset.AvailableCharsets.CHARSETS;
                }
                static forName(charsetName) {
                    javaemul.internal.InternalPreconditions.checkArgument(charsetName != null, "Null charset name");
                    charsetName = charsetName.toUpperCase();
                    if (((o1, o2) => { if (o1 && o1.equals) {
                        return o1.equals(o2);
                    }
                    else {
                        return o1 === o2;
                    } })(javaemul.internal.EmulatedCharset.ISO_8859_1_$LI$().name(), charsetName)) {
                        return javaemul.internal.EmulatedCharset.ISO_8859_1_$LI$();
                    }
                    else if (((o1, o2) => { if (o1 && o1.equals) {
                        return o1.equals(o2);
                    }
                    else {
                        return o1 === o2;
                    } })(javaemul.internal.EmulatedCharset.ISO_LATIN_1_$LI$().name(), charsetName)) {
                        return javaemul.internal.EmulatedCharset.ISO_LATIN_1_$LI$();
                    }
                    else if (((o1, o2) => { if (o1 && o1.equals) {
                        return o1.equals(o2);
                    }
                    else {
                        return o1 === o2;
                    } })(javaemul.internal.EmulatedCharset.UTF_8_$LI$().name(), charsetName)) {
                        return javaemul.internal.EmulatedCharset.UTF_8_$LI$();
                    }
                    if (!Charset.createLegalCharsetNameRegex().test(charsetName)) {
                        throw new java.nio.charset.IllegalCharsetNameException(charsetName);
                    }
                    else {
                        throw new java.nio.charset.UnsupportedCharsetException(charsetName);
                    }
                }
                static createLegalCharsetNameRegex() {
                    return new RegExp("^[A-Za-z0-9][\\w-:\\.\\+]*$");
                }
                name() {
                    return this.__name;
                }
                compareTo$java_nio_charset_Charset(that) {
                    return this.__name.toUpperCase().localeCompare(that.__name.toUpperCase());
                }
                /**
                 *
                 * @param {java.nio.charset.Charset} that
                 * @return {number}
                 */
                compareTo(that) {
                    if (((that != null && that instanceof java.nio.charset.Charset) || that === null)) {
                        return this.compareTo$java_nio_charset_Charset(that);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 *
                 * @return {number}
                 */
                hashCode() {
                    return ((o) => { if (o.hashCode) {
                        return o.hashCode();
                    }
                    else {
                        return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                    } })(this.__name);
                }
                /**
                 *
                 * @param {*} o
                 * @return {boolean}
                 */
                equals(o) {
                    if (o === this) {
                        return true;
                    }
                    if (!(o != null && o instanceof java.nio.charset.Charset)) {
                        return false;
                    }
                    let that = o;
                    return ((o1, o2) => { if (o1 && o1.equals) {
                        return o1.equals(o2);
                    }
                    else {
                        return o1 === o2;
                    } })(this.__name, that.__name);
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    return this.__name;
                }
            }
            charset.Charset = Charset;
            Charset["__class"] = "java.nio.charset.Charset";
            Charset["__interfaces"] = ["java.lang.Comparable"];
            (function (Charset) {
                class AvailableCharsets {
                    constructor() {
                    }
                }
                AvailableCharsets.CHARSETS = null;
                Charset.AvailableCharsets = AvailableCharsets;
                AvailableCharsets["__class"] = "java.nio.charset.Charset.AvailableCharsets";
            })(Charset = charset.Charset || (charset.Charset = {}));
        })(charset = nio.charset || (nio.charset = {}));
    })(nio = java.nio || (java.nio = {}));
})(java || (java = {}));
(function (java) {
    var nio;
    (function (nio) {
        var file;
        (function (file) {
            class Paths {
                constructor() {
                }
                static get(...paths) {
                    return new java.nio.file.Path((paths).join(java.nio.file.Path.PATH_SEPARATOR_$LI$()));
                }
            }
            file.Paths = Paths;
            Paths["__class"] = "java.nio.file.Paths";
        })(file = nio.file || (nio.file = {}));
    })(nio = java.nio || (java.nio = {}));
})(java || (java = {}));
(function (java) {
    var security;
    (function (security) {
        /**
         * Message Digest Service Provider Interface - <a
         * href="http://java.sun.com/j2se/1.4.2/docs/api/java/security/MessageDigestSpi.html">[Sun's
         * docs]</a>.
         * @class
         */
        class MessageDigestSpi {
            engineDigest$() { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); }
            engineDigest$byte_A$int$int(buf, offset, len) {
                let digest = this.engineDigest();
                if (buf.length < digest.length + offset) {
                    throw new java.security.DigestException("Insufficient buffer space for digest");
                }
                if (len < digest.length) {
                    throw new java.security.DigestException("Length not large enough to hold digest");
                }
                java.lang.System.arraycopy(digest, 0, buf, offset, digest.length);
                return digest.length;
            }
            engineDigest(buf, offset, len) {
                if (((buf != null && buf instanceof Array && (buf.length == 0 || buf[0] == null || (typeof buf[0] === 'number'))) || buf === null) && ((typeof offset === 'number') || offset === null) && ((typeof len === 'number') || len === null)) {
                    return this.engineDigest$byte_A$int$int(buf, offset, len);
                }
                else if (buf === undefined && offset === undefined && len === undefined) {
                    return this.engineDigest$();
                }
                else
                    throw new Error('invalid overload');
            }
            engineGetDigestLength() {
                return 0;
            }
            engineUpdate$byte(input) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); }
            engineUpdate$byte_A$int$int(input, offset, len) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); }
            engineUpdate(input, offset, len) {
                if (((input != null && input instanceof Array && (input.length == 0 || input[0] == null || (typeof input[0] === 'number'))) || input === null) && ((typeof offset === 'number') || offset === null) && ((typeof len === 'number') || len === null)) {
                    return this.engineUpdate$byte_A$int$int(input, offset, len);
                }
                else if (((typeof input === 'number') || input === null) && offset === undefined && len === undefined) {
                    return this.engineUpdate$byte(input);
                }
                else
                    throw new Error('invalid overload');
            }
        }
        security.MessageDigestSpi = MessageDigestSpi;
        MessageDigestSpi["__class"] = "java.security.MessageDigestSpi";
    })(security = java.security || (java.security = {}));
})(java || (java = {}));
(function (java) {
    var text;
    (function (text) {
        /**
         * A basic implementation for Java collators.
         *
         * @author Renaud Pawlak
         * @class
         */
        class Collator {
            constructor() {
            }
            static getInstance() {
                if (Collator.collator == null) {
                    Collator.collator = new Collator();
                }
                return Collator.collator;
            }
            /**
             *
             * @param {*} a
             * @param {*} b
             * @return {number}
             */
            compare(a, b) {
                return a.localeCompare(b);
            }
        }
        Collator.collator = null;
        text.Collator = Collator;
        Collator["__class"] = "java.text.Collator";
        Collator["__interfaces"] = ["java.util.Comparator"];
    })(text = java.text || (java.text = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        /**
         * Skeletal implementation of the Collection interface. <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/AbstractCollection.html">[Sun
         * docs]</a>
         *
         * @param <E> the element type.
         * @class
         */
        class AbstractCollection {
            constructor() {
            }
            stream() {
                return (new javaemul.internal.stream.StreamHelper(this));
            }
            forEach(action) {
                javaemul.internal.InternalPreconditions.checkNotNull((action));
                for (let index122 = this.iterator(); index122.hasNext();) {
                    let t = index122.next();
                    {
                        (target => (typeof target === 'function') ? target(t) : target.accept(t))(action);
                    }
                }
            }
            removeIf(filter) {
                javaemul.internal.InternalPreconditions.checkNotNull((filter));
                let removed = false;
                for (let it = this.iterator(); it.hasNext();) {
                    {
                        if ((target => (typeof target === 'function') ? target(it.next()) : target.test(it.next()))(filter)) {
                            it.remove();
                            removed = true;
                        }
                    }
                    ;
                }
                return removed;
            }
            /**
             *
             * @param {*} o
             * @return {boolean}
             */
            add(o) {
                throw new java.lang.UnsupportedOperationException("Add not supported on this collection");
            }
            /**
             *
             * @param {*} c
             * @return {boolean}
             */
            addAll(c) {
                javaemul.internal.InternalPreconditions.checkNotNull(c);
                let changed = false;
                for (let index123 = c.iterator(); index123.hasNext();) {
                    let e = index123.next();
                    {
                        changed = this.add(e) || changed;
                    }
                }
                return changed;
            }
            /**
             *
             */
            clear() {
                for (let iter = this.iterator(); iter.hasNext();) {
                    {
                        iter.next();
                        iter.remove();
                    }
                    ;
                }
            }
            /**
             *
             * @param {*} o
             * @return {boolean}
             */
            contains(o) {
                return this.advanceToFind(o, false);
            }
            /**
             *
             * @param {*} c
             * @return {boolean}
             */
            containsAll(c) {
                javaemul.internal.InternalPreconditions.checkNotNull(c);
                for (let index124 = c.iterator(); index124.hasNext();) {
                    let e = index124.next();
                    {
                        if (!this.contains(e)) {
                            return false;
                        }
                    }
                }
                return true;
            }
            /**
             *
             * @return {boolean}
             */
            isEmpty() {
                return this.size() === 0;
            }
            /**
             *
             * @param {*} o
             * @return {boolean}
             */
            remove(o) {
                return this.advanceToFind(o, true);
            }
            /**
             *
             * @param {*} c
             * @return {boolean}
             */
            removeAll(c) {
                javaemul.internal.InternalPreconditions.checkNotNull(c);
                let changed = false;
                for (let iter = this.iterator(); iter.hasNext();) {
                    {
                        let o = iter.next();
                        if (c.contains(o)) {
                            iter.remove();
                            changed = true;
                        }
                    }
                    ;
                }
                return changed;
            }
            /**
             *
             * @param {*} c
             * @return {boolean}
             */
            retainAll(c) {
                javaemul.internal.InternalPreconditions.checkNotNull(c);
                let changed = false;
                for (let iter = this.iterator(); iter.hasNext();) {
                    {
                        let o = iter.next();
                        if (!c.contains(o)) {
                            iter.remove();
                            changed = true;
                        }
                    }
                    ;
                }
                return changed;
            }
            toArray$() {
                return this.toArray$java_lang_Object_A((s => { let a = []; while (s-- > 0)
                    a.push(null); return a; })(this.size()));
            }
            toArray$java_lang_Object_A(a) {
                let size = this.size();
                if (a.length < size) {
                    a = javaemul.internal.ArrayHelper.createFrom(a, size);
                }
                let result = a;
                let it = this.iterator();
                for (let i = 0; i < size; ++i) {
                    {
                        result[i] = it.next();
                    }
                    ;
                }
                if (a.length > size) {
                    a[size] = null;
                }
                return a;
            }
            /**
             *
             * @param {Array} a
             * @return {Array}
             */
            toArray(a) {
                if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (a[0] != null))) || a === null)) {
                    return this.toArray$java_lang_Object_A(a);
                }
                else if (a === undefined) {
                    return this.toArray$();
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             *
             * @return {string}
             */
            toString() {
                let joiner = new java.util.StringJoiner(", ", "[", "]");
                for (let index125 = this.iterator(); index125.hasNext();) {
                    let e = index125.next();
                    {
                        joiner.add(e === this ? "(this Collection)" : new String(e).toString());
                    }
                }
                return joiner.toString();
            }
            /*private*/ advanceToFind(o, remove) {
                for (let iter = this.iterator(); iter.hasNext();) {
                    {
                        let e = iter.next();
                        if (java.util.Objects.equals(o, e)) {
                            if (remove) {
                                iter.remove();
                            }
                            return true;
                        }
                    }
                    ;
                }
                return false;
            }
        }
        util.AbstractCollection = AbstractCollection;
        AbstractCollection["__class"] = "java.util.AbstractCollection";
        AbstractCollection["__interfaces"] = ["java.util.Collection", "java.lang.Iterable"];
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        /**
         * Basic {@link Map.Entry} implementation that implements hashCode, equals, and
         * toString.
         * @class
         */
        class AbstractMapEntry {
            constructor() {
            }
            /**
             *
             * @param {*} other
             * @return {boolean}
             */
            equals(other) {
                if (!(other != null && (other["__interfaces"] != null && other["__interfaces"].indexOf("java.util.Map.Entry") >= 0 || other.constructor != null && other.constructor["__interfaces"] != null && other.constructor["__interfaces"].indexOf("java.util.Map.Entry") >= 0))) {
                    return false;
                }
                let entry = other;
                return java.util.Objects.equals(this.getKey(), entry.getKey()) && java.util.Objects.equals(this.getValue(), entry.getValue());
            }
            /**
             * Calculate the hash code using Sun's specified algorithm.
             * @return {number}
             */
            hashCode() {
                return java.util.Objects.hashCode(this.getKey()) ^ java.util.Objects.hashCode(this.getValue());
            }
            /**
             *
             * @return {string}
             */
            toString() {
                return this.getKey() + "=" + this.getValue();
            }
        }
        util.AbstractMapEntry = AbstractMapEntry;
        AbstractMapEntry["__class"] = "java.util.AbstractMapEntry";
        AbstractMapEntry["__interfaces"] = ["java.util.Map.Entry"];
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        /**
         * Incomplete and naive implementation of the BitSet utility (mainly for
         * compatibility/compilation purpose).
         *
         * @author Renaud Pawlak
         * @param {number} nbits
         * @class
         */
        class BitSet {
            constructor(nbits) {
                /*private*/ this.bits = [];
                if (((typeof nbits === 'number') || nbits === null)) {
                    let __args = arguments;
                    this.bits = [];
                    (() => {
                        while ((nbits > 0)) {
                            {
                                (this.bits).push(false);
                                nbits--;
                            }
                        }
                        ;
                    })();
                }
                else if (nbits === undefined) {
                    let __args = arguments;
                    this.bits = [];
                }
                else
                    throw new Error('invalid overload');
            }
            static valueOf(longs) {
                let bs = new BitSet();
                bs.bits = new Array(longs.length * 64);
                for (let n = 0; n < longs.length * 64; n++) {
                    {
                        bs.bits[n] = ((longs[(n / 64 | 0)] & (1 << (n % 64))) !== 0);
                    }
                    ;
                }
                return bs;
            }
            flip$int(bitIndex) {
                this.bits[bitIndex] = !this.bits[bitIndex];
            }
            flip$int$int(fromIndex, toIndex) {
                for (let i = fromIndex; i <= toIndex; i++) {
                    {
                        this.flip$int(i);
                    }
                    ;
                }
            }
            flip(fromIndex, toIndex) {
                if (((typeof fromIndex === 'number') || fromIndex === null) && ((typeof toIndex === 'number') || toIndex === null)) {
                    return this.flip$int$int(fromIndex, toIndex);
                }
                else if (((typeof fromIndex === 'number') || fromIndex === null) && toIndex === undefined) {
                    return this.flip$int(fromIndex);
                }
                else
                    throw new Error('invalid overload');
            }
            set$int(bitIndex) {
                this.bits[bitIndex] = true;
            }
            set$int$boolean(bitIndex, value) {
                if (value) {
                    this.set$int(bitIndex);
                }
                else {
                    this.clear$int(bitIndex);
                }
            }
            set$int$int(fromIndex, toIndex) {
                for (let i = fromIndex; i <= toIndex; i++) {
                    {
                        this.set$int(i);
                    }
                    ;
                }
            }
            set$int$int$boolean(fromIndex, toIndex, value) {
                if (value) {
                    this.set$int$int(fromIndex, toIndex);
                }
                else {
                    this.clear$int$int(fromIndex, toIndex);
                }
            }
            set(fromIndex, toIndex, value) {
                if (((typeof fromIndex === 'number') || fromIndex === null) && ((typeof toIndex === 'number') || toIndex === null) && ((typeof value === 'boolean') || value === null)) {
                    return this.set$int$int$boolean(fromIndex, toIndex, value);
                }
                else if (((typeof fromIndex === 'number') || fromIndex === null) && ((typeof toIndex === 'boolean') || toIndex === null) && value === undefined) {
                    return this.set$int$boolean(fromIndex, toIndex);
                }
                else if (((typeof fromIndex === 'number') || fromIndex === null) && ((typeof toIndex === 'number') || toIndex === null) && value === undefined) {
                    return this.set$int$int(fromIndex, toIndex);
                }
                else if (((typeof fromIndex === 'number') || fromIndex === null) && toIndex === undefined && value === undefined) {
                    return this.set$int(fromIndex);
                }
                else
                    throw new Error('invalid overload');
            }
            clear$int(bitIndex) {
                this.bits[bitIndex] = false;
            }
            clear$int$int(fromIndex, toIndex) {
                for (let i = fromIndex; i <= toIndex; i++) {
                    {
                        this.clear$int(i);
                    }
                    ;
                }
            }
            clear(fromIndex, toIndex) {
                if (((typeof fromIndex === 'number') || fromIndex === null) && ((typeof toIndex === 'number') || toIndex === null)) {
                    return this.clear$int$int(fromIndex, toIndex);
                }
                else if (((typeof fromIndex === 'number') || fromIndex === null) && toIndex === undefined) {
                    return this.clear$int(fromIndex);
                }
                else if (fromIndex === undefined && toIndex === undefined) {
                    return this.clear$();
                }
                else
                    throw new Error('invalid overload');
            }
            clear$() {
                this.bits = [];
            }
            get$int(bitIndex) {
                return this.bits[bitIndex];
            }
            get$int$int(fromIndex, toIndex) {
                let bs = new BitSet();
                for (let i = fromIndex; i <= toIndex; i++) {
                    {
                        (bs.bits).push(this.bits[i]);
                    }
                    ;
                }
                return bs;
            }
            get(fromIndex, toIndex) {
                if (((typeof fromIndex === 'number') || fromIndex === null) && ((typeof toIndex === 'number') || toIndex === null)) {
                    return this.get$int$int(fromIndex, toIndex);
                }
                else if (((typeof fromIndex === 'number') || fromIndex === null) && toIndex === undefined) {
                    return this.get$int(fromIndex);
                }
                else
                    throw new Error('invalid overload');
            }
            length() {
                return this.bits.length;
            }
            isEmpty() {
                return this.bits.length === 0;
            }
            cardinality() {
                let sum = 0;
                for (let i = 0; i < this.bits.length; i++) {
                    {
                        sum += this.bits[i] ? 1 : 0;
                    }
                    ;
                }
                return sum;
            }
            and(set) {
                for (let i = 0; i < this.bits.length; i++) {
                    {
                        this.bits[i] = this.bits[i] && set.get$int(i);
                    }
                    ;
                }
            }
            or(set) {
                for (let i = 0; i < this.bits.length; i++) {
                    {
                        this.bits[i] = this.bits[i] || set.get$int(i);
                    }
                    ;
                }
            }
            xor(set) {
                for (let i = 0; i < this.bits.length; i++) {
                    {
                        this.bits[i] = (this.bits[i] && !set.get$int(i)) || (!this.bits[i] && set.get$int(i));
                    }
                    ;
                }
            }
            andNot(set) {
                for (let i = 0; i < this.bits.length; i++) {
                    {
                        this.bits[i] = this.bits[i] && !set.get$int(i);
                    }
                    ;
                }
            }
            size() {
                return this.bits.length;
            }
            equals(obj) {
                if (!(obj != null && obj instanceof java.util.BitSet))
                    return false;
                if (this === obj)
                    return true;
                let set = obj;
                if (set.bits.length !== this.bits.length) {
                    return false;
                }
                for (let i = 0; i < set.bits.length; i++) {
                    {
                        if (!set.bits[i] == this.bits[i]) {
                            return false;
                        }
                    }
                    ;
                }
                return true;
            }
            clone() {
                let bs = new BitSet();
                bs.bits = (this.bits).slice(0, this.bits.length);
                return bs;
            }
        }
        util.BitSet = BitSet;
        BitSet["__class"] = "java.util.BitSet";
        BitSet["__interfaces"] = ["java.lang.Cloneable", "java.io.Serializable"];
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        class Comparators {
            static NATURAL_$LI$() { if (Comparators.NATURAL == null)
                Comparators.NATURAL = new Comparators.NaturalComparator(); return Comparators.NATURAL; }
            ;
            /**
             * Returns the natural Comparator.
             * <p>
             * Example:
             *
             * <pre>Comparator&lt;String&gt; compareString = Comparators.natural()</pre>
             *
             * @return {*} the natural Comparator
             */
            static natural() {
                return Comparators.NATURAL_$LI$();
            }
        }
        util.Comparators = Comparators;
        Comparators["__class"] = "java.util.Comparators";
        (function (Comparators) {
            class NaturalComparator {
                constructor() {
                }
                /**
                 *
                 * @param {*} o1
                 * @param {*} o2
                 * @return {number}
                 */
                compare(o1, o2) {
                    javaemul.internal.InternalPreconditions.checkNotNull(o1);
                    javaemul.internal.InternalPreconditions.checkNotNull(o2);
                    if ((o1)["compareTo"] === undefined) {
                        return o1.toString().localeCompare(o2.toString());
                    }
                    return o1.compareTo(o2);
                }
            }
            Comparators.NaturalComparator = NaturalComparator;
            NaturalComparator["__class"] = "java.util.Comparators.NaturalComparator";
            NaturalComparator["__interfaces"] = ["java.util.Comparator"];
        })(Comparators = util.Comparators || (util.Comparators = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        /**
         * Represents a date and time.
         * @param {number} year
         * @param {number} month
         * @param {number} date
         * @param {number} hrs
         * @param {number} min
         * @param {number} sec
         * @class
         */
        class Date {
            constructor(year, month, date, hrs, min, sec) {
                if (((typeof year === 'number') || year === null) && ((typeof month === 'number') || month === null) && ((typeof date === 'number') || date === null) && ((typeof hrs === 'number') || hrs === null) && ((typeof min === 'number') || min === null) && ((typeof sec === 'number') || sec === null)) {
                    let __args = arguments;
                    if (this.jsdate === undefined)
                        this.jsdate = null;
                    if (this.jsdate === undefined)
                        this.jsdate = null;
                    (() => {
                        this.jsdate = (new (Date.jsdateClass())());
                        this.jsdate["setFullYear"](this.jsdate, year + 1900, month, date);
                        this.jsdate["setHours"](this.jsdate, hrs, min, sec, 0);
                        this.fixDaylightSavings(hrs);
                    })();
                }
                else if (((typeof year === 'number') || year === null) && ((typeof month === 'number') || month === null) && ((typeof date === 'number') || date === null) && ((typeof hrs === 'number') || hrs === null) && ((typeof min === 'number') || min === null) && sec === undefined) {
                    let __args = arguments;
                    {
                        let __args = arguments;
                        let sec = 0;
                        if (this.jsdate === undefined)
                            this.jsdate = null;
                        if (this.jsdate === undefined)
                            this.jsdate = null;
                        (() => {
                            this.jsdate = (new (Date.jsdateClass())());
                            this.jsdate["setFullYear"](this.jsdate, year + 1900, month, date);
                            this.jsdate["setHours"](this.jsdate, hrs, min, sec, 0);
                            this.fixDaylightSavings(hrs);
                        })();
                    }
                }
                else if (((typeof year === 'number') || year === null) && ((typeof month === 'number') || month === null) && ((typeof date === 'number') || date === null) && hrs === undefined && min === undefined && sec === undefined) {
                    let __args = arguments;
                    {
                        let __args = arguments;
                        let hrs = 0;
                        let min = 0;
                        let sec = 0;
                        if (this.jsdate === undefined)
                            this.jsdate = null;
                        if (this.jsdate === undefined)
                            this.jsdate = null;
                        (() => {
                            this.jsdate = (new (Date.jsdateClass())());
                            this.jsdate["setFullYear"](this.jsdate, year + 1900, month, date);
                            this.jsdate["setHours"](this.jsdate, hrs, min, sec, 0);
                            this.fixDaylightSavings(hrs);
                        })();
                    }
                }
                else if (((typeof year === 'string') || year === null) && month === undefined && date === undefined && hrs === undefined && min === undefined && sec === undefined) {
                    let __args = arguments;
                    let date = __args[0];
                    {
                        let __args = arguments;
                        let date = Date.parse(__args[0]);
                        if (this.jsdate === undefined)
                            this.jsdate = null;
                        if (this.jsdate === undefined)
                            this.jsdate = null;
                        (() => {
                            this.jsdate = (new (Date.jsdateClass())(date));
                        })();
                    }
                }
                else if (((typeof year === 'number') || year === null) && month === undefined && date === undefined && hrs === undefined && min === undefined && sec === undefined) {
                    let __args = arguments;
                    let date = __args[0];
                    if (this.jsdate === undefined)
                        this.jsdate = null;
                    if (this.jsdate === undefined)
                        this.jsdate = null;
                    (() => {
                        this.jsdate = (new (Date.jsdateClass())(date));
                    })();
                }
                else if (year === undefined && month === undefined && date === undefined && hrs === undefined && min === undefined && sec === undefined) {
                    let __args = arguments;
                    if (this.jsdate === undefined)
                        this.jsdate = null;
                    if (this.jsdate === undefined)
                        this.jsdate = null;
                    (() => {
                        this.jsdate = (new (Date.jsdateClass())());
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            static parse(s) {
                let parsed = (Date.jsdateClass()["parse"](s));
                if (isNaN(parsed)) {
                    throw new java.lang.IllegalArgumentException();
                }
                return (n => n < 0 ? Math.ceil(n) : Math.floor(n))(parsed);
            }
            static UTC(year, month, date, hrs, min, sec) {
                return (Date.jsdateClass()["UTC"](year + 1900, month, date, hrs, min, sec, 0));
            }
            /**
             * Ensure a number is displayed with two digits.
             *
             * @return {string} a two-character base 10 representation of the number
             * @param {number} number
             */
            static padTwo(number) {
                if (number < 10) {
                    return "0" + number;
                }
                else {
                    return new String(number).toString();
                }
            }
            static jsdateClass() {
                return (window["Date"]);
            }
            after(when) {
                return this.getTime() > when.getTime();
            }
            before(when) {
                return this.getTime() < when.getTime();
            }
            clone() {
                return new Date(this.getTime());
            }
            compareTo$java_util_Date(other) {
                return (this.getTime() - other.getTime());
            }
            /**
             *
             * @param {java.util.Date} other
             * @return {number}
             */
            compareTo(other) {
                if (((other != null && other instanceof Date) || other === null)) {
                    return this.compareTo$java_util_Date(other);
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             *
             * @param {*} obj
             * @return {boolean}
             */
            equals(obj) {
                return ((obj != null && obj instanceof Date) && (this.getTime() === obj.getTime()));
            }
            getDate() {
                return (this.jsdate["getDate"](this.jsdate));
            }
            getDay() {
                return (this.jsdate["getDay"](this.jsdate));
            }
            getHours() {
                return (this.jsdate["getHours"](this.jsdate));
            }
            getMinutes() {
                return (this.jsdate["getMinutes"](this.jsdate));
            }
            getMonth() {
                return (this.jsdate["getMonth"](this.jsdate));
            }
            getSeconds() {
                return (this.jsdate["getSeconds"](this.jsdate));
            }
            getTime() {
                return (this.jsdate["getTime"](this.jsdate));
            }
            getTimezoneOffset() {
                return (this.jsdate["getTimezoneOffset"](this.jsdate));
            }
            getYear() {
                return (this.jsdate["getFullYear"](this.jsdate)) - 1900;
            }
            /**
             *
             * @return {number}
             */
            hashCode() {
                let time = this.getTime();
                return ((time ^ (time >>> 32)) | 0);
            }
            setDate(date) {
                let hours = this.getHours();
                this.jsdate["setDate"](this.jsdate, date);
                this.fixDaylightSavings(hours);
            }
            setHours(hours) {
                this.jsdate["setHours"](this.jsdate, hours);
                this.fixDaylightSavings(hours);
            }
            setMinutes(minutes) {
                let hours = this.getHours() + (minutes / 60 | 0);
                this.jsdate["setMinutes"](this.jsdate, minutes);
                this.fixDaylightSavings(hours);
            }
            setMonth(month) {
                let hours = this.getHours();
                this.jsdate["setMonth"](this.jsdate, month);
                this.fixDaylightSavings(hours);
            }
            setSeconds(seconds) {
                let hours = this.getHours() + (seconds / (60 * 60) | 0);
                this.jsdate["setSeconds"](this.jsdate, seconds);
                this.fixDaylightSavings(hours);
            }
            setTime(time) {
                this.jsdate["setTime"](this.jsdate, time);
            }
            setYear(year) {
                let hours = this.getHours();
                this.jsdate["setFullYear"](this.jsdate, year + 1900);
                this.fixDaylightSavings(hours);
            }
            toGMTString() {
                return this.jsdate["getUTCDate"](this.jsdate) + " " + Date.StringData.MONTHS_$LI$()[(this.jsdate["getUTCMonth"](this.jsdate))] + " " + this.jsdate["getUTCFullYear"](this.jsdate) + " " + Date.padTwo((this.jsdate["getUTCHours"](this.jsdate))) + ":" + Date.padTwo((this.jsdate["getUTCMinutes"](this.jsdate))) + ":" + Date.padTwo((this.jsdate["getUTCSeconds"](this.jsdate))) + " GMT";
            }
            toLocaleString() {
                return this.jsdate.toLocaleString();
            }
            /**
             *
             * @return {string}
             */
            toString() {
                let offset = -(this.getTimezoneOffset() | 0);
                let hourOffset = ((offset >= 0) ? "+" : "") + ((offset / 60 | 0));
                let minuteOffset = Date.padTwo(Math.abs(offset) % 60);
                return Date.StringData.DAYS_$LI$()[(this.getDay() | 0)] + " " + Date.StringData.MONTHS_$LI$()[(this.getMonth() | 0)] + " " + Date.padTwo((this.getDate() | 0)) + " " + Date.padTwo((this.getHours() | 0)) + ":" + Date.padTwo((this.getMinutes() | 0)) + ":" + Date.padTwo((this.getSeconds() | 0)) + " GMT" + hourOffset + minuteOffset + " " + this.jsdate["getFullYear"](this.jsdate);
            }
            /**
             * Detects if the requested time falls into a non-existent time range due to
             * local time advancing into daylight savings time or is ambiguous due to
             * going out of daylight savings. If so, adjust accordingly.
             * @param {number} requestedHours
             * @private
             */
            fixDaylightSavings(requestedHours) {
                requestedHours %= 24;
                if (this.getHours() !== requestedHours) {
                    let copy = (new (Date.jsdateClass())(this.getTime()));
                    copy["setDate"](((copy["getDate"](copy)) + 1));
                    let timeDiff = (this.jsdate["getTimezoneOffset"](this.jsdate)) - (copy["getTimezoneOffset"](copy));
                    if (timeDiff > 0) {
                        let timeDiffHours = (timeDiff / 60 | 0);
                        let timeDiffMinutes = timeDiff % 60;
                        let day = (this.getDate() | 0);
                        let badHours = (this.getHours() | 0);
                        if (badHours + timeDiffHours >= 24) {
                            day++;
                        }
                        let newTime = (new (Date.jsdateClass())((this.jsdate["getFullYear"](this.jsdate)), this.getMonth(), day, requestedHours + timeDiffHours, this.getMinutes() + timeDiffMinutes, this.getSeconds(), (this.jsdate["getMilliseconds"](this.jsdate))));
                        this.setTime((newTime["getMilliseconds"](newTime)));
                    }
                }
                let originalTimeInMillis = this.getTime();
                this.setTime(originalTimeInMillis + Date.ONE_HOUR_IN_MILLISECONDS);
                if (this.getHours() !== requestedHours) {
                    this.setTime(originalTimeInMillis);
                }
            }
        }
        Date.ONE_HOUR_IN_MILLISECONDS = 60 * 60 * 1000;
        util.Date = Date;
        Date["__class"] = "java.util.Date";
        Date["__interfaces"] = ["java.lang.Cloneable", "java.lang.Comparable", "java.io.Serializable"];
        (function (Date) {
            /**
             * Encapsulates static data to avoid Date itself having a static
             * initializer.
             * @class
             */
            class StringData {
                constructor() {
                }
                static DAYS_$LI$() { if (StringData.DAYS == null)
                    StringData.DAYS = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]; return StringData.DAYS; }
                ;
                static MONTHS_$LI$() { if (StringData.MONTHS == null)
                    StringData.MONTHS = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]; return StringData.MONTHS; }
                ;
            }
            Date.StringData = StringData;
            StringData["__class"] = "java.util.Date.StringData";
        })(Date = util.Date || (util.Date = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        class EventListenerProxy {
            constructor(listener) {
                if (this.listener === undefined)
                    this.listener = null;
                this.listener = listener;
            }
            getListener() {
                return this.listener;
            }
        }
        util.EventListenerProxy = EventListenerProxy;
        EventListenerProxy["__class"] = "java.util.EventListenerProxy";
        EventListenerProxy["__interfaces"] = ["java.util.EventListener"];
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        /**
         * Available as a superclass of event objects.
         * @param {*} source
         * @class
         */
        class EventObject {
            constructor(source) {
                if (this.source === undefined)
                    this.source = null;
                this.source = source;
            }
            getSource() {
                return this.source;
            }
        }
        util.EventObject = EventObject;
        EventObject["__class"] = "java.util.EventObject";
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        /**
         * A simple wrapper around JavaScriptObject to provide {@link java.util.Map}-like semantics for any
         * key type.
         * <p>
         * Implementation notes:
         * <p>
         * A key's hashCode is the index in backingMap which should contain that key. Since several keys may
         * have the same hash, each value in hashCodeMap is actually an array containing all entries whose
         * keys share the same hash.
         * @param {java.util.AbstractHashMap} host
         * @class
         */
        class InternalHashCodeMap {
            constructor(host) {
                /*private*/ this.backingMap = java.util.InternalJsMapFactory.newJsMap();
                if (this.host === undefined)
                    this.host = null;
                if (this.__size === undefined)
                    this.__size = 0;
                this.host = host;
            }
            forEach(action) {
                javaemul.internal.InternalPreconditions.checkNotNull((action));
                for (let index126 = this.iterator(); index126.hasNext();) {
                    let t = index126.next();
                    {
                        (target => (typeof target === 'function') ? target(t) : target.accept(t))(action);
                    }
                }
            }
            put(key, value) {
                let hashCode = this.hash(key);
                let chain = this.getChainOrEmpty(hashCode);
                if (chain.length === 0) {
                    this.backingMap.set(hashCode, chain);
                }
                else {
                    let entry = this.findEntryInChain(key, chain);
                    if (entry != null) {
                        return entry.setValue(value);
                    }
                }
                chain[chain.length] = (new java.util.AbstractMap.SimpleEntry(key, value));
                this.__size++;
                java.util.ConcurrentModificationDetector.structureChanged(this.host);
                return null;
            }
            remove(key) {
                let hashCode = this.hash(key);
                let chain = this.getChainOrEmpty(hashCode);
                for (let i = 0; i < chain.length; i++) {
                    {
                        let entry = chain[i];
                        if (this.host._equals(key, entry.getKey())) {
                            if (chain.length === 1) {
                                javaemul.internal.ArrayHelper.setLength(chain, 0);
                                this.backingMap.delete(hashCode);
                            }
                            else {
                                javaemul.internal.ArrayHelper.removeFrom(chain, i, 1);
                            }
                            this.__size--;
                            java.util.ConcurrentModificationDetector.structureChanged(this.host);
                            return entry.getValue();
                        }
                    }
                    ;
                }
                return null;
            }
            getEntry(key) {
                return this.findEntryInChain(key, this.getChainOrEmpty(this.hash(key)));
            }
            /*private*/ findEntryInChain(key, chain) {
                for (let index127 = 0; index127 < chain.length; index127++) {
                    let entry = chain[index127];
                    {
                        if (this.host._equals(key, entry.getKey())) {
                            return entry;
                        }
                    }
                }
                return null;
            }
            size() {
                return this.__size;
            }
            /**
             *
             * @return {*}
             */
            iterator() {
                return new InternalHashCodeMap.InternalHashCodeMap$0(this);
            }
            /*private*/ getChainOrEmpty(hashCode) {
                let chain = this.unsafeCastToArray(this.backingMap.get(hashCode));
                return chain == null ? this.newEntryChain() : chain;
            }
            /*private*/ newEntryChain() {
                return ([]);
            }
            /*private*/ unsafeCastToArray(arr) {
                return (arr);
            }
            /**
             * Returns hash code of the key as calculated by {@link AbstractHashMap#getHashCode(Object)} but
             * also handles null keys as well.
             * @param {*} key
             * @return {number}
             * @private
             */
            /*private*/ hash(key) {
                return key == null ? 0 : this.host.getHashCode(key);
            }
        }
        util.InternalHashCodeMap = InternalHashCodeMap;
        InternalHashCodeMap["__class"] = "java.util.InternalHashCodeMap";
        InternalHashCodeMap["__interfaces"] = ["java.lang.Iterable"];
        (function (InternalHashCodeMap) {
            class InternalHashCodeMap$0 {
                constructor(__parent) {
                    this.__parent = __parent;
                    this.chains = this.__parent.backingMap.entries();
                    this.itemIndex = 0;
                    this.chain = this.__parent.newEntryChain();
                    this.lastEntry = null;
                }
                forEachRemaining(consumer) {
                    javaemul.internal.InternalPreconditions.checkNotNull((consumer));
                    while ((this.hasNext())) {
                        {
                            (target => (typeof target === 'function') ? target(this.next()) : target.accept(this.next()))(consumer);
                        }
                    }
                    ;
                }
                /**
                 *
                 * @return {boolean}
                 */
                hasNext() {
                    if (this.itemIndex < this.chain.length) {
                        return true;
                    }
                    let current = this.chains.next();
                    if (!current.done) {
                        this.chain = this.__parent.unsafeCastToArray(current.value[1]);
                        this.itemIndex = 0;
                        return true;
                    }
                    return false;
                }
                /**
                 *
                 * @return {*}
                 */
                next() {
                    this.lastEntry = this.chain[this.itemIndex++];
                    return this.lastEntry;
                }
                /**
                 *
                 */
                remove() {
                    this.__parent.remove(this.lastEntry.getKey());
                    if (this.itemIndex !== 0) {
                        this.itemIndex--;
                    }
                }
            }
            InternalHashCodeMap.InternalHashCodeMap$0 = InternalHashCodeMap$0;
            InternalHashCodeMap$0["__interfaces"] = ["java.util.Iterator"];
        })(InternalHashCodeMap = util.InternalHashCodeMap || (util.InternalHashCodeMap = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        var InternalJsMap;
        (function (InternalJsMap) {
        })(InternalJsMap = util.InternalJsMap || (util.InternalJsMap = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        /**
         * A factory to create JavaScript Map instances.
         * @class
         */
        class InternalJsMapFactory {
            constructor() {
            }
            static jsMapCtor_$LI$() { if (InternalJsMapFactory.jsMapCtor == null)
                InternalJsMapFactory.jsMapCtor = InternalJsMapFactory.getJsMapConstructor(); return InternalJsMapFactory.jsMapCtor; }
            ;
            /*private*/ static getJsMapConstructor() {
                return (() => eval("Map")).call(null);
            }
            static newJsMap() {
                return (new (InternalJsMapFactory.jsMapCtor_$LI$())());
            }
        }
        util.InternalJsMapFactory = InternalJsMapFactory;
        InternalJsMapFactory["__class"] = "java.util.InternalJsMapFactory";
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        /**
         * A very simple emulation of Locale for shared-code patterns like
         * {@code String.toUpperCase(Locale.US)}.
         * <p>
         * Note: Any changes to this class should put into account the assumption that
         * was made in rest of the JRE emulation.
         * @class
         */
        class Locale {
            constructor() {
            }
            static ROOT_$LI$() { if (Locale.ROOT == null)
                Locale.ROOT = new Locale.RootLocale(); return Locale.ROOT; }
            ;
            static ENGLISH_$LI$() { if (Locale.ENGLISH == null)
                Locale.ENGLISH = new Locale.EnglishLocale(); return Locale.ENGLISH; }
            ;
            static US_$LI$() { if (Locale.US == null)
                Locale.US = new Locale.USLocale(); return Locale.US; }
            ;
            static defaultLocale_$LI$() { if (Locale.defaultLocale == null)
                Locale.defaultLocale = new Locale.DefaultLocale(); return Locale.defaultLocale; }
            ;
            /**
             * Returns an instance that represents the browser's default locale (not
             * necessarily the one defined by 'gwt.locale').
             * @return {java.util.Locale}
             */
            static getDefault() {
                return Locale.defaultLocale_$LI$();
            }
        }
        util.Locale = Locale;
        Locale["__class"] = "java.util.Locale";
        (function (Locale) {
            class RootLocale extends java.util.Locale {
                constructor() {
                    super();
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    return "";
                }
            }
            Locale.RootLocale = RootLocale;
            RootLocale["__class"] = "java.util.Locale.RootLocale";
            class EnglishLocale extends java.util.Locale {
                constructor() {
                    super();
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    return "en";
                }
            }
            Locale.EnglishLocale = EnglishLocale;
            EnglishLocale["__class"] = "java.util.Locale.EnglishLocale";
            class USLocale extends java.util.Locale {
                constructor() {
                    super();
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    return "en_US";
                }
            }
            Locale.USLocale = USLocale;
            USLocale["__class"] = "java.util.Locale.USLocale";
            class DefaultLocale extends java.util.Locale {
                constructor() {
                    super();
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    return "unknown";
                }
            }
            Locale.DefaultLocale = DefaultLocale;
            DefaultLocale["__class"] = "java.util.Locale.DefaultLocale";
        })(Locale = util.Locale || (util.Locale = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        var logging;
        (function (logging) {
            /**
             * An emulation of the java.util.logging.Formatter class. See
             * <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/util/logging/Formatter.html">
             * The Java API doc for details</a>
             * @class
             */
            class Formatter {
                formatMessage(record) {
                    return this.format(record);
                }
            }
            logging.Formatter = Formatter;
            Formatter["__class"] = "java.util.logging.Formatter";
        })(logging = util.logging || (util.logging = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        var logging;
        (function (logging) {
            /**
             * An emulation of the java.util.logging.Handler class. See
             * <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/util/logging/Handler.html">
             * The Java API doc for details</a>
             * @class
             */
            class Handler {
                constructor() {
                    if (this.formatter === undefined)
                        this.formatter = null;
                    if (this.level === undefined)
                        this.level = null;
                }
                getFormatter() {
                    return this.formatter;
                }
                getLevel() {
                    if (this.level != null) {
                        return this.level;
                    }
                    return java.util.logging.Level.ALL_$LI$();
                }
                isLoggable(record) {
                    return this.getLevel().intValue() <= record.getLevel().intValue();
                }
                setFormatter(newFormatter) {
                    this.formatter = newFormatter;
                }
                setLevel(newLevel) {
                    this.level = newLevel;
                }
            }
            logging.Handler = Handler;
            Handler["__class"] = "java.util.logging.Handler";
        })(logging = util.logging || (util.logging = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        var logging;
        (function (logging) {
            /**
             * An emulation of the java.util.logging.Level class. See
             * <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/util/logging/Level.html">
             * The Java API doc for details</a>
             * @class
             */
            class Level {
                constructor() {
                }
                static ALL_$LI$() { if (Level.ALL == null)
                    Level.ALL = new Level.LevelAll(); return Level.ALL; }
                ;
                static CONFIG_$LI$() { if (Level.CONFIG == null)
                    Level.CONFIG = new Level.LevelConfig(); return Level.CONFIG; }
                ;
                static FINE_$LI$() { if (Level.FINE == null)
                    Level.FINE = new Level.LevelFine(); return Level.FINE; }
                ;
                static FINER_$LI$() { if (Level.FINER == null)
                    Level.FINER = new Level.LevelFiner(); return Level.FINER; }
                ;
                static FINEST_$LI$() { if (Level.FINEST == null)
                    Level.FINEST = new Level.LevelFinest(); return Level.FINEST; }
                ;
                static INFO_$LI$() { if (Level.INFO == null)
                    Level.INFO = new Level.LevelInfo(); return Level.INFO; }
                ;
                static OFF_$LI$() { if (Level.OFF == null)
                    Level.OFF = new Level.LevelOff(); return Level.OFF; }
                ;
                static SEVERE_$LI$() { if (Level.SEVERE == null)
                    Level.SEVERE = new Level.LevelSevere(); return Level.SEVERE; }
                ;
                static WARNING_$LI$() { if (Level.WARNING == null)
                    Level.WARNING = new Level.LevelWarning(); return Level.WARNING; }
                ;
                static parse(name) {
                    java.util.logging.Logger.assertLoggingValues();
                    let loggingDisabled = ((o1, o2) => { if (o1 && o1.equals) {
                        return o1.equals(o2);
                    }
                    else {
                        return o1 === o2;
                    } })(java.lang.System.getProperty$java_lang_String$java_lang_String("gwt.logging.enabled", "FALSE"), "FALSE");
                    if (loggingDisabled) {
                        return null;
                    }
                    let value = name.toUpperCase();
                    switch ((value)) {
                        case "ALL":
                            return Level.ALL_$LI$();
                        case "CONFIG":
                            return Level.CONFIG_$LI$();
                        case "FINE":
                            return Level.FINE_$LI$();
                        case "FINER":
                            return Level.FINER_$LI$();
                        case "FINEST":
                            return Level.FINEST_$LI$();
                        case "INFO":
                            return Level.INFO_$LI$();
                        case "OFF":
                            return Level.OFF_$LI$();
                        case "SEVERE":
                            return Level.SEVERE_$LI$();
                        case "WARNING":
                            return Level.WARNING_$LI$();
                        default:
                            throw new java.lang.IllegalArgumentException("Invalid level \"" + name + "\"");
                    }
                }
                getName() {
                    return "DUMMY";
                }
                intValue() {
                    return -1;
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    return this.getName();
                }
            }
            logging.Level = Level;
            Level["__class"] = "java.util.logging.Level";
            Level["__interfaces"] = ["java.io.Serializable"];
            (function (Level) {
                class LevelAll extends java.util.logging.Level {
                    constructor() {
                        super();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getName() {
                        return "ALL";
                    }
                    /**
                     *
                     * @return {number}
                     */
                    intValue() {
                        return javaemul.internal.IntegerHelper.MIN_VALUE;
                    }
                }
                Level.LevelAll = LevelAll;
                LevelAll["__class"] = "java.util.logging.Level.LevelAll";
                LevelAll["__interfaces"] = ["java.io.Serializable"];
                class LevelConfig extends java.util.logging.Level {
                    constructor() {
                        super();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getName() {
                        return "CONFIG";
                    }
                    /**
                     *
                     * @return {number}
                     */
                    intValue() {
                        return 700;
                    }
                }
                Level.LevelConfig = LevelConfig;
                LevelConfig["__class"] = "java.util.logging.Level.LevelConfig";
                LevelConfig["__interfaces"] = ["java.io.Serializable"];
                class LevelFine extends java.util.logging.Level {
                    constructor() {
                        super();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getName() {
                        return "FINE";
                    }
                    /**
                     *
                     * @return {number}
                     */
                    intValue() {
                        return 500;
                    }
                }
                Level.LevelFine = LevelFine;
                LevelFine["__class"] = "java.util.logging.Level.LevelFine";
                LevelFine["__interfaces"] = ["java.io.Serializable"];
                class LevelFiner extends java.util.logging.Level {
                    constructor() {
                        super();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getName() {
                        return "FINER";
                    }
                    /**
                     *
                     * @return {number}
                     */
                    intValue() {
                        return 400;
                    }
                }
                Level.LevelFiner = LevelFiner;
                LevelFiner["__class"] = "java.util.logging.Level.LevelFiner";
                LevelFiner["__interfaces"] = ["java.io.Serializable"];
                class LevelFinest extends java.util.logging.Level {
                    constructor() {
                        super();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getName() {
                        return "FINEST";
                    }
                    /**
                     *
                     * @return {number}
                     */
                    intValue() {
                        return 300;
                    }
                }
                Level.LevelFinest = LevelFinest;
                LevelFinest["__class"] = "java.util.logging.Level.LevelFinest";
                LevelFinest["__interfaces"] = ["java.io.Serializable"];
                class LevelInfo extends java.util.logging.Level {
                    constructor() {
                        super();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getName() {
                        return "INFO";
                    }
                    /**
                     *
                     * @return {number}
                     */
                    intValue() {
                        return 800;
                    }
                }
                Level.LevelInfo = LevelInfo;
                LevelInfo["__class"] = "java.util.logging.Level.LevelInfo";
                LevelInfo["__interfaces"] = ["java.io.Serializable"];
                class LevelOff extends java.util.logging.Level {
                    constructor() {
                        super();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getName() {
                        return "OFF";
                    }
                    /**
                     *
                     * @return {number}
                     */
                    intValue() {
                        return javaemul.internal.IntegerHelper.MAX_VALUE;
                    }
                }
                Level.LevelOff = LevelOff;
                LevelOff["__class"] = "java.util.logging.Level.LevelOff";
                LevelOff["__interfaces"] = ["java.io.Serializable"];
                class LevelSevere extends java.util.logging.Level {
                    constructor() {
                        super();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getName() {
                        return "SEVERE";
                    }
                    /**
                     *
                     * @return {number}
                     */
                    intValue() {
                        return 1000;
                    }
                }
                Level.LevelSevere = LevelSevere;
                LevelSevere["__class"] = "java.util.logging.Level.LevelSevere";
                LevelSevere["__interfaces"] = ["java.io.Serializable"];
                class LevelWarning extends java.util.logging.Level {
                    constructor() {
                        super();
                    }
                    /**
                     *
                     * @return {string}
                     */
                    getName() {
                        return "WARNING";
                    }
                    /**
                     *
                     * @return {number}
                     */
                    intValue() {
                        return 900;
                    }
                }
                Level.LevelWarning = LevelWarning;
                LevelWarning["__class"] = "java.util.logging.Level.LevelWarning";
                LevelWarning["__interfaces"] = ["java.io.Serializable"];
            })(Level = logging.Level || (logging.Level = {}));
        })(logging = util.logging || (util.logging = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        var logging;
        (function (logging) {
            /**
             * An emulation of the java.util.logging.LogManager class. See
             * <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/util/logging/LogManger.html">
             * The Java API doc for details</a>
             * @class
             */
            class LogManager {
                constructor() {
                    /*private*/ this.loggerMap = (new java.util.HashMap());
                }
                static getLogManager() {
                    if (LogManager.singleton == null) {
                        LogManager.singleton = new LogManager();
                        let rootLogger = new java.util.logging.Logger("", null);
                        rootLogger.setLevel(java.util.logging.Level.INFO_$LI$());
                        LogManager.singleton.addLoggerImpl(rootLogger);
                    }
                    return LogManager.singleton;
                }
                addLogger(logger) {
                    if (this.getLogger(logger.getName()) != null) {
                        return false;
                    }
                    this.addLoggerAndEnsureParents(logger);
                    return true;
                }
                getLogger(name) {
                    return this.loggerMap.get(name);
                }
                getLoggerNames() {
                    return java.util.Collections.enumeration(this.loggerMap.keySet());
                }
                /**
                 * Helper function to add a logger when we have already determined that it
                 * does not exist.  When we add a logger, we recursively add all of it's
                 * ancestors. Since loggers do not get removed, logger creation is cheap,
                 * and there are not usually too many loggers in an ancestry chain,
                 * this is a simple way to ensure that the parent/child relationships are
                 * always correctly set up.
                 * @param {java.util.logging.Logger} logger
                 * @private
                 */
                /*private*/ addLoggerAndEnsureParents(logger) {
                    let name = logger.getName();
                    let parentName = name.substring(0, Math.max(0, name.lastIndexOf('.')));
                    logger.setParent(this.ensureLogger(parentName));
                    this.addLoggerImpl(logger);
                }
                /*private*/ addLoggerImpl(logger) {
                    if (((o1, o2) => { if (o1 && o1.equals) {
                        return o1.equals(o2);
                    }
                    else {
                        return o1 === o2;
                    } })(java.lang.System.getProperty$java_lang_String$java_lang_String("gwt.logging.simpleConsoleHandler", "ENABLED"), "ENABLED")) {
                        if ((logger.getName().length === 0)) {
                            logger.addHandler(new java.util.logging.SimpleConsoleLogHandler());
                        }
                    }
                    this.loggerMap.put(logger.getName(), logger);
                }
                /**
                 * Helper function to create a logger if it does not exist since the public
                 * APIs for getLogger and addLogger make it difficult to use those functions
                 * for this.
                 * @param {string} name
                 * @return {java.util.logging.Logger}
                 */
                ensureLogger(name) {
                    let logger = this.getLogger(name);
                    if (logger == null) {
                        let newLogger = new java.util.logging.Logger(name, null);
                        this.addLoggerAndEnsureParents(newLogger);
                        return newLogger;
                    }
                    return logger;
                }
            }
            LogManager.singleton = null;
            logging.LogManager = LogManager;
            LogManager["__class"] = "java.util.logging.LogManager";
        })(logging = util.logging || (util.logging = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        var logging;
        (function (logging) {
            /**
             * An emulation of the java.util.logging.LogRecord class. See
             * <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/util/logging/LogRecord.html">
             * The Java API doc for details</a>
             * @param {java.util.logging.Level} level
             * @param {string} msg
             * @class
             */
            class LogRecord {
                constructor(level, msg) {
                    /*private*/ this.loggerName = "";
                    /*private*/ this.thrown = null;
                    if (((level != null && level instanceof java.util.logging.Level) || level === null) && ((typeof msg === 'string') || msg === null)) {
                        let __args = arguments;
                        if (this.level === undefined)
                            this.level = null;
                        if (this.msg === undefined)
                            this.msg = null;
                        if (this.millis === undefined)
                            this.millis = 0;
                        this.loggerName = "";
                        this.thrown = null;
                        if (this.level === undefined)
                            this.level = null;
                        if (this.msg === undefined)
                            this.msg = null;
                        if (this.millis === undefined)
                            this.millis = 0;
                        (() => {
                            this.level = level;
                            this.msg = msg;
                            this.millis = java.lang.System.currentTimeMillis();
                        })();
                    }
                    else if (level === undefined && msg === undefined) {
                        let __args = arguments;
                        if (this.level === undefined)
                            this.level = null;
                        if (this.msg === undefined)
                            this.msg = null;
                        if (this.millis === undefined)
                            this.millis = 0;
                        this.loggerName = "";
                        this.thrown = null;
                        if (this.level === undefined)
                            this.level = null;
                        if (this.msg === undefined)
                            this.msg = null;
                        if (this.millis === undefined)
                            this.millis = 0;
                    }
                    else
                        throw new Error('invalid overload');
                }
                getLevel() {
                    return this.level;
                }
                getLoggerName() {
                    return this.loggerName;
                }
                getMessage() {
                    return this.msg;
                }
                getMillis() {
                    return this.millis;
                }
                getThrown() {
                    return this.thrown;
                }
                setLevel(newLevel) {
                    this.level = newLevel;
                }
                setLoggerName(newName) {
                    this.loggerName = newName;
                }
                setMessage(newMessage) {
                    this.msg = newMessage;
                }
                setMillis(newMillis) {
                    this.millis = newMillis;
                }
                setThrown(newThrown) {
                    this.thrown = newThrown;
                }
            }
            logging.LogRecord = LogRecord;
            LogRecord["__class"] = "java.util.logging.LogRecord";
            LogRecord["__interfaces"] = ["java.io.Serializable"];
        })(logging = util.logging || (util.logging = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        /**
         * See <a
         * href="http://docs.oracle.com/javase/7/docs/api/java/util/Objects.html">the
         * official Java API doc</a> for details.
         * @class
         */
        class Objects {
            constructor() {
            }
            static compare(a, b, c) {
                return a === b ? 0 : c.compare(a, b);
            }
            static deepEquals(a, b) {
                if (a === b) {
                    return true;
                }
                if (a == null || b == null) {
                    return false;
                }
                if (((o1, o2) => { if (o1 && o1.equals) {
                    return o1.equals(o2);
                }
                else {
                    return o1 === o2;
                } })(a, b)) {
                    return true;
                }
                let class1 = a.constructor;
                let class2 = b.constructor;
                if (!class1.isArray() || !((o1, o2) => { if (o1 && o1.equals) {
                    return o1.equals(o2);
                }
                else {
                    return o1 === o2;
                } })(class1, class2)) {
                    return false;
                }
                if (a != null && a instanceof Array && (a.length == 0 || a[0] == null || a[0] != null)) {
                    return java.util.Arrays.deepEquals(a, b);
                }
                if (a != null && a instanceof Array && (a.length == 0 || a[0] == null || typeof a[0] === 'boolean')) {
                    return java.util.Arrays.equals$boolean_A$boolean_A(a, b);
                }
                if (a != null && a instanceof Array && (a.length == 0 || a[0] == null || typeof a[0] === 'number')) {
                    return java.util.Arrays.equals$byte_A$byte_A(a, b);
                }
                if (a != null && a instanceof Array && (a.length == 0 || a[0] == null || typeof a[0] === 'string')) {
                    return java.util.Arrays.equals$char_A$char_A(a, b);
                }
                if (a != null && a instanceof Array && (a.length == 0 || a[0] == null || typeof a[0] === 'number')) {
                    return java.util.Arrays.equals$short_A$short_A(a, b);
                }
                if (a != null && a instanceof Array && (a.length == 0 || a[0] == null || typeof a[0] === 'number')) {
                    return java.util.Arrays.equals$int_A$int_A(a, b);
                }
                if (a != null && a instanceof Array && (a.length == 0 || a[0] == null || typeof a[0] === 'number')) {
                    return java.util.Arrays.equals$long_A$long_A(a, b);
                }
                if (a != null && a instanceof Array && (a.length == 0 || a[0] == null || typeof a[0] === 'number')) {
                    return java.util.Arrays.equals$float_A$float_A(a, b);
                }
                if (a != null && a instanceof Array && (a.length == 0 || a[0] == null || typeof a[0] === 'number')) {
                    return java.util.Arrays.equals$double_A$double_A(a, b);
                }
                return true;
            }
            static equals(a, b) {
                return (a === b) || (a != null && ((o1, o2) => { if (o1 && o1.equals) {
                    return o1.equals(o2);
                }
                else {
                    return o1 === o2;
                } })(a, b));
            }
            static hashCode(o) {
                return o != null ? ((o) => { if (o.hashCode) {
                    return o.hashCode();
                }
                else {
                    return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                } })(o) : 0;
            }
            static hash(...values) {
                return java.util.Arrays.hashCode$java_lang_Object_A(values);
            }
            static isNull(obj) {
                return obj == null;
            }
            static nonNull(obj) {
                return obj != null;
            }
            static requireNonNull$java_lang_Object(obj) {
                if (obj == null) {
                    throw new java.lang.NullPointerException();
                }
                return obj;
            }
            static requireNonNull$java_lang_Object$java_lang_String(obj, message) {
                if (obj == null) {
                    throw new java.lang.NullPointerException(message);
                }
                return obj;
            }
            static requireNonNull(obj, message) {
                if (((obj != null) || obj === null) && ((typeof message === 'string') || message === null)) {
                    return java.util.Objects.requireNonNull$java_lang_Object$java_lang_String(obj, message);
                }
                else if (((obj != null) || obj === null) && ((typeof message === 'function' && message.length == 0) || message === null)) {
                    return java.util.Objects.requireNonNull$java_lang_Object$java_util_function_Supplier(obj, message);
                }
                else if (((obj != null) || obj === null) && message === undefined) {
                    return java.util.Objects.requireNonNull$java_lang_Object(obj);
                }
                else
                    throw new Error('invalid overload');
            }
            static requireNonNull$java_lang_Object$java_util_function_Supplier(obj, messageSupplier) {
                if (obj == null) {
                    throw new java.lang.NullPointerException((target => (typeof target === 'function') ? target() : target.get())(messageSupplier));
                }
                return obj;
            }
            static toString$java_lang_Object(o) {
                return new String(o).toString();
            }
            static toString$java_lang_Object$java_lang_String(o, nullDefault) {
                return o != null ? o.toString() : nullDefault;
            }
            static toString(o, nullDefault) {
                if (((o != null) || o === null) && ((typeof nullDefault === 'string') || nullDefault === null)) {
                    return java.util.Objects.toString$java_lang_Object$java_lang_String(o, nullDefault);
                }
                else if (((o != null) || o === null) && nullDefault === undefined) {
                    return java.util.Objects.toString$java_lang_Object(o);
                }
                else
                    throw new Error('invalid overload');
            }
        }
        util.Objects = Objects;
        Objects["__class"] = "java.util.Objects";
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        /**
         * Construct an Observable with zero Observers.
         * @class
         */
        class Observable {
            constructor() {
                /*private*/ this.changed = false;
                if (this.obs === undefined)
                    this.obs = null;
                this.obs = (new java.util.Vector());
            }
            /**
             * Adds an observer to the set of observers for this object, provided that
             * it is not the same as some observer already in the set. The order in
             * which notifications will be delivered to multiple observers is not
             * specified. See the class comment.
             *
             * @param {*} o
             * an observer to be added.
             * @throws NullPointerException
             * if the parameter o is null.
             */
            addObserver(o) {
                if (o == null)
                    throw new java.lang.NullPointerException();
                if (!this.obs.contains(o)) {
                    this.obs.addElement(o);
                }
            }
            /**
             * Deletes an observer from the set of observers of this object. Passing
             * <CODE>null</CODE> to this method will have no effect.
             *
             * @param {*} o
             * the observer to be deleted.
             */
            deleteObserver(o) {
                this.obs.removeElement(o);
            }
            notifyObservers$() {
                this.notifyObservers$java_lang_Object(null);
            }
            notifyObservers$java_lang_Object(arg) {
                let arrLocal;
                if (!this.changed)
                    return;
                arrLocal = this.obs.toArray();
                this.clearChanged();
                for (let i = arrLocal.length - 1; i >= 0; i--) {
                    arrLocal[i].update(this, arg);
                }
            }
            /**
             * If this object has changed, as indicated by the <code>hasChanged</code>
             * method, then notify all of its observers and then call the
             * <code>clearChanged</code> method to indicate that this object has no
             * longer changed.
             * <p>
             * Each observer has its <code>update</code> method called with two
             * arguments: this observable object and the <code>arg</code> argument.
             *
             * @param {*} arg
             * any object.
             * @see java.util.Observable#clearChanged()
             * @see java.util.Observable#hasChanged()
             * @see java.util.Observer#update(java.util.Observable, java.lang.Object)
             */
            notifyObservers(arg) {
                if (((arg != null) || arg === null)) {
                    return this.notifyObservers$java_lang_Object(arg);
                }
                else if (arg === undefined) {
                    return this.notifyObservers$();
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             * Clears the observer list so that this object no longer has any observers.
             */
            deleteObservers() {
                this.obs.removeAllElements();
            }
            /**
             * Marks this <tt>Observable</tt> object as having been changed; the
             * <tt>hasChanged</tt> method will now return <tt>true</tt>.
             */
            setChanged() {
                this.changed = true;
            }
            /**
             * Indicates that this object has no longer changed, or that it has already
             * notified all of its observers of its most recent change, so that the
             * <tt>hasChanged</tt> method will now return <tt>false</tt>. This method is
             * called automatically by the <code>notifyObservers</code> methods.
             *
             * @see java.util.Observable#notifyObservers()
             * @see java.util.Observable#notifyObservers(java.lang.Object)
             */
            clearChanged() {
                this.changed = false;
            }
            /**
             * Tests if this object has changed.
             *
             * @return {boolean} <code>true</code> if and only if the <code>setChanged</code>
             * method has been called more recently than the
             * <code>clearChanged</code> method on this object;
             * <code>false</code> otherwise.
             * @see java.util.Observable#clearChanged()
             * @see java.util.Observable#setChanged()
             */
            hasChanged() {
                return this.changed;
            }
            /**
             * Returns the number of observers of this <tt>Observable</tt> object.
             *
             * @return {number} the number of observers of this object.
             */
            countObservers() {
                return this.obs.size();
            }
        }
        util.Observable = Observable;
        Observable["__class"] = "java.util.Observable";
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        /**
         * See <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html">
         * the official Java API doc</a> for details.
         *
         * @param <T> type of the wrapped reference
         * @class
         */
        class Optional {
            constructor(ref) {
                if (((ref != null) || ref === null)) {
                    let __args = arguments;
                    if (this.ref === undefined)
                        this.ref = null;
                    if (this.ref === undefined)
                        this.ref = null;
                    (() => {
                        this.ref = (javaemul.internal.InternalPreconditions.checkCriticalNotNull(ref));
                    })();
                }
                else if (ref === undefined) {
                    let __args = arguments;
                    if (this.ref === undefined)
                        this.ref = null;
                    if (this.ref === undefined)
                        this.ref = null;
                    (() => {
                        this.ref = null;
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            static empty() {
                return Optional.EMPTY_$LI$();
            }
            static of(value) {
                return (new Optional(value));
            }
            static ofNullable(value) {
                return value == null ? Optional.empty() : Optional.of(value);
            }
            static EMPTY_$LI$() { if (Optional.EMPTY == null)
                Optional.EMPTY = (new Optional()); return Optional.EMPTY; }
            ;
            isPresent() {
                return this.ref != null;
            }
            get() {
                javaemul.internal.InternalPreconditions.checkCriticalElement(this.isPresent());
                return this.ref;
            }
            ifPresent(consumer) {
                if (this.isPresent()) {
                    (target => (typeof target === 'function') ? target(this.ref) : target.accept(this.ref))(consumer);
                }
            }
            filter(predicate) {
                javaemul.internal.InternalPreconditions.checkCriticalNotNull((predicate));
                if (!this.isPresent() || (target => (typeof target === 'function') ? target(this.ref) : target.test(this.ref))(predicate)) {
                    return this;
                }
                return Optional.empty();
            }
            map(mapper) {
                javaemul.internal.InternalPreconditions.checkCriticalNotNull((mapper));
                if (this.isPresent()) {
                    return Optional.ofNullable((target => (typeof target === 'function') ? target(this.ref) : target.apply(this.ref))(mapper));
                }
                return Optional.empty();
            }
            flatMap(mapper) {
                javaemul.internal.InternalPreconditions.checkCriticalNotNull((mapper));
                if (this.isPresent()) {
                    return (javaemul.internal.InternalPreconditions.checkCriticalNotNull((target => (typeof target === 'function') ? target(this.ref) : target.apply(this.ref))(mapper)));
                }
                return Optional.empty();
            }
            orElse(other) {
                return this.isPresent() ? this.ref : other;
            }
            orElseGet(other) {
                return this.isPresent() ? this.ref : (target => (typeof target === 'function') ? target() : target.get())(other);
            }
            orElseThrow(exceptionSupplier) {
                if (this.isPresent()) {
                    return this.ref;
                }
                throw (target => (typeof target === 'function') ? target() : target.get())(exceptionSupplier);
            }
            /**
             *
             * @param {*} obj
             * @return {boolean}
             */
            equals(obj) {
                if (obj === this) {
                    return true;
                }
                if (!(obj != null && obj instanceof java.util.Optional)) {
                    return false;
                }
                let other = obj;
                return java.util.Objects.equals(this.ref, other.ref);
            }
            /**
             *
             * @return {number}
             */
            hashCode() {
                return java.util.Objects.hashCode(this.ref);
            }
            /**
             *
             * @return {string}
             */
            toString() {
                return this.isPresent() ? "Optional.of(" + new String(this.ref).toString() + ")" : "Optional.empty()";
            }
        }
        util.Optional = Optional;
        Optional["__class"] = "java.util.Optional";
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        /**
         * See <a href="https://docs.oracle.com/javase/8/docs/api/java/util/OptionalDouble.html">
         * the official Java API doc</a> for details.
         * @class
         */
        class OptionalDouble {
            constructor(value) {
                if (((typeof value === 'number') || value === null)) {
                    let __args = arguments;
                    if (this.ref === undefined)
                        this.ref = 0;
                    if (this.present === undefined)
                        this.present = false;
                    if (this.ref === undefined)
                        this.ref = 0;
                    if (this.present === undefined)
                        this.present = false;
                    (() => {
                        this.ref = value;
                        this.present = true;
                    })();
                }
                else if (value === undefined) {
                    let __args = arguments;
                    if (this.ref === undefined)
                        this.ref = 0;
                    if (this.present === undefined)
                        this.present = false;
                    if (this.ref === undefined)
                        this.ref = 0;
                    if (this.present === undefined)
                        this.present = false;
                    (() => {
                        this.ref = 0;
                        this.present = false;
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            static empty() {
                return OptionalDouble.EMPTY_$LI$();
            }
            static of(value) {
                return new OptionalDouble(value);
            }
            static EMPTY_$LI$() { if (OptionalDouble.EMPTY == null)
                OptionalDouble.EMPTY = new OptionalDouble(); return OptionalDouble.EMPTY; }
            ;
            isPresent() {
                return this.present;
            }
            getAsDouble() {
                javaemul.internal.InternalPreconditions.checkCriticalElement(this.present);
                return this.ref;
            }
            ifPresent(consumer) {
                if (this.present) {
                    (target => (typeof target === 'function') ? target(this.ref) : target.accept(this.ref))(consumer);
                }
            }
            orElse(other) {
                return this.present ? this.ref : other;
            }
            orElseGet(other) {
                return this.present ? this.ref : (target => (typeof target === 'function') ? target() : target.getAsDouble())(other);
            }
            orElseThrow(exceptionSupplier) {
                if (this.present) {
                    return this.ref;
                }
                throw (target => (typeof target === 'function') ? target() : target.get())(exceptionSupplier);
            }
            /**
             *
             * @param {*} obj
             * @return {boolean}
             */
            equals(obj) {
                if (obj === this) {
                    return true;
                }
                if (!(obj != null && obj instanceof java.util.OptionalDouble)) {
                    return false;
                }
                let other = obj;
                return this.present === other.present && (this.ref - other.ref) === 0;
            }
            /**
             *
             * @return {number}
             */
            hashCode() {
                return this.present ? javaemul.internal.DoubleHelper.hashCode(this.ref) : 0;
            }
            /**
             *
             * @return {string}
             */
            toString() {
                return this.present ? "OptionalDouble.of(" + ('' + (this.ref)) + ")" : "OptionalDouble.empty()";
            }
        }
        util.OptionalDouble = OptionalDouble;
        OptionalDouble["__class"] = "java.util.OptionalDouble";
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        /**
         * See <a href="https://docs.oracle.com/javase/8/docs/api/java/util/OptionalInt.html">
         * the official Java API doc</a> for details.
         * @class
         */
        class OptionalInt {
            constructor(value) {
                if (((typeof value === 'number') || value === null)) {
                    let __args = arguments;
                    if (this.ref === undefined)
                        this.ref = 0;
                    if (this.present === undefined)
                        this.present = false;
                    if (this.ref === undefined)
                        this.ref = 0;
                    if (this.present === undefined)
                        this.present = false;
                    (() => {
                        this.ref = value;
                        this.present = true;
                    })();
                }
                else if (value === undefined) {
                    let __args = arguments;
                    if (this.ref === undefined)
                        this.ref = 0;
                    if (this.present === undefined)
                        this.present = false;
                    if (this.ref === undefined)
                        this.ref = 0;
                    if (this.present === undefined)
                        this.present = false;
                    (() => {
                        this.ref = 0;
                        this.present = false;
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            static empty() {
                return OptionalInt.EMPTY_$LI$();
            }
            static of(value) {
                return new OptionalInt(value);
            }
            static EMPTY_$LI$() { if (OptionalInt.EMPTY == null)
                OptionalInt.EMPTY = new OptionalInt(); return OptionalInt.EMPTY; }
            ;
            isPresent() {
                return this.present;
            }
            getAsInt() {
                javaemul.internal.InternalPreconditions.checkCriticalElement(this.present);
                return this.ref;
            }
            ifPresent(consumer) {
                if (this.present) {
                    (target => (typeof target === 'function') ? target(this.ref) : target.accept(this.ref))(consumer);
                }
            }
            orElse(other) {
                return this.present ? this.ref : other;
            }
            orElseGet(other) {
                return this.present ? this.ref : (target => (typeof target === 'function') ? target() : target.getAsInt())(other);
            }
            orElseThrow(exceptionSupplier) {
                if (this.present) {
                    return this.ref;
                }
                throw (target => (typeof target === 'function') ? target() : target.get())(exceptionSupplier);
            }
            /**
             *
             * @param {*} obj
             * @return {boolean}
             */
            equals(obj) {
                if (obj === this) {
                    return true;
                }
                if (!(obj != null && obj instanceof java.util.OptionalInt)) {
                    return false;
                }
                let other = obj;
                return this.present === other.present && (this.ref - other.ref) === 0;
            }
            /**
             *
             * @return {number}
             */
            hashCode() {
                return this.present ? javaemul.internal.IntegerHelper.hashCode(this.ref) : 0;
            }
            /**
             *
             * @return {string}
             */
            toString() {
                return this.present ? "OptionalInt.of(" + ('' + (this.ref)) + ")" : "OptionalInt.empty()";
            }
        }
        util.OptionalInt = OptionalInt;
        OptionalInt["__class"] = "java.util.OptionalInt";
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        /**
         * See <a href="https://docs.oracle.com/javase/8/docs/api/java/util/OptionalLong.html">
         * the official Java API doc</a> for details.
         * @class
         */
        class OptionalLong {
            constructor(value) {
                if (((typeof value === 'number') || value === null)) {
                    let __args = arguments;
                    if (this.ref === undefined)
                        this.ref = 0;
                    if (this.present === undefined)
                        this.present = false;
                    if (this.ref === undefined)
                        this.ref = 0;
                    if (this.present === undefined)
                        this.present = false;
                    (() => {
                        this.ref = value;
                        this.present = true;
                    })();
                }
                else if (value === undefined) {
                    let __args = arguments;
                    if (this.ref === undefined)
                        this.ref = 0;
                    if (this.present === undefined)
                        this.present = false;
                    if (this.ref === undefined)
                        this.ref = 0;
                    if (this.present === undefined)
                        this.present = false;
                    (() => {
                        this.ref = 0;
                        this.present = false;
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            static empty() {
                return OptionalLong.EMPTY_$LI$();
            }
            static of(value) {
                return new OptionalLong(value);
            }
            static EMPTY_$LI$() { if (OptionalLong.EMPTY == null)
                OptionalLong.EMPTY = new OptionalLong(); return OptionalLong.EMPTY; }
            ;
            isPresent() {
                return this.present;
            }
            getAsLong() {
                javaemul.internal.InternalPreconditions.checkCriticalElement(this.present);
                return this.ref;
            }
            ifPresent(consumer) {
                if (this.present) {
                    (target => (typeof target === 'function') ? target(this.ref) : target.accept(this.ref))(consumer);
                }
            }
            orElse(other) {
                return this.present ? this.ref : other;
            }
            orElseGet(other) {
                return this.present ? this.ref : (target => (typeof target === 'function') ? target() : target.getAsLong())(other);
            }
            orElseThrow(exceptionSupplier) {
                if (this.present) {
                    return this.ref;
                }
                throw (target => (typeof target === 'function') ? target() : target.get())(exceptionSupplier);
            }
            /**
             *
             * @param {*} obj
             * @return {boolean}
             */
            equals(obj) {
                if (obj === this) {
                    return true;
                }
                if (!(obj != null && obj instanceof java.util.OptionalLong)) {
                    return false;
                }
                let other = obj;
                return this.present === other.present && (this.ref - other.ref) === 0;
            }
            /**
             *
             * @return {number}
             */
            hashCode() {
                return this.present ? javaemul.internal.LongHelper.hashCode(this.ref) : 0;
            }
            /**
             *
             * @return {string}
             */
            toString() {
                return this.present ? "OptionalLong.of(" + ('' + (this.ref)) + ")" : "OptionalLong.empty()";
            }
        }
        util.OptionalLong = OptionalLong;
        OptionalLong["__class"] = "java.util.OptionalLong";
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        /**
         * Construct a random generator with the given {@code seed} as the initial
         * state.
         *
         * @param {number} seed the seed that will determine the initial state of this random
         * number generator.
         * @see #setSeed
         * @class
         */
        class Random {
            constructor(seed) {
                /**
                 * The boolean value indicating if the second Gaussian number is available.
                 */
                /*private*/ this.haveNextNextGaussian = false;
                if (((typeof seed === 'number') || seed === null)) {
                    let __args = arguments;
                    if (this.nextNextGaussian === undefined)
                        this.nextNextGaussian = 0;
                    if (this.seedhi === undefined)
                        this.seedhi = 0;
                    if (this.seedlo === undefined)
                        this.seedlo = 0;
                    this.haveNextNextGaussian = false;
                    if (this.nextNextGaussian === undefined)
                        this.nextNextGaussian = 0;
                    if (this.seedhi === undefined)
                        this.seedhi = 0;
                    if (this.seedlo === undefined)
                        this.seedlo = 0;
                    (() => {
                        this.setSeed$long(seed);
                    })();
                }
                else if (seed === undefined) {
                    let __args = arguments;
                    if (this.nextNextGaussian === undefined)
                        this.nextNextGaussian = 0;
                    if (this.seedhi === undefined)
                        this.seedhi = 0;
                    if (this.seedlo === undefined)
                        this.seedlo = 0;
                    this.haveNextNextGaussian = false;
                    if (this.nextNextGaussian === undefined)
                        this.nextNextGaussian = 0;
                    if (this.seedhi === undefined)
                        this.seedhi = 0;
                    if (this.seedlo === undefined)
                        this.seedlo = 0;
                    (() => {
                        let seed = Random.uniqueSeed++ + javaemul.internal.DateUtil.now();
                        let hi = (Math.floor(seed * Random.twoToTheMinus24) | 0) & 16777215;
                        let lo = ((seed - (hi * Random.twoToThe24)) | 0);
                        this.setSeed$int$int(hi, lo);
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            static __static_initialize() { if (!Random.__static_initialized) {
                Random.__static_initialized = true;
                Random.__static_initializer_0();
            } }
            static twoToTheXMinus24_$LI$() { Random.__static_initialize(); if (Random.twoToTheXMinus24 == null)
                Random.twoToTheXMinus24 = (s => { let a = []; while (s-- > 0)
                    a.push(0); return a; })(25); return Random.twoToTheXMinus24; }
            ;
            static twoToTheXMinus48_$LI$() { Random.__static_initialize(); if (Random.twoToTheXMinus48 == null)
                Random.twoToTheXMinus48 = (s => { let a = []; while (s-- > 0)
                    a.push(0); return a; })(33); return Random.twoToTheXMinus48; }
            ;
            static __static_initializer_0() {
                let twoToTheXMinus48Tmp = 1.52587890625E-5;
                for (let i = 32; i >= 0; i--) {
                    {
                        Random.twoToTheXMinus48_$LI$()[i] = twoToTheXMinus48Tmp;
                        twoToTheXMinus48Tmp *= 0.5;
                    }
                    ;
                }
                let twoToTheXMinus24Tmp = 1.0;
                for (let i = 24; i >= 0; i--) {
                    {
                        Random.twoToTheXMinus24_$LI$()[i] = twoToTheXMinus24Tmp;
                        twoToTheXMinus24Tmp *= 0.5;
                    }
                    ;
                }
            }
            /**
             * Returns the next pseudo-random, uniformly distributed {@code boolean} value
             * generated by this generator.
             *
             * @return {boolean} a pseudo-random, uniformly distributed boolean value.
             */
            nextBoolean() {
                return this.nextInternal(1) !== 0;
            }
            /**
             * Modifies the {@code byte} array by a random sequence of {@code byte}s
             * generated by this random number generator.
             *
             * @param {Array} buf non-null array to contain the new random {@code byte}s.
             * @see #next
             */
            nextBytes(buf) {
                javaemul.internal.InternalPreconditions.checkNotNull(buf);
                let rand = 0;
                let count = 0;
                let loop = 0;
                while ((count < buf.length)) {
                    {
                        if (loop === 0) {
                            rand = (this.nextInternal(32) | 0);
                            loop = 3;
                        }
                        else {
                            loop--;
                        }
                        buf[count++] = (rand | 0);
                        rand >>= 8;
                    }
                }
                ;
            }
            /**
             * Generates a normally distributed random {@code double} number between 0.0
             * inclusively and 1.0 exclusively.
             *
             * @return {number} a random {@code double} in the range [0.0 - 1.0)
             * @see #nextFloat
             */
            nextDouble() {
                return this.nextInternal(26) * Random.twoToTheMinus26 + this.nextInternal(27) * Random.twoToTheMinus53;
            }
            /**
             * Generates a normally distributed random {@code float} number between 0.0
             * inclusively and 1.0 exclusively.
             *
             * @return {number} float a random {@code float} number between [0.0 and 1.0)
             * @see #nextDouble
             */
            nextFloat() {
                return Math.fround((this.nextInternal(24) * Random.twoToTheMinus24));
            }
            /**
             * Pseudo-randomly generates (approximately) a normally distributed {@code
             * double} value with mean 0.0 and a standard deviation value of {@code 1.0}
             * using the <i>polar method<i> of G. E. P. Box, M. E. Muller, and G.
             * Marsaglia, as described by Donald E. Knuth in <i>The Art of Computer
             * Programming, Volume 2: Seminumerical Algorithms</i>, section 3.4.1,
             * subsection C, algorithm P.
             *
             * @return {number} a random {@code double}
             * @see #nextDouble
             */
            nextGaussian() {
                if (this.haveNextNextGaussian) {
                    this.haveNextNextGaussian = false;
                    return this.nextNextGaussian;
                }
                let v1;
                let v2;
                let s;
                do {
                    {
                        v1 = 2 * this.nextDouble() - 1;
                        v2 = 2 * this.nextDouble() - 1;
                        s = v1 * v1 + v2 * v2;
                    }
                } while ((s >= 1));
                let norm = (s === 0) ? 0.0 : Math.sqrt(-2.0 * Math.log(s) / s);
                this.nextNextGaussian = v2 * norm;
                this.haveNextNextGaussian = true;
                return v1 * norm;
            }
            nextInt$() {
                return (this.nextInternal(32) | 0);
            }
            nextInt$int(n) {
                javaemul.internal.InternalPreconditions.checkCriticalArgument(n > 0, "Random nextInt parameter can only be positive: %s", /* toString */ ('' + (n)));
                if ((n & -n) === n) {
                    return (((n * this.nextInternal(31)) * Random.twoToTheMinus31) | 0);
                }
                let bits;
                let val;
                do {
                    {
                        bits = this.nextInternal(31);
                        val = bits % n;
                    }
                } while ((bits - val + (n - 1) < 0));
                return (val | 0);
            }
            /**
             * Returns a new pseudo-random {@code int} value which is uniformly
             * distributed between 0 (inclusively) and the value of {@code n}
             * (exclusively).
             *
             * @param {number} n the exclusive upper border of the range [0 - n).
             * @return {number} a random {@code int}.
             */
            nextInt(n) {
                if (((typeof n === 'number') || n === null)) {
                    return this.nextInt$int(n);
                }
                else if (n === undefined) {
                    return this.nextInt$();
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             * Generates a uniformly distributed 64-bit integer value from the random
             * number sequence.
             *
             * @return {number} 64-bit random integer.
             * @see java.lang.Integer#MAX_VALUE
             * @see java.lang.Integer#MIN_VALUE
             * @see #next
             * @see #nextInt()
             * @see #nextInt(int)
             */
            nextLong() {
                return ((n => n < 0 ? Math.ceil(n) : Math.floor(n))(this.nextInternal(32)) << 32) + (n => n < 0 ? Math.ceil(n) : Math.floor(n))(this.nextInternal(32));
            }
            setSeed$long(seed) {
                this.setSeed$int$int((((seed >> 24) & 16777215) | 0), ((seed & 16777215) | 0));
            }
            /**
             * Returns a pseudo-random uniformly distributed {@code int} value of the
             * number of bits specified by the argument {@code bits} as described by
             * Donald E. Knuth in <i>The Art of Computer Programming, Volume 2:
             * Seminumerical Algorithms</i>, section 3.2.1.
             *
             * @param {number} bits number of bits of the returned value.
             * @return {number} a pseudo-random generated int number.
             * @see #nextBytes
             * @see #nextDouble
             * @see #nextFloat
             * @see #nextInt()
             * @see #nextInt(int)
             * @see #nextGaussian
             * @see #nextLong
             */
            next(bits) {
                return (this.nextInternal(bits) | 0);
            }
            /*private*/ nextInternal(bits) {
                let hi = this.seedhi * Random.multiplierLo + this.seedlo * Random.multiplierHi;
                let lo = this.seedlo * Random.multiplierLo + 11;
                let carry = Math.floor(lo * Random.twoToTheMinus24);
                hi += carry;
                lo -= carry * Random.twoToThe24;
                hi %= Random.twoToThe24;
                this.seedhi = hi;
                this.seedlo = lo;
                if (bits <= 24) {
                    return Math.floor(this.seedhi * Random.twoToTheXMinus24_$LI$()[bits]);
                }
                else {
                    let h = this.seedhi * (1 << (bits - 24));
                    let l = Math.floor(this.seedlo * Random.twoToTheXMinus48_$LI$()[bits]);
                    let dval = h + l;
                    if (dval >= Random.twoToThe31) {
                        dval -= Random.twoToThe32;
                    }
                    return dval;
                }
            }
            setSeed$int$int(seedhi, seedlo) {
                this.seedhi = seedhi ^ 1502;
                this.seedlo = seedlo ^ 15525485;
                this.haveNextNextGaussian = false;
            }
            setSeed(seedhi, seedlo) {
                if (((typeof seedhi === 'number') || seedhi === null) && ((typeof seedlo === 'number') || seedlo === null)) {
                    return this.setSeed$int$int(seedhi, seedlo);
                }
                else if (((typeof seedhi === 'number') || seedhi === null) && seedlo === undefined) {
                    return this.setSeed$long(seedhi);
                }
                else
                    throw new Error('invalid overload');
            }
        }
        Random.__static_initialized = false;
        Random.multiplierHi = 1502;
        Random.multiplierLo = 15525485;
        Random.twoToThe24 = 1.6777216E7;
        Random.twoToThe31 = 2.147483648E9;
        Random.twoToThe32 = 4.294967296E9;
        Random.twoToTheMinus24 = 5.9604644775390625E-8;
        Random.twoToTheMinus26 = 1.4901161193847656E-8;
        Random.twoToTheMinus31 = 4.6566128730773926E-10;
        Random.twoToTheMinus53 = 1.1102230246251565E-16;
        /**
         * A value used to avoid two random number generators produced at the same
         * time having the same seed.
         */
        Random.uniqueSeed = 0;
        util.Random = Random;
        Random["__class"] = "java.util.Random";
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        var regex;
        (function (regex) {
            class Matcher {
                constructor(_pattern, text) {
                    if (this._pattern === undefined)
                        this._pattern = null;
                    if (this.text === undefined)
                        this.text = null;
                    if (this.starts === undefined)
                        this.starts = null;
                    if (this.ends === undefined)
                        this.ends = null;
                    if (this.groups === undefined)
                        this.groups = null;
                    this._pattern = _pattern;
                    this.text = text;
                    this.reset();
                }
                hasGroups() {
                    if (this.groups == null)
                        throw new java.lang.IllegalStateException("No match available");
                }
                searchWith(regExp) {
                    let startLastIndex = (regExp.lastIndex | 0);
                    let exec = regExp.exec(this.text);
                    this.groups = (exec);
                    if (this.groups == null) {
                        this.reset();
                        return false;
                    }
                    this.starts = [];
                    this.ends = [];
                    let parenthesisStart = [];
                    let parenthesisEnds = [];
                    let nonCapturesToCaptures = new Matcher.NonCapturesToCaptures(parenthesisStart, parenthesisEnds);
                    let regExpStringWithAllCaptures = (regExp.source).replace(new RegExp("((?:\\\\.|\\[\\^?\\]\\]|\\[\\^?(?:[^\\\\\\]]|\\\\.|)+\\])+)|\\(((?:\\?\\:)?)|(\\))", "g"), ((((nonCapturesToCaptures) => {
                        return (...args) => nonCapturesToCaptures.apply(args);
                    })(nonCapturesToCaptures))));
                    let regExpWithAllCaptures = new RegExp(regExpStringWithAllCaptures);
                    let indexGetter = new Matcher.IndexGetter(regExp.source, parenthesisStart, parenthesisEnds, this.starts, this.ends, startLastIndex);
                    (this.text.substring(startLastIndex)).replace(regExpWithAllCaptures, ((((indexGetter) => {
                        return (...args) => indexGetter.apply(args);
                    })(indexGetter))));
                    return true;
                }
                end$() {
                    return this.end$int(0);
                }
                end$int(i) {
                    this.hasGroups();
                    return this.ends[i];
                }
                end$java_lang_String(string) {
                    return this.end$int(this._pattern.namedGroupsNames.get(string) + this.regionStart());
                }
                end(string) {
                    if (((typeof string === 'string') || string === null)) {
                        return this.end$java_lang_String(string);
                    }
                    else if (((typeof string === 'number') || string === null)) {
                        return this.end$int(string);
                    }
                    else if (string === undefined) {
                        return this.end$();
                    }
                    else
                        throw new Error('invalid overload');
                }
                find$() {
                    return this.searchWith(this._pattern.regexp);
                }
                find$int(start) {
                    this._pattern.regexp.lastIndex = start;
                    return this.find();
                }
                find(start) {
                    if (((typeof start === 'number') || start === null)) {
                        return this.find$int(start);
                    }
                    else if (start === undefined) {
                        return this.find$();
                    }
                    else
                        throw new Error('invalid overload');
                }
                group$() {
                    return this.group$int(0);
                }
                group$int(i) {
                    this.hasGroups();
                    return this.groups[i];
                }
                group$java_lang_String(string) {
                    return this.group$int(this._pattern.namedGroupsNames.get(string) + this.regionStart());
                }
                group(string) {
                    if (((typeof string === 'string') || string === null)) {
                        return this.group$java_lang_String(string);
                    }
                    else if (((typeof string === 'number') || string === null)) {
                        return this.group$int(string);
                    }
                    else if (string === undefined) {
                        return this.group$();
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 *
                 * @return {number}
                 */
                groupCount() {
                    return this.groups.length - 1;
                }
                hitEnd() {
                    return this.end() === this.text.length;
                }
                lookingAt() {
                    this.reset();
                    return this.searchWith(java.util.regex.Pattern.compile$java_lang_String("^(?:" + this._pattern.pattern() + ")").regexp);
                }
                matches() {
                    this.reset();
                    return this.searchWith(java.util.regex.Pattern.compile$java_lang_String("^(?:" + this._pattern.pattern() + ")$").regexp);
                }
                pattern() {
                    return this._pattern;
                }
                regionEnd() {
                    this.hasGroups();
                    return this.groups.length;
                }
                regionStart() {
                    this.hasGroups();
                    return 1;
                }
                replaceAll(replacement) {
                    this.reset();
                    this.text = (this.text).replace(this._pattern.regexp, replacement);
                    return this.text;
                }
                replaceFirst(replacement) {
                    this.reset();
                    let firstReplacer = new Matcher.FirstReplacer(replacement);
                    this.text = (this.text).replace(this._pattern.regexp, (((((firstReplacer) => {
                        return (args) => firstReplacer.apply(args);
                    })(firstReplacer)))));
                    return this.text;
                }
                reset$() {
                    this._pattern.regexp.lastIndex = 0;
                    this.groups = null;
                    this.starts = null;
                    this.ends = null;
                    return this;
                }
                reset$java_lang_CharSequence(input) {
                    this.text = input.toString();
                    return this.reset();
                }
                reset(input) {
                    if (((input != null && (input["__interfaces"] != null && input["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || input.constructor != null && input.constructor["__interfaces"] != null && input.constructor["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || typeof input === "string")) || input === null)) {
                        return this.reset$java_lang_CharSequence(input);
                    }
                    else if (input === undefined) {
                        return this.reset$();
                    }
                    else
                        throw new Error('invalid overload');
                }
                start$() {
                    return this.start$int(0);
                }
                start$int(i) {
                    this.hasGroups();
                    return this.starts[i];
                }
                start$java_lang_String(string) {
                    return this.start$int(this._pattern.namedGroupsNames.get(string) + this.regionStart());
                }
                start(string) {
                    if (((typeof string === 'string') || string === null)) {
                        return this.start$java_lang_String(string);
                    }
                    else if (((typeof string === 'number') || string === null)) {
                        return this.start$int(string);
                    }
                    else if (string === undefined) {
                        return this.start$();
                    }
                    else
                        throw new Error('invalid overload');
                }
                toMatchResult() {
                    return this;
                }
                usePattern(newPattern) {
                    this._pattern = newPattern;
                    return this;
                }
            }
            regex.Matcher = Matcher;
            Matcher["__class"] = "java.util.regex.Matcher";
            Matcher["__interfaces"] = ["java.util.regex.MatchResult"];
            (function (Matcher) {
                class IndexGetter {
                    constructor(regexString, parenthesisStart, parenthesisEnd, starts, ends, startLastIndex) {
                        if (this.regexString === undefined)
                            this.regexString = null;
                        if (this.parenthesisStart === undefined)
                            this.parenthesisStart = null;
                        if (this.parenthesisEnd === undefined)
                            this.parenthesisEnd = null;
                        if (this.starts === undefined)
                            this.starts = null;
                        if (this.ends === undefined)
                            this.ends = null;
                        if (this.startLastIndex === undefined)
                            this.startLastIndex = 0;
                        this.regexString = regexString;
                        this.parenthesisStart = parenthesisStart;
                        this.parenthesisEnd = parenthesisEnd;
                        this.starts = starts;
                        this.ends = ends;
                        this.startLastIndex = startLastIndex;
                    }
                    /**
                     *
                     * @param {Array} args
                     * @return {string}
                     */
                    apply(args) {
                        (this.starts).push(((args[args.length - 2])));
                        (this.ends).push((this.starts[0]) + args[0].length);
                        let lastIndices = (new java.util.Stack());
                        lastIndices.push(this.ends[0]);
                        lastIndices.push(this.starts[0]);
                        let countEndsFrom = 0;
                        for (let i = 0; i < args.length - 3; ++i) {
                            {
                                let pl = this.parenthesisStart[i];
                                while ((this.parenthesisEnd[countEndsFrom] < pl)) {
                                    {
                                        countEndsFrom += 1;
                                        lastIndices.pop();
                                    }
                                }
                                ;
                                let start = lastIndices.pop();
                                let len = args[i + 1] != null ? args[i + 1].length : 0;
                                lastIndices.push(start + len);
                                lastIndices.push(start);
                                if ((c => c.charCodeAt == null ? c : c.charCodeAt(0))(this.regexString.charAt(pl + 1)) == '?'.charCodeAt(0)) {
                                    continue;
                                }
                                if (len === 0) {
                                    (this.starts).push(-1);
                                    (this.ends).push(-1);
                                }
                                else {
                                    start += this.startLastIndex;
                                    (this.starts).push(start);
                                    (this.ends).push(start + len);
                                }
                            }
                            ;
                        }
                        this.starts[0] += this.startLastIndex;
                        this.ends[0] += this.startLastIndex;
                        return args[0];
                    }
                }
                Matcher.IndexGetter = IndexGetter;
                IndexGetter["__class"] = "java.util.regex.Matcher.IndexGetter";
                IndexGetter["__interfaces"] = ["java.util.function.Function"];
                class NonCapturesToCaptures {
                    constructor(start, ends) {
                        if (this.start === undefined)
                            this.start = null;
                        if (this.ends === undefined)
                            this.ends = null;
                        this.start = start;
                        this.ends = ends;
                    }
                    /**
                     *
                     * @param {Array} args
                     * @return {string}
                     */
                    apply(args) {
                        if (args[1] !== undefined) {
                            return args[1];
                        }
                        if (args[2] !== undefined) {
                            (this.start).push(javaemul.internal.IntegerHelper.parseInt((args[args.length - 2])));
                            return "(";
                        }
                        if (args[3] !== undefined) {
                            (this.ends).push(javaemul.internal.IntegerHelper.parseInt((args[args.length - 2])));
                            return args[3];
                        }
                        throw new Error("NonCapturesToCaptures");
                    }
                }
                Matcher.NonCapturesToCaptures = NonCapturesToCaptures;
                NonCapturesToCaptures["__class"] = "java.util.regex.Matcher.NonCapturesToCaptures";
                NonCapturesToCaptures["__interfaces"] = ["java.util.function.Function"];
                class FirstReplacer {
                    constructor(replacement) {
                        this.first = true;
                        if (this.replacement === undefined)
                            this.replacement = null;
                        this.replacement = replacement;
                    }
                    /**
                     *
                     * @param {Array} args
                     * @return {string}
                     */
                    apply(args) {
                        if (this.first) {
                            this.first = false;
                            return this.replacement;
                        }
                        return args[0];
                    }
                }
                Matcher.FirstReplacer = FirstReplacer;
                FirstReplacer["__class"] = "java.util.regex.Matcher.FirstReplacer";
                FirstReplacer["__interfaces"] = ["java.util.function.Function"];
            })(Matcher = regex.Matcher || (regex.Matcher = {}));
        })(regex = util.regex || (util.regex = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        var regex;
        (function (regex_1) {
            class Pattern {
                constructor(regexp, _flags, namedGroupsNames) {
                    if (this.regexp === undefined)
                        this.regexp = null;
                    if (this._flags === undefined)
                        this._flags = 0;
                    if (this.namedGroupsNames === undefined)
                        this.namedGroupsNames = null;
                    this.regexp = regexp;
                    this._flags = _flags;
                    this.namedGroupsNames = namedGroupsNames;
                }
                static compile$java_lang_String(regexp) {
                    return Pattern.compile$java_lang_String$int(regexp, 0);
                }
                static compile$java_lang_String$int(regexpString, flags) {
                    let jsFlags = "g";
                    if ((flags & Pattern.MULTILINE) > 0) {
                        jsFlags += "m";
                    }
                    if ((flags & Pattern.CASE_INSENSITIVE) > 0) {
                        jsFlags += "i";
                    }
                    if ((flags & Pattern.UNICODE_CHARACTER_CLASS) > 0) {
                        jsFlags += "u";
                    }
                    if ((flags & Pattern.UNICODE_CASE) > 0) {
                        jsFlags += "ui";
                    }
                    let namedGroupsNames = (new java.util.HashMap());
                    let groupNameRemover = new Pattern.GroupNameRemover(namedGroupsNames);
                    regexpString = (regexpString).replace(new RegExp("(?:\\\\\\\\)*(\\\\?)\\[\\^?\\]?|(?:\\\\\\\\)*(\\\\?)\\]|(?:\\\\\\\\)*(\\\\?)\\((?:(\\?\\:)|\\?<([^>]+)>)?", "g"), (((((groupNameRemover) => {
                        return (...args) => groupNameRemover.apply(args);
                    })(groupNameRemover))))).replace(new RegExp("(\\?\\:|(?:[*+?]|\\{[^\\}]+\\})*)((?:[^\\\\()|]|\\\\.|\\[\\^?\\]\\]|\\[\\^?(?:[^\\\\\\]]|\\\\.|)+\\])*)", "g"), ((((...args) => {
                        if (args[2] === undefined || args[2].length === 0) {
                            return args[1];
                        }
                        let regexp = args[args.length - 1];
                        let startIndexOfMatched = javaemul.internal.IntegerHelper.parseInt((args[args.length - 2]));
                        let endIndexOfMatched = startIndexOfMatched + args[0].length;
                        let hasOpenBracket = (startIndexOfMatched > 0 && ((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })("(", (regexp.charAt(startIndexOfMatched - 1)))) || (startIndexOfMatched > 2 && ((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })("(?:", (regexp.substr(startIndexOfMatched - 3, 3))));
                        let hasCloseBracket = regexp.length > endIndexOfMatched && ((o1, o2) => { if (o1 && o1.equals) {
                            return o1.equals(o2);
                        }
                        else {
                            return o1 === o2;
                        } })(")", (regexp.charAt(endIndexOfMatched)));
                        if (hasOpenBracket && hasCloseBracket) {
                            return args[1] + args[2];
                        }
                        return args[1] + "(?:" + args[2] + ")";
                    }))));
                    try {
                        return new Pattern(new RegExp(regexpString, jsFlags), flags, namedGroupsNames);
                    }
                    catch (e) {
                        throw new java.util.regex.PatternSyntaxException(e, regexpString);
                    }
                    ;
                }
                static compile(regexpString, flags) {
                    if (((typeof regexpString === 'string') || regexpString === null) && ((typeof flags === 'number') || flags === null)) {
                        return java.util.regex.Pattern.compile$java_lang_String$int(regexpString, flags);
                    }
                    else if (((typeof regexpString === 'string') || regexpString === null) && flags === undefined) {
                        return java.util.regex.Pattern.compile$java_lang_String(regexpString);
                    }
                    else
                        throw new Error('invalid overload');
                }
                flags() {
                    return this._flags;
                }
                matcher(sequence) {
                    return new java.util.regex.Matcher(this, sequence.toString());
                }
                static matches(regex, input) {
                    return Pattern.compile$java_lang_String(regex).matcher(input).matches();
                }
                pattern() {
                    return this.regexp.source;
                }
                static quote(s) {
                    return JSON.stringify(s);
                }
                split(input, limit = 0) {
                    return ((input.toString()).split(this.regexp, limit).toArray());
                }
                splitAsStream(input) {
                    return java.util.Arrays.stream(this.split(input));
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    return this.pattern();
                }
            }
            Pattern.CASE_INSENSITIVE = 2;
            Pattern.MULTILINE = 8;
            Pattern.UNICODE_CASE = 64;
            Pattern.UNICODE_CHARACTER_CLASS = 256;
            regex_1.Pattern = Pattern;
            Pattern["__class"] = "java.util.regex.Pattern";
            Pattern["__interfaces"] = ["java.io.Serializable"];
            (function (Pattern) {
                class GroupNameRemover {
                    constructor(namedGroupsNames) {
                        this.count = 0;
                        this.inBrackets = false;
                        if (this.namedGroupsNames === undefined)
                            this.namedGroupsNames = null;
                        this.namedGroupsNames = namedGroupsNames;
                    }
                    /**
                     *
                     * @param {Array} args
                     * @return {string}
                     */
                    apply(args) {
                        if (this.inBrackets || args[2] !== undefined) {
                            this.inBrackets = args[2] === undefined || args[2].length === 1;
                            return args[0];
                        }
                        if (args[1] !== undefined) {
                            this.inBrackets = args[1].length === 0;
                            return args[0];
                        }
                        if (args[3] !== undefined && args[3].length !== 0) {
                            return args[0];
                        }
                        if (args[4] === undefined) {
                            this.count += 1;
                        }
                        if (args[5] !== undefined) {
                            this.namedGroupsNames.put((args[5]), this.count);
                            args[0] = args[0].replace(new RegExp("\\?<[^>]+>"), "");
                        }
                        return args[0];
                    }
                }
                Pattern.GroupNameRemover = GroupNameRemover;
                GroupNameRemover["__class"] = "java.util.regex.Pattern.GroupNameRemover";
                GroupNameRemover["__interfaces"] = ["java.util.function.Function"];
            })(Pattern = regex_1.Pattern || (regex_1.Pattern = {}));
        })(regex = util.regex || (util.regex = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        var stream;
        (function (stream) {
            var Collector;
            (function (Collector) {
                var Characteristics;
                (function (Characteristics) {
                })(Characteristics = Collector.Characteristics || (Collector.Characteristics = {}));
            })(Collector = stream.Collector || (stream.Collector = {}));
        })(stream = util.stream || (util.stream = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        var stream;
        (function (stream) {
            class Collectors {
                static throwingMerger() {
                    return (u, v) => {
                        throw new java.lang.IllegalStateException(javaemul.internal.StringHelper.format("Duplicate key %s", u));
                    };
                }
                static toList() {
                    return (new Collectors.CollectorImpl(() => new java.util.ArrayList(), (l, i) => l.add(i), (left, right) => {
                        left.addAll$java_util_Collection(right);
                        return left;
                    }));
                }
                static toSet() {
                    return (new Collectors.CollectorImpl(() => new java.util.HashSet(), (s, i) => s.add(i), (left, right) => {
                        left.addAll(right);
                        return left;
                    }));
                }
                static toMap$java_util_function_Function$java_util_function_Function(keyMapper, valueMapper) {
                    return Collectors.toMap$java_util_function_Function$java_util_function_Function$java_util_function_BinaryOperator$java_util_function_Supplier((keyMapper), (valueMapper), (Collectors.throwingMerger()), () => { return new java.util.HashMap(); });
                }
                static toMap$java_util_function_Function$java_util_function_Function$java_util_function_BinaryOperator(keyMapper, valueMapper, mergeFunction) {
                    return Collectors.toMap$java_util_function_Function$java_util_function_Function$java_util_function_BinaryOperator$java_util_function_Supplier((keyMapper), (valueMapper), (mergeFunction), () => { return new java.util.HashMap(); });
                }
                static toMap$java_util_function_Function$java_util_function_Function$java_util_function_BinaryOperator$java_util_function_Supplier(keyMapper, valueMapper, mergeFunction, mapSupplier) {
                    let accumulator = (map, element) => map.merge((target => (typeof target === 'function') ? target(element) : target.apply(element))(keyMapper), (target => (typeof target === 'function') ? target(element) : target.apply(element))(valueMapper), (mergeFunction));
                    return (new Collectors.CollectorImpl((mapSupplier), (accumulator), (Collectors.mapMerger((mergeFunction)))));
                }
                static toMap(keyMapper, valueMapper, mergeFunction, mapSupplier) {
                    if (((typeof keyMapper === 'function' && keyMapper.length == 1) || keyMapper === null) && ((typeof valueMapper === 'function' && valueMapper.length == 1) || valueMapper === null) && ((typeof mergeFunction === 'function' && mergeFunction.length == 2) || mergeFunction === null) && ((typeof mapSupplier === 'function' && mapSupplier.length == 0) || mapSupplier === null)) {
                        return java.util.stream.Collectors.toMap$java_util_function_Function$java_util_function_Function$java_util_function_BinaryOperator$java_util_function_Supplier(keyMapper, valueMapper, mergeFunction, mapSupplier);
                    }
                    else if (((typeof keyMapper === 'function' && keyMapper.length == 1) || keyMapper === null) && ((typeof valueMapper === 'function' && valueMapper.length == 1) || valueMapper === null) && ((typeof mergeFunction === 'function' && mergeFunction.length == 2) || mergeFunction === null) && mapSupplier === undefined) {
                        return java.util.stream.Collectors.toMap$java_util_function_Function$java_util_function_Function$java_util_function_BinaryOperator(keyMapper, valueMapper, mergeFunction);
                    }
                    else if (((typeof keyMapper === 'function' && keyMapper.length == 1) || keyMapper === null) && ((typeof valueMapper === 'function' && valueMapper.length == 1) || valueMapper === null) && mergeFunction === undefined && mapSupplier === undefined) {
                        return java.util.stream.Collectors.toMap$java_util_function_Function$java_util_function_Function(keyMapper, valueMapper);
                    }
                    else
                        throw new Error('invalid overload');
                }
                static mapMerger(mergeFunction) {
                    return (m1, m2) => {
                        for (let index128 = m2.entrySet().iterator(); index128.hasNext();) {
                            let e = index128.next();
                            m1.merge(e.getKey(), e.getValue(), (mergeFunction));
                        }
                        return m1;
                    };
                }
            }
            stream.Collectors = Collectors;
            Collectors["__class"] = "java.util.stream.Collectors";
            (function (Collectors) {
                class CollectorImpl {
                    constructor(supplier, accumulator, combiner) {
                        if (this.__supplier === undefined)
                            this.__supplier = null;
                        if (this.__accumulator === undefined)
                            this.__accumulator = null;
                        if (this.__combiner === undefined)
                            this.__combiner = null;
                        this.__supplier = (supplier);
                        this.__accumulator = (accumulator);
                        this.__combiner = (combiner);
                    }
                    /**
                     *
                     * @return {*}
                     */
                    accumulator() {
                        return (this.__accumulator);
                    }
                    /**
                     *
                     * @return {*}
                     */
                    supplier() {
                        return (this.__supplier);
                    }
                    combiner() {
                        throw new java.lang.IllegalStateException();
                    }
                    finisher() {
                        throw new java.lang.IllegalStateException();
                    }
                    characteristics() {
                        throw new java.lang.IllegalStateException();
                    }
                }
                Collectors.CollectorImpl = CollectorImpl;
                CollectorImpl["__class"] = "java.util.stream.Collectors.CollectorImpl";
                CollectorImpl["__interfaces"] = ["java.util.stream.Collector"];
            })(Collectors = stream.Collectors || (stream.Collectors = {}));
        })(stream = util.stream || (util.stream = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        var stream;
        (function (stream) {
            var IntStream;
            (function (IntStream) {
                function range(startInclusive, endExclusive) {
                    if (startInclusive >= endExclusive) {
                        return java.util.Collections.emptyList().stream();
                    }
                    else {
                        let result = (new java.util.ArrayList());
                        for (; startInclusive < endExclusive; ++startInclusive) {
                            {
                                result.add(startInclusive);
                            }
                            ;
                        }
                        return result.stream();
                    }
                }
                IntStream.range = range;
            })(IntStream = stream.IntStream || (stream.IntStream = {}));
        })(stream = util.stream || (util.stream = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        var stream;
        (function (stream) {
            var Stream;
            (function (Stream) {
                function of(...values) {
                    return java.util.Arrays.asList.apply(null, values).stream();
                }
                Stream.of = of;
            })(Stream = stream.Stream || (stream.Stream = {}));
        })(stream = util.stream || (util.stream = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        /**
         * See <a href="https://docs.oracle.com/javase/8/docs/api/java/util/StringJoiner.html">
         * the official Java API doc</a> for details.
         * @param {*} delimiter
         * @param {*} prefix
         * @param {*} suffix
         * @class
         */
        class StringJoiner {
            constructor(delimiter, prefix, suffix) {
                if (((delimiter != null && (delimiter["__interfaces"] != null && delimiter["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || delimiter.constructor != null && delimiter.constructor["__interfaces"] != null && delimiter.constructor["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || typeof delimiter === "string")) || delimiter === null) && ((prefix != null && (prefix["__interfaces"] != null && prefix["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || prefix.constructor != null && prefix.constructor["__interfaces"] != null && prefix.constructor["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || typeof prefix === "string")) || prefix === null) && ((suffix != null && (suffix["__interfaces"] != null && suffix["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || suffix.constructor != null && suffix.constructor["__interfaces"] != null && suffix.constructor["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || typeof suffix === "string")) || suffix === null)) {
                    let __args = arguments;
                    if (this.delimiter === undefined)
                        this.delimiter = null;
                    if (this.prefix === undefined)
                        this.prefix = null;
                    if (this.suffix === undefined)
                        this.suffix = null;
                    if (this.builder === undefined)
                        this.builder = null;
                    if (this.emptyValue === undefined)
                        this.emptyValue = null;
                    if (this.delimiter === undefined)
                        this.delimiter = null;
                    if (this.prefix === undefined)
                        this.prefix = null;
                    if (this.suffix === undefined)
                        this.suffix = null;
                    if (this.builder === undefined)
                        this.builder = null;
                    if (this.emptyValue === undefined)
                        this.emptyValue = null;
                    (() => {
                        javaemul.internal.InternalPreconditions.checkNotNull(delimiter, "delimiter");
                        javaemul.internal.InternalPreconditions.checkNotNull(prefix, "prefix");
                        javaemul.internal.InternalPreconditions.checkNotNull(suffix, "suffix");
                        this.delimiter = delimiter.toString();
                        this.prefix = prefix.toString();
                        this.suffix = suffix.toString();
                        this.emptyValue = this.prefix + this.suffix;
                    })();
                }
                else if (((delimiter != null && (delimiter["__interfaces"] != null && delimiter["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || delimiter.constructor != null && delimiter.constructor["__interfaces"] != null && delimiter.constructor["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || typeof delimiter === "string")) || delimiter === null) && prefix === undefined && suffix === undefined) {
                    let __args = arguments;
                    {
                        let __args = arguments;
                        let prefix = "";
                        let suffix = "";
                        if (this.delimiter === undefined)
                            this.delimiter = null;
                        if (this.prefix === undefined)
                            this.prefix = null;
                        if (this.suffix === undefined)
                            this.suffix = null;
                        if (this.builder === undefined)
                            this.builder = null;
                        if (this.emptyValue === undefined)
                            this.emptyValue = null;
                        if (this.delimiter === undefined)
                            this.delimiter = null;
                        if (this.prefix === undefined)
                            this.prefix = null;
                        if (this.suffix === undefined)
                            this.suffix = null;
                        if (this.builder === undefined)
                            this.builder = null;
                        if (this.emptyValue === undefined)
                            this.emptyValue = null;
                        (() => {
                            javaemul.internal.InternalPreconditions.checkNotNull(delimiter, "delimiter");
                            javaemul.internal.InternalPreconditions.checkNotNull(prefix, "prefix");
                            javaemul.internal.InternalPreconditions.checkNotNull(suffix, "suffix");
                            this.delimiter = delimiter.toString();
                            this.prefix = prefix.toString();
                            this.suffix = suffix.toString();
                            this.emptyValue = this.prefix + this.suffix;
                        })();
                    }
                }
                else
                    throw new Error('invalid overload');
            }
            add(newElement) {
                this.initBuilderOrAddDelimiter();
                this.builder.append$java_lang_CharSequence(newElement);
                return this;
            }
            length() {
                if (this.builder == null) {
                    return this.emptyValue.length;
                }
                return this.builder.length() + this.suffix.length;
            }
            merge(other) {
                if (other.builder != null) {
                    let otherLength = other.builder.length();
                    this.initBuilderOrAddDelimiter();
                    this.builder.append$java_lang_CharSequence$int$int(other.builder, other.prefix.length, otherLength);
                }
                return this;
            }
            setEmptyValue(emptyValue) {
                javaemul.internal.InternalPreconditions.checkNotNull(emptyValue);
                this.emptyValue = emptyValue.toString();
                return this;
            }
            /**
             *
             * @return {string}
             */
            toString() {
                if (this.builder == null) {
                    return this.emptyValue;
                }
                else if ((this.suffix.length === 0)) {
                    return this.builder.toString();
                }
                else {
                    return this.builder.toString() + this.suffix;
                }
            }
            /*private*/ initBuilderOrAddDelimiter() {
                if (this.builder == null) {
                    this.builder = new java.lang.StringBuilder(this.prefix);
                }
                else {
                    this.builder.append$java_lang_String(this.delimiter);
                }
            }
        }
        util.StringJoiner = StringJoiner;
        StringJoiner["__class"] = "java.util.StringJoiner";
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        class TimerTask {
            constructor() {
                this.state = TimerTask.VIRGIN;
                this.period = 0;
                if (this.nextExecutionTime === undefined)
                    this.nextExecutionTime = 0;
                if (this.handle === undefined)
                    this.handle = 0;
            }
            cancel() {
                let success = this.state === TimerTask.SCHEDULED;
                this.state = TimerTask.CANCELLED;
                this.nextExecutionTime = 0;
                this.period = 0;
                return success;
            }
            scheduledExecutionTime() {
                return this.period < 0 ? this.nextExecutionTime + this.period : this.nextExecutionTime - this.period;
            }
        }
        TimerTask.VIRGIN = 0;
        TimerTask.SCHEDULED = 1;
        TimerTask.EXECUTED = 2;
        TimerTask.CANCELLED = 3;
        util.TimerTask = TimerTask;
        TimerTask["__class"] = "java.util.TimerTask";
        TimerTask["__interfaces"] = ["java.lang.Runnable"];
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
var javaemul;
(function (javaemul) {
    var internal;
    (function (internal) {
        /**
         * Provides utilities to perform operations on Arrays.
         * @class
         */
        class ArrayHelper {
            static clone(array, fromIndex, toIndex) {
                let result = ArrayHelper.unsafeClone(array, fromIndex, toIndex);
                return javaemul.internal.ArrayStamper.stampJavaTypeInfo(result, array);
            }
            /**
             * Unlike clone, this method returns a copy of the array that is not type
             * marked. This is only safe for temp arrays as returned array will not do
             * any type checks.
             * @param {*} array
             * @param {number} fromIndex
             * @param {number} toIndex
             * @return {Array}
             */
            static unsafeClone(array, fromIndex, toIndex) {
                return array.slice(fromIndex, toIndex);
            }
            static createFrom(array, length) {
                let result = ArrayHelper.createNativeArray(length);
                return javaemul.internal.ArrayStamper.stampJavaTypeInfo(result, array);
            }
            /*private*/ static createNativeArray(length) {
                return (new Array(length));
            }
            static getLength(array) {
                return (array.length | 0);
            }
            static setLength(array, length) {
                array.length = length;
            }
            static removeFrom(array, index, deleteCount) {
                array.splice(index, deleteCount);
            }
            static insertTo$java_lang_Object$int$java_lang_Object(array, index, value) {
                array.splice(index, 0, value);
            }
            static insertTo$java_lang_Object$int$java_lang_Object_A(array, index, values) {
                ArrayHelper.copy$java_lang_Object$int$java_lang_Object$int$int$boolean(values, 0, array, index, values.length, false);
            }
            static insertTo(array, index, values) {
                if (((array != null) || array === null) && ((typeof index === 'number') || index === null) && ((values != null && values instanceof Array && (values.length == 0 || values[0] == null || (values[0] != null))) || values === null)) {
                    return javaemul.internal.ArrayHelper.insertTo$java_lang_Object$int$java_lang_Object_A(array, index, values);
                }
                else if (((array != null) || array === null) && ((typeof index === 'number') || index === null) && ((values != null) || values === null)) {
                    return javaemul.internal.ArrayHelper.insertTo$java_lang_Object$int$java_lang_Object(array, index, values);
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             * This version of insertTo is specified only for arrays.
             * Same implementation (and arguments) as "public static void insertTo(Object array, int index, Object[] values)"
             * @param {*} array
             * @param {number} index
             * @param {Array} values
             */
            static insertValuesToArray(array, index, values) {
                ArrayHelper.copy$java_lang_Object$int$java_lang_Object$int$int$boolean(values, 0, array, index, values.length, false);
            }
            static copy$java_lang_Object$int$java_lang_Object$int$int(array, srcOfs, dest, destOfs, len) {
                ArrayHelper.copy$java_lang_Object$int$java_lang_Object$int$int$boolean(array, srcOfs, dest, destOfs, len, true);
            }
            static copy$java_lang_Object$int$java_lang_Object$int$int$boolean(src, srcOfs, dest, destOfs, len, overwrite) {
                if (src === dest) {
                    src = ArrayHelper.unsafeClone(src, srcOfs, srcOfs + len);
                    srcOfs = 0;
                }
                for (let batchStart = srcOfs, end = srcOfs + len; batchStart < end;) {
                    {
                        let batchEnd = Math.min(batchStart + ArrayHelper.ARRAY_PROCESS_BATCH_SIZE, end);
                        len = batchEnd - batchStart;
                        ArrayHelper.applySplice(dest, destOfs, overwrite ? len : 0, ArrayHelper.unsafeClone(src, batchStart, batchEnd));
                        batchStart = batchEnd;
                        destOfs += len;
                    }
                    ;
                }
            }
            static copy(src, srcOfs, dest, destOfs, len, overwrite) {
                if (((src != null) || src === null) && ((typeof srcOfs === 'number') || srcOfs === null) && ((dest != null) || dest === null) && ((typeof destOfs === 'number') || destOfs === null) && ((typeof len === 'number') || len === null) && ((typeof overwrite === 'boolean') || overwrite === null)) {
                    return javaemul.internal.ArrayHelper.copy$java_lang_Object$int$java_lang_Object$int$int$boolean(src, srcOfs, dest, destOfs, len, overwrite);
                }
                else if (((src != null) || src === null) && ((typeof srcOfs === 'number') || srcOfs === null) && ((dest != null) || dest === null) && ((typeof destOfs === 'number') || destOfs === null) && ((typeof len === 'number') || len === null) && overwrite === undefined) {
                    return javaemul.internal.ArrayHelper.copy$java_lang_Object$int$java_lang_Object$int$int(src, srcOfs, dest, destOfs, len);
                }
                else
                    throw new Error('invalid overload');
            }
            /*private*/ static applySplice(arrayObject, index, deleteCount, arrayToAdd) {
                Array.prototype.splice.apply(arrayObject, [index, deleteCount].concat(arrayToAdd));
            }
        }
        ArrayHelper.ARRAY_PROCESS_BATCH_SIZE = 10000;
        internal.ArrayHelper = ArrayHelper;
        ArrayHelper["__class"] = "javaemul.internal.ArrayHelper";
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
(function (javaemul) {
    var internal;
    (function (internal) {
        /**
         * A utility to provide array stamping. Provided as a separate class to simplify
         * super-source.
         * @class
         */
        class ArrayStamper {
            static stampJavaTypeInfo(array, referenceType) {
                return (array);
            }
        }
        internal.ArrayStamper = ArrayStamper;
        ArrayStamper["__class"] = "javaemul.internal.ArrayStamper";
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
(function (javaemul) {
    var internal;
    (function (internal) {
        /**
         * Wraps native <code>boolean</code> as an object.
         * @param {boolean} value
         * @class
         */
        class BooleanHelper {
            constructor() {
            }
            static TYPE_$LI$() { if (BooleanHelper.TYPE == null)
                BooleanHelper.TYPE = Boolean; return BooleanHelper.TYPE; }
            ;
            static compare(x, y) {
                return (x === y) ? 0 : (x ? 1 : -1);
            }
            static hashCode(value) {
                return value ? 1231 : 1237;
            }
            static logicalAnd(a, b) {
                return a && b;
            }
            static logicalOr(a, b) {
                return a || b;
            }
            static logicalXor(a, b) {
                return (a) !== (b);
            }
            static parseBoolean(s) {
                return ((o1, o2) => o1.toUpperCase() === (o2 === null ? o2 : o2.toUpperCase()))("true", s);
            }
            static toString(x) {
                return new String(x).toString();
            }
            static valueOf$boolean(b) {
                return b ? BooleanHelper.TRUE : BooleanHelper.FALSE;
            }
            static valueOf$java_lang_String(s) {
                return BooleanHelper.valueOf$boolean(BooleanHelper.parseBoolean(s));
            }
            static valueOf(s) {
                if (((typeof s === 'string') || s === null)) {
                    return javaemul.internal.BooleanHelper.valueOf$java_lang_String(s);
                }
                else if (((typeof s === 'boolean') || s === null)) {
                    return javaemul.internal.BooleanHelper.valueOf$boolean(s);
                }
                else
                    throw new Error('invalid overload');
            }
            booleanValue() {
                return BooleanHelper.unsafeCast((javaemul.internal.InternalPreconditions.checkNotNull(this)));
            }
            /*private*/ static unsafeCast(value) {
                return value;
            }
            compareTo$javaemul_internal_BooleanHelper(b) {
                return BooleanHelper.compare(this.booleanValue(), b.booleanValue());
            }
            /**
             *
             * @param {javaemul.internal.BooleanHelper} b
             * @return {number}
             */
            compareTo(b) {
                if (((b != null && b instanceof javaemul.internal.BooleanHelper) || b === null)) {
                    return this.compareTo$javaemul_internal_BooleanHelper(b);
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             *
             * @param {*} o
             * @return {boolean}
             */
            equals(o) {
                return javaemul.internal.InternalPreconditions.checkNotNull(this) === o;
            }
            /**
             *
             * @return {number}
             */
            hashCode() {
                return BooleanHelper.hashCode(this.booleanValue());
            }
            /**
             *
             * @return {string}
             */
            toString() {
                return BooleanHelper.toString(this.booleanValue());
            }
        }
        BooleanHelper.FALSE = false;
        BooleanHelper.TRUE = true;
        internal.BooleanHelper = BooleanHelper;
        BooleanHelper["__class"] = "javaemul.internal.BooleanHelper";
        BooleanHelper["__interfaces"] = ["java.lang.Comparable", "java.io.Serializable"];
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
(function (javaemul) {
    var internal;
    (function (internal) {
        /**
         * Wraps a native <code>char</code> as an object.
         *
         * TODO(jat): many of the classification methods implemented here are not
         * correct in that they only handle ASCII characters, and many other methods are
         * not currently implemented. I think the proper approach is to introduce * a
         * deferred binding parameter which substitutes an implementation using a
         * fully-correct Unicode character database, at the expense of additional data
         * being downloaded. That way developers that need the functionality can get it
         * without those who don't need it paying for it.
         *
         * <pre>
         * The following methods are still not implemented -- most would require Unicode
         * character db to be useful:
         * - digit / is* / to*(int codePoint)
         * - isDefined(char)
         * - isIdentifierIgnorable(char)
         * - isJavaIdentifierPart(char)
         * - isJavaIdentifierStart(char)
         * - isJavaLetter(char) -- deprecated, so probably not
         * - isJavaLetterOrDigit(char) -- deprecated, so probably not
         * - isISOControl(char)
         * - isMirrored(char)
         * - isSpaceChar(char)
         * - isTitleCase(char)
         * - isUnicodeIdentifierPart(char)
         * - isUnicodeIdentifierStart(char)
         * - getDirectionality(*)
         * - getNumericValue(*)
         * - getType(*)
         * - reverseBytes(char) -- any use for this at all in the browser?
         * - toTitleCase(*)
         * - all the category constants for classification
         *
         * The following do not properly handle characters outside of ASCII:
         * - digit(char c, int radix)
         * - isDigit(char c)
         * - isLetter(char c)
         * - isLetterOrDigit(char c)
         * - isLowerCase(char c)
         * - isUpperCase(char c)
         * </pre>
         * @param {string} value
         * @class
         */
        class CharacterHelper {
            constructor(value) {
                if (this.value === undefined)
                    this.value = null;
                this.value = value;
            }
            static TYPE_$LI$() { if (CharacterHelper.TYPE == null)
                CharacterHelper.TYPE = String; return CharacterHelper.TYPE; }
            ;
            static charCount(codePoint) {
                return codePoint >= CharacterHelper.MIN_SUPPLEMENTARY_CODE_POINT ? 2 : 1;
            }
            static codePointAt$char_A$int(a, index) {
                return CharacterHelper.codePointAt$java_lang_CharSequence$int$int(new String(a), index, a.length);
            }
            static codePointAt$char_A$int$int(a, index, limit) {
                return CharacterHelper.codePointAt$java_lang_CharSequence$int$int(new String(a), index, limit);
            }
            static codePointAt(a, index, limit) {
                if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (typeof a[0] === 'string'))) || a === null) && ((typeof index === 'number') || index === null) && ((typeof limit === 'number') || limit === null)) {
                    return javaemul.internal.CharacterHelper.codePointAt$char_A$int$int(a, index, limit);
                }
                else if (((a != null && (a["__interfaces"] != null && a["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || a.constructor != null && a.constructor["__interfaces"] != null && a.constructor["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || typeof a === "string")) || a === null) && ((typeof index === 'number') || index === null) && ((typeof limit === 'number') || limit === null)) {
                    return javaemul.internal.CharacterHelper.codePointAt$java_lang_CharSequence$int$int(a, index, limit);
                }
                else if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (typeof a[0] === 'string'))) || a === null) && ((typeof index === 'number') || index === null) && limit === undefined) {
                    return javaemul.internal.CharacterHelper.codePointAt$char_A$int(a, index);
                }
                else if (((a != null && (a["__interfaces"] != null && a["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || a.constructor != null && a.constructor["__interfaces"] != null && a.constructor["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || typeof a === "string")) || a === null) && ((typeof index === 'number') || index === null) && limit === undefined) {
                    return javaemul.internal.CharacterHelper.codePointAt$java_lang_CharSequence$int(a, index);
                }
                else
                    throw new Error('invalid overload');
            }
            static codePointAt$java_lang_CharSequence$int(seq, index) {
                return CharacterHelper.codePointAt$java_lang_CharSequence$int$int(seq, index, seq.length);
            }
            static codePointBefore$char_A$int(a, index) {
                return CharacterHelper.codePointBefore$java_lang_CharSequence$int$int(new String(a), index, 0);
            }
            static codePointBefore$char_A$int$int(a, index, start) {
                return CharacterHelper.codePointBefore$java_lang_CharSequence$int$int(new String(a), index, start);
            }
            static codePointBefore(a, index, start) {
                if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (typeof a[0] === 'string'))) || a === null) && ((typeof index === 'number') || index === null) && ((typeof start === 'number') || start === null)) {
                    return javaemul.internal.CharacterHelper.codePointBefore$char_A$int$int(a, index, start);
                }
                else if (((a != null && (a["__interfaces"] != null && a["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || a.constructor != null && a.constructor["__interfaces"] != null && a.constructor["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || typeof a === "string")) || a === null) && ((typeof index === 'number') || index === null) && ((typeof start === 'number') || start === null)) {
                    return javaemul.internal.CharacterHelper.codePointBefore$java_lang_CharSequence$int$int(a, index, start);
                }
                else if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (typeof a[0] === 'string'))) || a === null) && ((typeof index === 'number') || index === null) && start === undefined) {
                    return javaemul.internal.CharacterHelper.codePointBefore$char_A$int(a, index);
                }
                else if (((a != null && (a["__interfaces"] != null && a["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || a.constructor != null && a.constructor["__interfaces"] != null && a.constructor["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || typeof a === "string")) || a === null) && ((typeof index === 'number') || index === null) && start === undefined) {
                    return javaemul.internal.CharacterHelper.codePointBefore$java_lang_CharSequence$int(a, index);
                }
                else
                    throw new Error('invalid overload');
            }
            static codePointBefore$java_lang_CharSequence$int(cs, index) {
                return CharacterHelper.codePointBefore$java_lang_CharSequence$int$int(cs, index, 0);
            }
            static codePointCount$char_A$int$int(a, offset, count) {
                return CharacterHelper.codePointCount$java_lang_CharSequence$int$int(new String(a), offset, offset + count);
            }
            static codePointCount(a, offset, count) {
                if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (typeof a[0] === 'string'))) || a === null) && ((typeof offset === 'number') || offset === null) && ((typeof count === 'number') || count === null)) {
                    return javaemul.internal.CharacterHelper.codePointCount$char_A$int$int(a, offset, count);
                }
                else if (((a != null && (a["__interfaces"] != null && a["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || a.constructor != null && a.constructor["__interfaces"] != null && a.constructor["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || typeof a === "string")) || a === null) && ((typeof offset === 'number') || offset === null) && ((typeof count === 'number') || count === null)) {
                    return javaemul.internal.CharacterHelper.codePointCount$java_lang_CharSequence$int$int(a, offset, count);
                }
                else
                    throw new Error('invalid overload');
            }
            static codePointCount$java_lang_CharSequence$int$int(seq, beginIndex, endIndex) {
                let count = 0;
                for (let idx = beginIndex; idx < endIndex;) {
                    {
                        let ch = seq.charAt(idx++);
                        if (CharacterHelper.isHighSurrogate(ch) && idx < endIndex && (CharacterHelper.isLowSurrogate(seq.charAt(idx)))) {
                            ++idx;
                        }
                        ++count;
                    }
                    ;
                }
                return count;
            }
            static compare(x, y) {
                return (c => c.charCodeAt == null ? c : c.charCodeAt(0))(x) - (c => c.charCodeAt == null ? c : c.charCodeAt(0))(y);
            }
            static digit(c, radix) {
                if (radix < CharacterHelper.MIN_RADIX || radix > CharacterHelper.MAX_RADIX) {
                    return -1;
                }
                if ((c => c.charCodeAt == null ? c : c.charCodeAt(0))(c) >= '0'.charCodeAt(0) && (c => c.charCodeAt == null ? c : c.charCodeAt(0))(c) < '0'.charCodeAt(0) + Math.min(radix, 10)) {
                    return (c => c.charCodeAt == null ? c : c.charCodeAt(0))(c) - '0'.charCodeAt(0);
                }
                if ((c => c.charCodeAt == null ? c : c.charCodeAt(0))(c) >= 'a'.charCodeAt(0) && (c => c.charCodeAt == null ? c : c.charCodeAt(0))(c) < (radix + 'a'.charCodeAt(0) - 10)) {
                    return (c => c.charCodeAt == null ? c : c.charCodeAt(0))(c) - 'a'.charCodeAt(0) + 10;
                }
                if ((c => c.charCodeAt == null ? c : c.charCodeAt(0))(c) >= 'A'.charCodeAt(0) && (c => c.charCodeAt == null ? c : c.charCodeAt(0))(c) < (radix + 'A'.charCodeAt(0) - 10)) {
                    return (c => c.charCodeAt == null ? c : c.charCodeAt(0))(c) - 'A'.charCodeAt(0) + 10;
                }
                return -1;
            }
            static getNumericValue(ch) {
                return ((ch).charCodeAt(0) | 0);
            }
            static forDigit$int$int(digit, radix) {
                if (radix < CharacterHelper.MIN_RADIX || radix > CharacterHelper.MAX_RADIX) {
                    return String.fromCharCode(0);
                }
                if (digit < 0 || digit >= radix) {
                    return String.fromCharCode(0);
                }
                return CharacterHelper.forDigit$int(digit);
            }
            static forDigit(digit, radix) {
                if (((typeof digit === 'number') || digit === null) && ((typeof radix === 'number') || radix === null)) {
                    return javaemul.internal.CharacterHelper.forDigit$int$int(digit, radix);
                }
                else if (((typeof digit === 'number') || digit === null) && radix === undefined) {
                    return javaemul.internal.CharacterHelper.forDigit$int(digit);
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             * @skip
             *
             * public for shared implementation with Arrays.hashCode
             * @param {string} c
             * @return {number}
             */
            static hashCode(c) {
                return (c).charCodeAt(0);
            }
            static isDigit(c) {
                let result = (new String(c).toString()).match(CharacterHelper.digitRegex());
                return result != null && result.length > 0;
            }
            static digitRegex() {
                return new RegExp("\\d");
            }
            static isHighSurrogate(ch) {
                return (c => c.charCodeAt == null ? c : c.charCodeAt(0))(ch) >= (c => c.charCodeAt == null ? c : c.charCodeAt(0))(CharacterHelper.MIN_HIGH_SURROGATE) && (c => c.charCodeAt == null ? c : c.charCodeAt(0))(ch) <= (c => c.charCodeAt == null ? c : c.charCodeAt(0))(CharacterHelper.MAX_HIGH_SURROGATE);
            }
            static isLetter(c) {
                return (new String(c).toString()).match(CharacterHelper.leterRegex()).length > 0;
            }
            static leterRegex() {
                return new RegExp("[A-Z]", "i");
            }
            static isLetterOrDigit(c) {
                return (new String(c).toString()).match(CharacterHelper.leterOrDigitRegex()).length > 0;
            }
            static leterOrDigitRegex() {
                return new RegExp("[A-Z\\d]", "i");
            }
            static isLowerCase(c) {
                return (c => c.charCodeAt == null ? c : c.charCodeAt(0))(CharacterHelper.toLowerCase$char(c)) == (c => c.charCodeAt == null ? c : c.charCodeAt(0))(c) && CharacterHelper.isLetter(c);
            }
            static isLowSurrogate(ch) {
                return (c => c.charCodeAt == null ? c : c.charCodeAt(0))(ch) >= (c => c.charCodeAt == null ? c : c.charCodeAt(0))(CharacterHelper.MIN_LOW_SURROGATE) && (c => c.charCodeAt == null ? c : c.charCodeAt(0))(ch) <= (c => c.charCodeAt == null ? c : c.charCodeAt(0))(CharacterHelper.MAX_LOW_SURROGATE);
            }
            /**
             * Deprecated - see isWhitespace(char).
             * @param {string} c
             * @return {boolean}
             */
            static isSpace(c) {
                switch ((c).charCodeAt(0)) {
                    case 32 /* ' ' */:
                        return true;
                    case 10 /* '\n' */:
                        return true;
                    case 9 /* '\t' */:
                        return true;
                    case 12 /* '\f' */:
                        return true;
                    case 13 /* '\r' */:
                        return true;
                    default:
                        return false;
                }
            }
            static isWhitespace$char(ch) {
                return (new String(ch).toString()).match(CharacterHelper.whitespaceRegex()).length > 0;
            }
            static isWhitespace(ch) {
                if (((typeof ch === 'string') || ch === null)) {
                    return javaemul.internal.CharacterHelper.isWhitespace$char(ch);
                }
                else if (((typeof ch === 'number') || ch === null)) {
                    return javaemul.internal.CharacterHelper.isWhitespace$int(ch);
                }
                else
                    throw new Error('invalid overload');
            }
            static isWhitespace$int(codePoint) {
                return String.fromCharCode(codePoint).match(CharacterHelper.whitespaceRegex()).length > 0;
            }
            static whitespaceRegex() {
                return new RegExp("[\\t-\\r \\u1680\\u180E\\u2000-\\u2006\\u2008-\\u200A\\u2028\\u2029\\u205F\\u3000\\uFEFF]|[\\x1C-\\x1F]");
            }
            static isSupplementaryCodePoint(codePoint) {
                return codePoint >= CharacterHelper.MIN_SUPPLEMENTARY_CODE_POINT && codePoint <= CharacterHelper.MAX_CODE_POINT;
            }
            static isSurrogatePair(highSurrogate, lowSurrogate) {
                return CharacterHelper.isHighSurrogate(highSurrogate) && CharacterHelper.isLowSurrogate(lowSurrogate);
            }
            static isUpperCase(c) {
                return (c => c.charCodeAt == null ? c : c.charCodeAt(0))(CharacterHelper.toUpperCase$char(c)) == (c => c.charCodeAt == null ? c : c.charCodeAt(0))(c) && CharacterHelper.isLetter(c);
            }
            static isValidCodePoint(codePoint) {
                return codePoint >= CharacterHelper.MIN_CODE_POINT && codePoint <= CharacterHelper.MAX_CODE_POINT;
            }
            static offsetByCodePoints$char_A$int$int$int$int(a, start, count, index, codePointOffset) {
                return CharacterHelper.offsetByCodePoints$java_lang_CharSequence$int$int(((str, index, len) => str.substring(index, index + len))((a).join(''), start, count), index, codePointOffset);
            }
            static offsetByCodePoints(a, start, count, index, codePointOffset) {
                if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (typeof a[0] === 'string'))) || a === null) && ((typeof start === 'number') || start === null) && ((typeof count === 'number') || count === null) && ((typeof index === 'number') || index === null) && ((typeof codePointOffset === 'number') || codePointOffset === null)) {
                    return javaemul.internal.CharacterHelper.offsetByCodePoints$char_A$int$int$int$int(a, start, count, index, codePointOffset);
                }
                else if (((a != null && (a["__interfaces"] != null && a["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || a.constructor != null && a.constructor["__interfaces"] != null && a.constructor["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || typeof a === "string")) || a === null) && ((typeof start === 'number') || start === null) && ((typeof count === 'number') || count === null) && index === undefined && codePointOffset === undefined) {
                    return javaemul.internal.CharacterHelper.offsetByCodePoints$java_lang_CharSequence$int$int(a, start, count);
                }
                else
                    throw new Error('invalid overload');
            }
            static offsetByCodePoints$java_lang_CharSequence$int$int(seq, index, codePointOffset) {
                if (codePointOffset < 0) {
                    while ((codePointOffset < 0)) {
                        {
                            --index;
                            if (CharacterHelper.isLowSurrogate(seq.charAt(index)) && CharacterHelper.isHighSurrogate(seq.charAt(index - 1))) {
                                --index;
                            }
                            ++codePointOffset;
                        }
                    }
                    ;
                }
                else {
                    while ((codePointOffset > 0)) {
                        {
                            if (CharacterHelper.isHighSurrogate(seq.charAt(index)) && CharacterHelper.isLowSurrogate(seq.charAt(index + 1))) {
                                ++index;
                            }
                            ++index;
                            --codePointOffset;
                        }
                    }
                    ;
                }
                return index;
            }
            static toChars$int(codePoint) {
                javaemul.internal.InternalPreconditions.checkCriticalArgument(codePoint >= 0 && codePoint <= CharacterHelper.MAX_CODE_POINT, "CodePoint %s not in range [%s, %s]", /* toString */ ('' + (codePoint)), "0", /* toString */ ('' + (CharacterHelper.MAX_CODE_POINT)));
                if (codePoint >= CharacterHelper.MIN_SUPPLEMENTARY_CODE_POINT) {
                    return [CharacterHelper.getHighSurrogate(codePoint), CharacterHelper.getLowSurrogate(codePoint)];
                }
                else {
                    return [String.fromCharCode(codePoint)];
                }
            }
            static toChars$int$char_A$int(codePoint, dst, dstIndex) {
                javaemul.internal.InternalPreconditions.checkCriticalArgument(codePoint >= 0 && codePoint <= CharacterHelper.MAX_CODE_POINT, "CodePoint %s not in range [%s, %s]", /* toString */ ('' + (codePoint)), "0", /* toString */ ('' + (CharacterHelper.MAX_CODE_POINT)));
                if (codePoint >= CharacterHelper.MIN_SUPPLEMENTARY_CODE_POINT) {
                    dst[dstIndex++] = CharacterHelper.getHighSurrogate(codePoint);
                    dst[dstIndex] = CharacterHelper.getLowSurrogate(codePoint);
                    return 2;
                }
                else {
                    dst[dstIndex] = String.fromCharCode(codePoint);
                    return 1;
                }
            }
            static toChars(codePoint, dst, dstIndex) {
                if (((typeof codePoint === 'number') || codePoint === null) && ((dst != null && dst instanceof Array && (dst.length == 0 || dst[0] == null || (typeof dst[0] === 'string'))) || dst === null) && ((typeof dstIndex === 'number') || dstIndex === null)) {
                    return javaemul.internal.CharacterHelper.toChars$int$char_A$int(codePoint, dst, dstIndex);
                }
                else if (((typeof codePoint === 'number') || codePoint === null) && dst === undefined && dstIndex === undefined) {
                    return javaemul.internal.CharacterHelper.toChars$int(codePoint);
                }
                else
                    throw new Error('invalid overload');
            }
            static toCodePoint(highSurrogate, lowSurrogate) {
                return CharacterHelper.MIN_SUPPLEMENTARY_CODE_POINT + (((c => c.charCodeAt == null ? c : c.charCodeAt(0))(highSurrogate) & 1023) << 10) + ((c => c.charCodeAt == null ? c : c.charCodeAt(0))(lowSurrogate) & 1023);
            }
            static toLowerCase$char(c) {
                return new String(c).toString().toLowerCase().charAt(0);
            }
            static toLowerCase(c) {
                if (((typeof c === 'string') || c === null)) {
                    return javaemul.internal.CharacterHelper.toLowerCase$char(c);
                }
                else if (((typeof c === 'number') || c === null)) {
                    return javaemul.internal.CharacterHelper.toLowerCase$int(c);
                }
                else
                    throw new Error('invalid overload');
            }
            static toLowerCase$int(c) {
                return (new String(String.fromCharCode(c)).toString().toLowerCase().charAt(0)).charCodeAt(0);
            }
            static toString(x) {
                return new String(x).toString();
            }
            static toUpperCase$char(c) {
                return new String(c).toString().toUpperCase().charAt(0);
            }
            static toUpperCase(c) {
                if (((typeof c === 'string') || c === null)) {
                    return javaemul.internal.CharacterHelper.toUpperCase$char(c);
                }
                else if (((typeof c === 'number') || c === null)) {
                    return javaemul.internal.CharacterHelper.toUpperCase$int(c);
                }
                else
                    throw new Error('invalid overload');
            }
            static toUpperCase$int(c) {
                return new String(String.fromCharCode(c)).toString().toUpperCase().charAt(0);
            }
            static valueOf(c) {
                if ((c => c.charCodeAt == null ? c : c.charCodeAt(0))(c) < 128) {
                    let result = CharacterHelper.BoxedValues.boxedValues_$LI$()[(c).charCodeAt(0)];
                    if ((c => c.charCodeAt == null ? c : c.charCodeAt(0))(result) == null) {
                        result = CharacterHelper.BoxedValues.boxedValues_$LI$()[(c).charCodeAt(0)] = new String(c);
                    }
                    return result;
                }
                return new String(c);
            }
            static codePointAt$java_lang_CharSequence$int$int(cs, index, limit) {
                let hiSurrogate = cs.charAt(index++);
                let loSurrogate;
                if (CharacterHelper.isHighSurrogate(hiSurrogate) && index < limit && CharacterHelper.isLowSurrogate(loSurrogate = cs.charAt(index))) {
                    return CharacterHelper.toCodePoint(hiSurrogate, loSurrogate);
                }
                return (hiSurrogate).charCodeAt(0);
            }
            static codePointBefore$java_lang_CharSequence$int$int(cs, index, start) {
                let loSurrogate = cs.charAt(--index);
                let highSurrogate;
                if (CharacterHelper.isLowSurrogate(loSurrogate) && index > start && CharacterHelper.isHighSurrogate(highSurrogate = cs.charAt(index - 1))) {
                    return CharacterHelper.toCodePoint(highSurrogate, loSurrogate);
                }
                return (loSurrogate).charCodeAt(0);
            }
            static forDigit$int(digit) {
                let overBaseTen = digit - 10;
                return String.fromCharCode((overBaseTen < 0 ? '0'.charCodeAt(0) + digit : 'a'.charCodeAt(0) + overBaseTen));
            }
            /**
             * Computes the high surrogate character of the UTF16 representation of a
             * non-BMP code point. See {@link getLowSurrogate}.
             *
             * @param {number} codePoint
             * requested codePoint, required to be >=
             * MIN_SUPPLEMENTARY_CODE_POINT
             * @return {string} high surrogate character
             */
            static getHighSurrogate(codePoint) {
                return String.fromCharCode(((c => c.charCodeAt == null ? c : c.charCodeAt(0))(CharacterHelper.MIN_HIGH_SURROGATE) + (((codePoint - CharacterHelper.MIN_SUPPLEMENTARY_CODE_POINT) >> 10) & 1023)));
            }
            /**
             * Computes the low surrogate character of the UTF16 representation of a
             * non-BMP code point. See {@link getHighSurrogate}.
             *
             * @param {number} codePoint
             * requested codePoint, required to be >=
             * MIN_SUPPLEMENTARY_CODE_POINT
             * @return {string} low surrogate character
             */
            static getLowSurrogate(codePoint) {
                return String.fromCharCode(((c => c.charCodeAt == null ? c : c.charCodeAt(0))(CharacterHelper.MIN_LOW_SURROGATE) + ((codePoint - CharacterHelper.MIN_SUPPLEMENTARY_CODE_POINT) & 1023)));
            }
            charValue() {
                return this.value;
            }
            compareTo$javaemul_internal_CharacterHelper(c) {
                return CharacterHelper.compare(this.value, c.value);
            }
            /**
             *
             * @param {javaemul.internal.CharacterHelper} c
             * @return {number}
             */
            compareTo(c) {
                if (((c != null && c instanceof javaemul.internal.CharacterHelper) || c === null)) {
                    return this.compareTo$javaemul_internal_CharacterHelper(c);
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             *
             * @param {*} o
             * @return {boolean}
             */
            equals(o) {
                return (o != null && o instanceof javaemul.internal.CharacterHelper) && ((c => c.charCodeAt == null ? c : c.charCodeAt(0))(o.value) == (c => c.charCodeAt == null ? c : c.charCodeAt(0))(this.value));
            }
            /**
             *
             * @return {number}
             */
            hashCode() {
                return CharacterHelper.hashCode(this.value);
            }
            /**
             *
             * @return {string}
             */
            toString() {
                return new String(this.value).toString();
            }
        }
        CharacterHelper.MIN_RADIX = 2;
        CharacterHelper.MAX_RADIX = 36;
        CharacterHelper.MIN_VALUE = '\u0000';
        CharacterHelper.MAX_VALUE = '\uffff';
        CharacterHelper.MIN_SURROGATE = '\ud800';
        CharacterHelper.MAX_SURROGATE = '\udfff';
        CharacterHelper.MIN_LOW_SURROGATE = '\udc00';
        CharacterHelper.MAX_LOW_SURROGATE = '\udfff';
        CharacterHelper.MIN_HIGH_SURROGATE = '\ud800';
        CharacterHelper.MAX_HIGH_SURROGATE = '\udbff';
        CharacterHelper.MIN_SUPPLEMENTARY_CODE_POINT = 65536;
        CharacterHelper.MIN_CODE_POINT = 0;
        CharacterHelper.MAX_CODE_POINT = 1114111;
        CharacterHelper.SIZE = 16;
        internal.CharacterHelper = CharacterHelper;
        CharacterHelper["__class"] = "javaemul.internal.CharacterHelper";
        CharacterHelper["__interfaces"] = ["java.lang.Comparable", "java.io.Serializable"];
        (function (CharacterHelper) {
            /**
             * Use nested class to avoid clinit on outer.
             * @class
             */
            class BoxedValues {
                constructor() {
                }
                static boxedValues_$LI$() { if (BoxedValues.boxedValues == null)
                    BoxedValues.boxedValues = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(128); return BoxedValues.boxedValues; }
                ;
            }
            CharacterHelper.BoxedValues = BoxedValues;
            BoxedValues["__class"] = "javaemul.internal.CharacterHelper.BoxedValues";
        })(CharacterHelper = internal.CharacterHelper || (internal.CharacterHelper = {}));
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
(function (javaemul) {
    var internal;
    (function (internal) {
        /**
         * Private implementation class for GWT. This API should not be
         * considered public or stable.
         * @class
         */
        class Coercions {
            constructor() {
            }
            /**
             * Coerce js int to 32 bits.
             * Trick related to JS and lack of integer rollover.
             * {@see com.google.gwt.lang.Cast#narrow_int}
             * @param {number} value
             * @return {number}
             */
            static ensureInt(value) {
                return value | 0;
            }
        }
        internal.Coercions = Coercions;
        Coercions["__class"] = "javaemul.internal.Coercions";
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
(function (javaemul) {
    var internal;
    (function (internal) {
        /**
         * Simple Helper class to return Date.now.
         * @class
         */
        class DateUtil {
            /**
             * Returns the numeric value corresponding to the current time - the number
             * of milliseconds elapsed since 1 January 1970 00:00:00 UTC.
             * @return {number}
             */
            static now() {
                if (Date.now) {
                    return Date.now();
                }
                ;
                return ((new Date()).getTime());
            }
        }
        internal.DateUtil = DateUtil;
        DateUtil["__class"] = "javaemul.internal.DateUtil";
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
(function (javaemul) {
    var internal;
    (function (internal) {
        /**
         * Contains logics for calculating hash codes in JavaScript.
         * @class
         */
        class HashCodes {
            static hashCodeForString(s) {
                return javaemul.internal.StringHashCache.getHashCode(s);
            }
            static getIdentityHashCode(o) {
                if (o == null) {
                    return 0;
                }
                return (typeof o === 'string') ? HashCodes.hashCodeForString(javaemul.internal.JsUtils.unsafeCastToString(o)) : HashCodes.getObjectIdentityHashCode(o);
            }
            static getObjectIdentityHashCode(o) {
                if ((o)[HashCodes.HASH_CODE_PROPERTY] != null) {
                    return ((o)[HashCodes.HASH_CODE_PROPERTY]);
                }
                else {
                    return ((o)[HashCodes.HASH_CODE_PROPERTY] = HashCodes.getNextHashId());
                }
            }
            /**
             * Called from JSNI. Do not change this implementation without updating:
             * <ul>
             * <li>{@link com.google.gwt.user.client.rpc.impl.SerializerBase}</li>
             * </ul>
             * @return {number}
             * @private
             */
            /*private*/ static getNextHashId() {
                return ++HashCodes.sNextHashId;
            }
        }
        HashCodes.sNextHashId = 0;
        HashCodes.HASH_CODE_PROPERTY = "$H";
        internal.HashCodes = HashCodes;
        HashCodes["__class"] = "javaemul.internal.HashCodes";
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
(function (javaemul) {
    var internal;
    (function (internal) {
        class JreHelper {
            static LOG10E_$LI$() { if (JreHelper.LOG10E == null)
                JreHelper.LOG10E = Math.LOG10E; return JreHelper.LOG10E; }
            ;
        }
        internal.JreHelper = JreHelper;
        JreHelper["__class"] = "javaemul.internal.JreHelper";
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
(function (javaemul) {
    var internal;
    (function (internal) {
        /**
         * Provides an interface for simple JavaScript idioms that can not be expressed in Java.
         * @class
         */
        class JsUtils {
            static getInfinity() {
                return Infinity;
            }
            static isUndefined(value) {
                return value == null;
            }
            static unsafeCastToString(string) {
                return string;
            }
            static setPropertySafe(map, key, value) {
                try {
                    (map)[key] = value;
                }
                catch (e) {
                }
                ;
            }
            static getIntProperty(map, key) {
                return ((map)[key]);
            }
            static setIntProperty(map, key, value) {
                (map)[key] = value;
            }
            static typeOf(o) {
                return typeof o;
            }
        }
        internal.JsUtils = JsUtils;
        JsUtils["__class"] = "javaemul.internal.JsUtils";
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
(function (javaemul) {
    var internal;
    (function (internal) {
        /**
         * A helper class for long comparison.
         * @class
         */
        class LongCompareHolder {
            static getLongComparator() {
                return (l1, l2) => l2 - l1;
            }
        }
        internal.LongCompareHolder = LongCompareHolder;
        LongCompareHolder["__class"] = "javaemul.internal.LongCompareHolder";
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
(function (javaemul) {
    var internal;
    (function (internal) {
        /**
         * Math utility methods and constants.
         * @class
         */
        class MathHelper {
            static EPSILON_$LI$() { if (MathHelper.EPSILON == null)
                MathHelper.EPSILON = MathHelper.pow(2, -52); return MathHelper.EPSILON; }
            ;
            static MAX_VALUE_$LI$() { if (MathHelper.MAX_VALUE == null)
                MathHelper.MAX_VALUE = (2 - MathHelper.EPSILON_$LI$()) * MathHelper.pow(2, 1023); return MathHelper.MAX_VALUE; }
            ;
            static MIN_VALUE_$LI$() { if (MathHelper.MIN_VALUE == null)
                MathHelper.MIN_VALUE = MathHelper.pow(2, -1022); return MathHelper.MIN_VALUE; }
            ;
            static nextDown(x) {
                return -MathHelper.nextUp(-x);
            }
            static ulp(x) {
                return x < 0 ? MathHelper.nextUp(x) - x : x - (-MathHelper.nextUp(-x));
            }
            static nextUp(x) {
                if (x !== x) {
                    return x;
                }
                if (x === (-1 / 0 | 0)) {
                    return -MathHelper.MAX_VALUE_$LI$();
                }
                if (x === (+1 / 0 | 0)) {
                    return (+1 / 0 | 0);
                }
                if (x === +MathHelper.MAX_VALUE_$LI$()) {
                    return (+1 / 0 | 0);
                }
                let y = x * (x < 0 ? 1 - MathHelper.EPSILON_$LI$() / 2 : 1 + MathHelper.EPSILON_$LI$());
                if (y === x) {
                    y = MathHelper.MIN_VALUE_$LI$() * MathHelper.EPSILON_$LI$() > 0 ? x + MathHelper.MIN_VALUE_$LI$() * MathHelper.EPSILON_$LI$() : x + MathHelper.MIN_VALUE_$LI$();
                }
                if (y === (+1 / 0 | 0)) {
                    y = +MathHelper.MAX_VALUE_$LI$();
                }
                let b = x + (y - x) / 2;
                if (x < b && b < y) {
                    y = b;
                }
                let c = (y + x) / 2;
                if (x < c && c < y) {
                    y = c;
                }
                return y === 0 ? -0 : y;
            }
            static PI_OVER_180_$LI$() { if (MathHelper.PI_OVER_180 == null)
                MathHelper.PI_OVER_180 = MathHelper.PI / 180.0; return MathHelper.PI_OVER_180; }
            ;
            static PI_UNDER_180_$LI$() { if (MathHelper.PI_UNDER_180 == null)
                MathHelper.PI_UNDER_180 = 180.0 / MathHelper.PI; return MathHelper.PI_UNDER_180; }
            ;
            static abs$double(x) {
                return x <= 0 ? 0.0 - x : x;
            }
            static abs$float(x) {
                return Math.fround(MathHelper.abs$double(x));
            }
            static abs$int(x) {
                return x < 0 ? -x : x;
            }
            static abs(x) {
                if (((typeof x === 'number') || x === null)) {
                    return javaemul.internal.MathHelper.abs$int(x);
                }
                else if (((typeof x === 'number') || x === null)) {
                    return javaemul.internal.MathHelper.abs$long(x);
                }
                else if (((typeof x === 'number') || x === null)) {
                    return javaemul.internal.MathHelper.abs$float(x);
                }
                else if (((typeof x === 'number') || x === null)) {
                    return javaemul.internal.MathHelper.abs$double(x);
                }
                else
                    throw new Error('invalid overload');
            }
            static abs$long(x) {
                return x < 0 ? -x : x;
            }
            static acos(x) {
                return Math.acos(x);
            }
            static asin(x) {
                return Math.asin(x);
            }
            static atan(x) {
                return Math.atan(x);
            }
            static atan2(y, x) {
                return Math.atan2(y, x);
            }
            static cbrt(x) {
                return MathHelper.pow(x, 1.0 / 3.0);
            }
            static ceil(x) {
                return Math.ceil(x);
            }
            static copySign$double$double(magnitude, sign) {
                if (sign < 0) {
                    return (magnitude < 0) ? magnitude : -magnitude;
                }
                else {
                    return (magnitude > 0) ? magnitude : -magnitude;
                }
            }
            static copySign$float$float(magnitude, sign) {
                return Math.fround((MathHelper.copySign$double$double(magnitude, sign)));
            }
            static copySign(magnitude, sign) {
                if (((typeof magnitude === 'number') || magnitude === null) && ((typeof sign === 'number') || sign === null)) {
                    return javaemul.internal.MathHelper.copySign$float$float(magnitude, sign);
                }
                else if (((typeof magnitude === 'number') || magnitude === null) && ((typeof sign === 'number') || sign === null)) {
                    return javaemul.internal.MathHelper.copySign$double$double(magnitude, sign);
                }
                else
                    throw new Error('invalid overload');
            }
            static cos(x) {
                return Math.cos(x);
            }
            static cosh(x) {
                return (MathHelper.exp(x) + MathHelper.exp(-x)) / 2.0;
            }
            static exp(x) {
                return Math.exp(x);
            }
            static expm1(d) {
                if (d === 0.0 || isNaN(d)) {
                    return d;
                }
                else if (!((value) => Number.NEGATIVE_INFINITY === value || Number.POSITIVE_INFINITY === value)(d)) {
                    if (d < 0.0) {
                        return -1.0;
                    }
                    else {
                        return javaemul.internal.DoubleHelper.POSITIVE_INFINITY;
                    }
                }
                return MathHelper.exp(d) + 1.0;
            }
            static floor(x) {
                return Math.floor(x);
            }
            static hypot(x, y) {
                return MathHelper.sqrt(x * x + y * y);
            }
            static log(x) {
                return Math.log(x);
            }
            static log10(x) {
                return Math.log(x) * Math.LOG10E;
            }
            static log1p(x) {
                return MathHelper.log(x + 1.0);
            }
            static max$double$double(x, y) {
                return Math.max(x, y);
            }
            static max$float$float(x, y) {
                return Math.fround(Math.max(x, y));
            }
            static max$int$int(x, y) {
                return x > y ? x : y;
            }
            static max(x, y) {
                if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                    return javaemul.internal.MathHelper.max$int$int(x, y);
                }
                else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                    return javaemul.internal.MathHelper.max$long$long(x, y);
                }
                else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                    return javaemul.internal.MathHelper.max$float$float(x, y);
                }
                else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                    return javaemul.internal.MathHelper.max$double$double(x, y);
                }
                else
                    throw new Error('invalid overload');
            }
            static max$long$long(x, y) {
                return x > y ? x : y;
            }
            static min$double$double(x, y) {
                return Math.min(x, y);
            }
            static min$float$float(x, y) {
                return Math.fround(Math.min(x, y));
            }
            static min$int$int(x, y) {
                return x < y ? x : y;
            }
            static min(x, y) {
                if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                    return javaemul.internal.MathHelper.min$int$int(x, y);
                }
                else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                    return javaemul.internal.MathHelper.min$long$long(x, y);
                }
                else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                    return javaemul.internal.MathHelper.min$float$float(x, y);
                }
                else if (((typeof x === 'number') || x === null) && ((typeof y === 'number') || y === null)) {
                    return javaemul.internal.MathHelper.min$double$double(x, y);
                }
                else
                    throw new Error('invalid overload');
            }
            static min$long$long(x, y) {
                return x < y ? x : y;
            }
            static pow(x, exp) {
                return Math.pow(x, exp);
            }
            static random() {
                return Math.random();
            }
            static rint(d) {
                if (isNaN(d)) {
                    return d;
                }
                else if (((value) => Number.NEGATIVE_INFINITY === value || Number.POSITIVE_INFINITY === value)(d)) {
                    return d;
                }
                else if (d === 0.0) {
                    return d;
                }
                else {
                    return MathHelper.round$double(d);
                }
            }
            static round$double(x) {
                return (n => n < 0 ? Math.ceil(n) : Math.floor(n))(Math.round(x));
            }
            static round$float(x) {
                let roundedValue = Math.round(x);
                return MathHelper.unsafeCastToInt(roundedValue);
            }
            static round(x) {
                if (((typeof x === 'number') || x === null)) {
                    return javaemul.internal.MathHelper.round$float(x);
                }
                else if (((typeof x === 'number') || x === null)) {
                    return javaemul.internal.MathHelper.round$double(x);
                }
                else
                    throw new Error('invalid overload');
            }
            /*private*/ static unsafeCastToInt(d) {
                return (d);
            }
            static scalb$double$int(d, scaleFactor) {
                if (scaleFactor >= 31 || scaleFactor <= -31) {
                    return d * MathHelper.pow(2, scaleFactor);
                }
                else if (scaleFactor > 0) {
                    return d * (1 << scaleFactor);
                }
                else if (scaleFactor === 0) {
                    return d;
                }
                else {
                    return d * 1.0 / (1 << -scaleFactor);
                }
            }
            static scalb$float$int(f, scaleFactor) {
                if (scaleFactor >= 31 || scaleFactor <= -31) {
                    return Math.fround(f * Math.fround(MathHelper.pow(2, scaleFactor)));
                }
                else if (scaleFactor > 0) {
                    return Math.fround(f * (1 << scaleFactor));
                }
                else if (scaleFactor === 0) {
                    return f;
                }
                else {
                    return Math.fround(Math.fround(f * 1.0) / (1 << -scaleFactor));
                }
            }
            static scalb(f, scaleFactor) {
                if (((typeof f === 'number') || f === null) && ((typeof scaleFactor === 'number') || scaleFactor === null)) {
                    return javaemul.internal.MathHelper.scalb$float$int(f, scaleFactor);
                }
                else if (((typeof f === 'number') || f === null) && ((typeof scaleFactor === 'number') || scaleFactor === null)) {
                    return javaemul.internal.MathHelper.scalb$double$int(f, scaleFactor);
                }
                else
                    throw new Error('invalid overload');
            }
            static signum$double(d) {
                if (d > 0.0) {
                    return 1.0;
                }
                else if (d < 0.0) {
                    return -1.0;
                }
                else {
                    return 0.0;
                }
            }
            static signum$float(f) {
                if (f > 0.0) {
                    return 1.0;
                }
                else if (f < 0.0) {
                    return -1.0;
                }
                else {
                    return 0.0;
                }
            }
            static signum(f) {
                if (((typeof f === 'number') || f === null)) {
                    return javaemul.internal.MathHelper.signum$float(f);
                }
                else if (((typeof f === 'number') || f === null)) {
                    return javaemul.internal.MathHelper.signum$double(f);
                }
                else
                    throw new Error('invalid overload');
            }
            static sin(x) {
                return Math.sin(x);
            }
            static sinh(x) {
                return (MathHelper.exp(x) - MathHelper.exp(-x)) / 2.0;
            }
            static sqrt(x) {
                return Math.sqrt(x);
            }
            static tan(x) {
                return Math.tan(x);
            }
            static tanh(x) {
                if (x === javaemul.internal.JsUtils.getInfinity()) {
                    return 1.0;
                }
                else if (x === -javaemul.internal.JsUtils.getInfinity()) {
                    return -1.0;
                }
                let e2x = MathHelper.exp(2.0 * x);
                return (e2x - 1) / (e2x + 1);
            }
            static toDegrees(x) {
                return x * MathHelper.PI_UNDER_180_$LI$();
            }
            static toRadians(x) {
                return x * MathHelper.PI_OVER_180_$LI$();
            }
            static IEEEremainder(f1, f2) {
                let r = Math.abs(f1 % f2);
                if (isNaN(r) || r === f2 || r <= Math.abs(f2) / 2.0) {
                    return r;
                }
                else {
                    return (f => { if (f > 0) {
                        return 1;
                    }
                    else if (f < 0) {
                        return -1;
                    }
                    else {
                        return 0;
                    } })(f1) * (r - f2);
                }
            }
        }
        MathHelper.E = 2.718281828459045;
        MathHelper.PI = 3.141592653589793;
        internal.MathHelper = MathHelper;
        MathHelper["__class"] = "javaemul.internal.MathHelper";
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
(function (javaemul) {
    var internal;
    (function (internal) {
        /**
         * Abstract base class for numeric wrapper classes.
         * @class
         */
        class NumberHelper {
            constructor() {
            }
            /**
             * @skip
             *
             * This function will determine the radix that the string is expressed
             * in based on the parsing rules defined in the Javadocs for
             * Integer.decode() and invoke __parseAndValidateInt.
             * @param {string} s
             * @param {number} lowerBound
             * @param {number} upperBound
             * @return {number}
             */
            static __decodeAndValidateInt(s, lowerBound, upperBound) {
                let decode = NumberHelper.__decodeNumberString(s);
                return NumberHelper.__parseAndValidateInt(decode.payload, decode.radix, lowerBound, upperBound);
            }
            static __decodeNumberString(s) {
                let negative;
                if (((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(s, "-")) {
                    negative = true;
                    s = s.substring(1);
                }
                else {
                    negative = false;
                    if (((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(s, "+")) {
                        s = s.substring(1);
                    }
                }
                let radix;
                if (((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(s, "0x") || ((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(s, "0X")) {
                    s = s.substring(2);
                    radix = 16;
                }
                else if (((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(s, "#")) {
                    s = s.substring(1);
                    radix = 16;
                }
                else if (((str, searchString, position = 0) => str.substr(position, searchString.length) === searchString)(s, "0")) {
                    radix = 8;
                }
                else {
                    radix = 10;
                }
                if (negative) {
                    s = "-" + s;
                }
                return new NumberHelper.__Decode(radix, s);
            }
            /**
             * @skip
             *
             * This function contains common logic for parsing a String as a
             * floating- point number and validating the range.
             * @param {string} s
             * @return {number}
             */
            static __parseAndValidateDouble(s) {
                if (!NumberHelper.__isValidDouble(s)) {
                    throw java.lang.NumberFormatException.forInputString(s);
                }
                return parseFloat(s);
            }
            /**
             * @skip
             *
             * This function contains common logic for parsing a String in a given
             * radix and validating the result.
             * @param {string} s
             * @param {number} radix
             * @param {number} lowerBound
             * @param {number} upperBound
             * @return {number}
             */
            static __parseAndValidateInt(s, radix, lowerBound, upperBound) {
                if (s == null) {
                    throw java.lang.NumberFormatException.forNullInputString();
                }
                if (radix < javaemul.internal.CharacterHelper.MIN_RADIX || radix > javaemul.internal.CharacterHelper.MAX_RADIX) {
                    throw java.lang.NumberFormatException.forRadix(radix);
                }
                let length = s.length;
                let startIndex = (length > 0) && ((c => c.charCodeAt == null ? c : c.charCodeAt(0))(s.charAt(0)) == '-'.charCodeAt(0) || (c => c.charCodeAt == null ? c : c.charCodeAt(0))(s.charAt(0)) == '+'.charCodeAt(0)) ? 1 : 0;
                for (let i = startIndex; i < length; i++) {
                    {
                        if (javaemul.internal.CharacterHelper.digit(s.charAt(i), radix) === -1) {
                            throw java.lang.NumberFormatException.forInputString(s);
                        }
                    }
                    ;
                }
                let toReturn = (parseInt(s, radix) | 0);
                let isTooLow = toReturn < lowerBound;
                if (javaemul.internal.DoubleHelper.isNaN(toReturn)) {
                    throw java.lang.NumberFormatException.forInputString(s);
                }
                else if (isTooLow || toReturn > upperBound) {
                    throw java.lang.NumberFormatException.forInputString(s);
                }
                return toReturn;
            }
            /**
             * @skip
             *
             * This function contains common logic for parsing a String in a given
             * radix and validating the result.
             * @param {string} s
             * @param {number} radix
             * @return {number}
             */
            static __parseAndValidateLong(s, radix) {
                if (s == null) {
                    throw java.lang.NumberFormatException.forNullInputString();
                }
                if (radix < javaemul.internal.CharacterHelper.MIN_RADIX || radix > javaemul.internal.CharacterHelper.MAX_RADIX) {
                    throw java.lang.NumberFormatException.forRadix(radix);
                }
                let orig = s;
                let length = s.length;
                let negative = false;
                if (length > 0) {
                    let c = s.charAt(0);
                    if ((c => c.charCodeAt == null ? c : c.charCodeAt(0))(c) == '-'.charCodeAt(0) || (c => c.charCodeAt == null ? c : c.charCodeAt(0))(c) == '+'.charCodeAt(0)) {
                        s = s.substring(1);
                        length--;
                        negative = ((c => c.charCodeAt == null ? c : c.charCodeAt(0))(c) == '-'.charCodeAt(0));
                    }
                }
                if (length === 0) {
                    throw java.lang.NumberFormatException.forInputString(orig);
                }
                while ((s.length > 0 && (c => c.charCodeAt == null ? c : c.charCodeAt(0))(s.charAt(0)) == '0'.charCodeAt(0))) {
                    {
                        s = s.substring(1);
                        length--;
                    }
                }
                ;
                if (length > NumberHelper.__ParseLong.maxLengthForRadix_$LI$()[radix]) {
                    throw java.lang.NumberFormatException.forInputString(orig);
                }
                for (let i = 0; i < length; i++) {
                    {
                        if (javaemul.internal.CharacterHelper.digit(s.charAt(i), radix) === -1) {
                            throw java.lang.NumberFormatException.forInputString(orig);
                        }
                    }
                    ;
                }
                let toReturn = 0;
                let maxDigits = NumberHelper.__ParseLong.maxDigitsForRadix_$LI$()[radix];
                let radixPower = NumberHelper.__ParseLong.maxDigitsRadixPower_$LI$()[radix];
                let minValue = -NumberHelper.__ParseLong.maxValueForRadix_$LI$()[radix];
                let firstTime = true;
                let head = length % maxDigits;
                if (head > 0) {
                    toReturn = -(parseInt(s.substring(0, head), radix) | 0);
                    s = s.substring(head);
                    length -= head;
                    firstTime = false;
                }
                while ((length >= maxDigits)) {
                    {
                        head = (parseInt(s.substring(0, maxDigits), radix) | 0);
                        s = s.substring(maxDigits);
                        length -= maxDigits;
                        if (!firstTime) {
                            if (toReturn < minValue) {
                                throw java.lang.NumberFormatException.forInputString(orig);
                            }
                            toReturn *= radixPower;
                        }
                        else {
                            firstTime = false;
                        }
                        toReturn -= head;
                    }
                }
                ;
                if (toReturn > 0) {
                    throw java.lang.NumberFormatException.forInputString(orig);
                }
                if (!negative) {
                    toReturn = -toReturn;
                    if (toReturn < 0) {
                        throw java.lang.NumberFormatException.forInputString(orig);
                    }
                }
                return toReturn;
            }
            /**
             * @skip
             *
             * @param {string} str
             * @return {boolean} {@code true} if the string matches the float format,
             * {@code false} otherwise
             * @private
             */
            static __isValidDouble(str) {
                if (NumberHelper.floatRegex == null) {
                    NumberHelper.floatRegex = NumberHelper.createFloatRegex();
                }
                return NumberHelper.floatRegex.test(str);
            }
            static createFloatRegex() {
                return (/^\s*[+-]?(NaN|Infinity|((\d+\.?\d*)|(\.\d+))([eE][+-]?\d+)?[dDfF]?)\s*$/);
            }
            byteValue() {
                return (this.intValue() | 0);
            }
            shortValue() {
                return (this.intValue() | 0);
            }
        }
        /**
         * Stores a regular expression object to verify the format of float values.
         */
        NumberHelper.floatRegex = null;
        internal.NumberHelper = NumberHelper;
        NumberHelper["__class"] = "javaemul.internal.NumberHelper";
        NumberHelper["__interfaces"] = ["java.io.Serializable"];
        (function (NumberHelper) {
            class __Decode {
                constructor(radix, payload) {
                    if (this.payload === undefined)
                        this.payload = null;
                    if (this.radix === undefined)
                        this.radix = 0;
                    this.radix = radix;
                    this.payload = payload;
                }
            }
            NumberHelper.__Decode = __Decode;
            __Decode["__class"] = "javaemul.internal.NumberHelper.__Decode";
            /**
             * Use nested class to avoid clinit on outer.
             * @class
             */
            class __ParseLong {
                constructor() {
                }
                static __static_initialize() { if (!__ParseLong.__static_initialized) {
                    __ParseLong.__static_initialized = true;
                    __ParseLong.__static_initializer_0();
                } }
                static maxDigitsForRadix_$LI$() { __ParseLong.__static_initialize(); if (__ParseLong.maxDigitsForRadix == null)
                    __ParseLong.maxDigitsForRadix = [-1, -1, 30, 19, 15, 13, 11, 11, 10, 9, 9, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5]; return __ParseLong.maxDigitsForRadix; }
                ;
                static maxDigitsRadixPower_$LI$() { __ParseLong.__static_initialize(); if (__ParseLong.maxDigitsRadixPower == null)
                    __ParseLong.maxDigitsRadixPower = (s => { let a = []; while (s-- > 0)
                        a.push(0); return a; })(37); return __ParseLong.maxDigitsRadixPower; }
                ;
                static maxLengthForRadix_$LI$() { __ParseLong.__static_initialize(); if (__ParseLong.maxLengthForRadix == null)
                    __ParseLong.maxLengthForRadix = [-1, -1, 63, 40, 32, 28, 25, 23, 21, 20, 19, 19, 18, 18, 17, 17, 16, 16, 16, 15, 15, 15, 15, 14, 14, 14, 14, 14, 14, 13, 13, 13, 13, 13, 13, 13, 13]; return __ParseLong.maxLengthForRadix; }
                ;
                static maxValueForRadix_$LI$() { __ParseLong.__static_initialize(); if (__ParseLong.maxValueForRadix == null)
                    __ParseLong.maxValueForRadix = (s => { let a = []; while (s-- > 0)
                        a.push(0); return a; })(37); return __ParseLong.maxValueForRadix; }
                ;
                static __static_initializer_0() {
                    for (let i = 2; i <= 36; i++) {
                        {
                            __ParseLong.maxDigitsRadixPower_$LI$()[i] = (Math.pow(i, __ParseLong.maxDigitsForRadix_$LI$()[i]) | 0);
                            __ParseLong.maxValueForRadix_$LI$()[i] = (n => n < 0 ? Math.ceil(n) : Math.floor(n))(9223372036854775807 / __ParseLong.maxDigitsRadixPower_$LI$()[i]);
                        }
                        ;
                    }
                }
            }
            __ParseLong.__static_initialized = false;
            NumberHelper.__ParseLong = __ParseLong;
            __ParseLong["__class"] = "javaemul.internal.NumberHelper.__ParseLong";
        })(NumberHelper = internal.NumberHelper || (internal.NumberHelper = {}));
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
(function (javaemul) {
    var internal;
    (function (internal) {
        class ObjectHelper {
            static clone(obj) {
                var copy;
                if (null == obj || "object" != typeof obj)
                    return obj;
                if (obj instanceof Date) {
                    copy = new Date();
                    copy.setTime(obj.getTime());
                    return copy;
                }
                ;
                if (obj instanceof Array) {
                    copy = [];
                    for (var i = 0, len = obj.length; i < len; i++) {
                        copy[i] = javaemul.internal.ObjectHelper.clone(obj[i]);
                    }
                    return copy;
                }
                ;
                if (obj instanceof Object) {
                    copy = {};
                    for (var attr in obj) {
                        if (obj.hasOwnProperty(attr))
                            copy[attr] = javaemul.internal.ObjectHelper.clone(obj[attr]);
                    }
                    return copy;
                }
                ;
                throw new Error("Unable to copy obj! Its type isn\'t supported.");
            }
        }
        internal.ObjectHelper = ObjectHelper;
        ObjectHelper["__class"] = "javaemul.internal.ObjectHelper";
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
(function (javaemul) {
    var internal;
    (function (internal) {
        var stream;
        (function (stream) {
            class ChooseSmallest {
                constructor(comparator) {
                    if (this.comparator === undefined)
                        this.comparator = null;
                    this.comparator = comparator;
                }
                apply(t1, t2) {
                    if (this.comparator.compare(t1, t2) <= 0) {
                        return t1;
                    }
                    return t2;
                }
            }
            stream.ChooseSmallest = ChooseSmallest;
            ChooseSmallest["__class"] = "javaemul.internal.stream.ChooseSmallest";
            ChooseSmallest["__interfaces"] = ["java.util.function.BiFunction", "java.util.function.BinaryOperator"];
        })(stream = internal.stream || (internal.stream = {}));
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
(function (javaemul) {
    var internal;
    (function (internal) {
        var stream;
        (function (stream) {
            class ConsumingFunction {
                constructor(consumer) {
                    if (this.consumer === undefined)
                        this.consumer = null;
                    this.consumer = (consumer);
                }
                /**
                 *
                 * @param {*} t
                 * @return {*}
                 */
                apply(t) {
                    (target => (typeof target === 'function') ? target(t) : target.accept(t))(this.consumer);
                    return t;
                }
            }
            stream.ConsumingFunction = ConsumingFunction;
            ConsumingFunction["__class"] = "javaemul.internal.stream.ConsumingFunction";
            ConsumingFunction["__interfaces"] = ["java.util.function.Function"];
        })(stream = internal.stream || (internal.stream = {}));
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
(function (javaemul) {
    var internal;
    (function (internal) {
        var stream;
        (function (stream) {
            class CountingPredicate {
                constructor(n) {
                    if (this.countDown === undefined)
                        this.countDown = 0;
                    this.countDown = n;
                }
                /**
                 *
                 * @param {*} t
                 * @return {boolean}
                 */
                test(t) {
                    if (this.countDown <= 0) {
                        return false;
                    }
                    --this.countDown;
                    return true;
                }
            }
            stream.CountingPredicate = CountingPredicate;
            CountingPredicate["__class"] = "javaemul.internal.stream.CountingPredicate";
            CountingPredicate["__interfaces"] = ["java.util.function.Predicate"];
        })(stream = internal.stream || (internal.stream = {}));
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
(function (javaemul) {
    var internal;
    (function (internal) {
        var stream;
        (function (stream) {
            class QuiteRunnable {
                constructor(loudRunnable) {
                    if (this.loudRunnable === undefined)
                        this.loudRunnable = null;
                    this.loudRunnable = (loudRunnable);
                }
                /**
                 *
                 */
                run() {
                    try {
                        (target => (typeof target === 'function') ? target() : target.run())(this.loudRunnable);
                    }
                    catch (e) {
                        console.error(e.message, e);
                    }
                    ;
                }
            }
            stream.QuiteRunnable = QuiteRunnable;
            QuiteRunnable["__class"] = "javaemul.internal.stream.QuiteRunnable";
            QuiteRunnable["__interfaces"] = ["java.lang.Runnable"];
        })(stream = internal.stream || (internal.stream = {}));
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
(function (javaemul) {
    var internal;
    (function (internal) {
        var stream;
        (function (stream) {
            class RunnableChain {
                constructor(run) {
                    if (this.run === undefined)
                        this.run = null;
                    if (this.next === undefined)
                        this.next = null;
                    this.run = (run);
                }
                chain(next) {
                    if (this.next == null) {
                        this.next = next;
                        return;
                    }
                    this.next.chain(next);
                }
                runChain() {
                    (target => (typeof target === 'function') ? target() : target.run())(this.run);
                    if (this.next == null) {
                        return;
                    }
                    this.next.runChain();
                }
            }
            stream.RunnableChain = RunnableChain;
            RunnableChain["__class"] = "javaemul.internal.stream.RunnableChain";
        })(stream = internal.stream || (internal.stream = {}));
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
(function (javaemul) {
    var internal;
    (function (internal) {
        var stream;
        (function (stream) {
            class StreamHelper {
                constructor(data) {
                    if (this.onCloseChain === undefined)
                        this.onCloseChain = null;
                    if (this.head === undefined)
                        this.head = null;
                    if (this.end === undefined)
                        this.end = null;
                    if (this.data === undefined)
                        this.data = null;
                    this.head = new javaemul.internal.stream.StreamRowMap((o) => o);
                    this.end = new javaemul.internal.stream.StreamRowEnd(this.head);
                    this.head.chain(this.end);
                    this.data = data;
                }
                /*private*/ chain(streamRow) {
                    this.end.chain(streamRow);
                    return this;
                }
                /*private*/ play() {
                    for (let index129 = this.data.iterator(); index129.hasNext();) {
                        let item = index129.next();
                        {
                            if (!this.head.item(item)) {
                                break;
                            }
                        }
                    }
                    this.head.end();
                }
                /*private*/ foldRight(identity, accumulator) {
                    let rowReduce = new javaemul.internal.stream.StreamRowReduce(identity, (accumulator));
                    this.chain(rowReduce);
                    this.play();
                    return rowReduce.getResult();
                }
                filter(predicate) {
                    return this.chain(new javaemul.internal.stream.StreamRowFilter((predicate)));
                }
                map(mapper) {
                    return this.chain(new javaemul.internal.stream.StreamRowMap((mapper)));
                }
                mapToObj(mapper) {
                    return this.chain(new javaemul.internal.stream.StreamRowMap((n) => (target => (typeof target === 'function') ? target(n) : target.apply(n))(mapper)));
                }
                flatMap(mapper) {
                    return this.chain(new javaemul.internal.stream.StreamRowFlatMap((mapper)));
                }
                distinct() {
                    return this.chain(new javaemul.internal.stream.StreamRowCollector((new java.util.LinkedHashSet())));
                }
                sorted$() {
                    return this.sorted$java_util_Comparator({ compare: (a, b) => a.compareTo(b) });
                }
                sorted$java_util_Comparator(comparator) {
                    return this.chain(new javaemul.internal.stream.StreamRowSortingCollector((new java.util.ArrayList()), comparator));
                }
                sorted(comparator) {
                    if (((comparator != null && (comparator["__interfaces"] != null && comparator["__interfaces"].indexOf("java.util.Comparator") >= 0 || comparator.constructor != null && comparator.constructor["__interfaces"] != null && comparator.constructor["__interfaces"].indexOf("java.util.Comparator") >= 0)) || comparator === null)) {
                        return this.sorted$java_util_Comparator(comparator);
                    }
                    else if (comparator === undefined) {
                        return this.sorted$();
                    }
                    else
                        throw new Error('invalid overload');
                }
                peek(action) {
                    return this.chain(new javaemul.internal.stream.StreamRowMap((arg0) => { return new javaemul.internal.stream.ConsumingFunction(action).apply(arg0); }));
                }
                limit(maxSize) {
                    return this.chain(new javaemul.internal.stream.StreamRowFilterFlop((arg0) => { return new javaemul.internal.stream.CountingPredicate(maxSize).test(arg0); }));
                }
                skip(n) {
                    let p = (new javaemul.internal.stream.CountingPredicate(n));
                    return this.chain(new javaemul.internal.stream.StreamRowFilter(((p) => {
                        return (v) => !p.test(v);
                    })(p)));
                }
                forEach(action) {
                    this.peek((action));
                    this.play();
                }
                forEachOrdered(action) {
                    this.forEach((action));
                }
                toArray$() {
                    let result = (new java.util.ArrayList());
                    this.chain(new javaemul.internal.stream.StreamRowCollector(result));
                    this.play();
                    return result.toArray();
                }
                toArray$java_util_function_IntFunction(generator) {
                    let result = (new java.util.ArrayList());
                    this.chain(new javaemul.internal.stream.StreamRowCollector(result));
                    this.play();
                    return result['toArray$java_lang_Object_A']((target => (typeof target === 'function') ? target(result.size()) : target.apply(result.size()))(generator));
                }
                toArray(generator) {
                    if (((typeof generator === 'function' && generator.length == 1) || generator === null)) {
                        return this.toArray$java_util_function_IntFunction(generator);
                    }
                    else if (generator === undefined) {
                        return this.toArray$();
                    }
                    else
                        throw new Error('invalid overload');
                }
                reduce$java_lang_Object$java_util_function_BinaryOperator(identity, accumulator) {
                    return this.foldRight(java.util.Optional.of(identity), (accumulator)).get();
                }
                reduce$java_util_function_BinaryOperator(accumulator) {
                    return this.foldRight(java.util.Optional.empty(), (accumulator));
                }
                collect$java_util_stream_Collector(collector) {
                    let container = (target => (typeof target === 'function') ? target() : target.get())(collector.supplier());
                    let accumulator = (collector.accumulator());
                    this.chain(new javaemul.internal.stream.StreamRowMap((arg0) => {
                        return new javaemul.internal.stream.ConsumingFunction(((container, accumulator) => {
                            return (item) => (target => (typeof target === 'function') ? target(container, item) : target.accept(container, item))(accumulator);
                        })(container, accumulator)).apply(arg0);
                    }));
                    this.play();
                    return container;
                }
                min(comparator) {
                    return this.foldRight(java.util.Optional.empty(), (a, b) => comparator.compare(a, b) <= 0 ? a : b);
                }
                max(comparator) {
                    return this.foldRight(java.util.Optional.empty(), (a, b) => comparator.compare(a, b) >= 0 ? a : b);
                }
                count() {
                    let counter = new javaemul.internal.stream.StreamRowCount();
                    this.chain(counter);
                    this.play();
                    return counter.getCount();
                }
                anyMatch(predicate) {
                    let streamRow = new javaemul.internal.stream.StreamRowOnceFilter((predicate));
                    this.chain(streamRow);
                    this.play();
                    return streamRow.getPredicateValue();
                }
                allMatch(predicate) {
                    let streamRow = new javaemul.internal.stream.StreamRowAllFilter((predicate));
                    this.chain(streamRow);
                    this.play();
                    return streamRow.getPredicateValue();
                }
                noneMatch(predicate) {
                    return this.allMatch((v) => !(target => (typeof target === 'function') ? target(v) : target.test(v))(predicate));
                }
                findFirst() {
                    let streamRow = new javaemul.internal.stream.StreamRowOnceFilter((o) => true);
                    this.chain(streamRow);
                    this.play();
                    return streamRow.getFirstMatch();
                }
                findAny() {
                    return this.findFirst();
                }
                iterator() {
                    let result = (new java.util.ArrayList());
                    this.chain(new javaemul.internal.stream.StreamRowCollector(result));
                    this.play();
                    return result.iterator();
                }
                isParallel() {
                    return false;
                }
                sequential() {
                    return this;
                }
                parallel() {
                    return this;
                }
                unordered() {
                    return this;
                }
                onClose(closeHandler) {
                    let chainItem = new javaemul.internal.stream.RunnableChain(() => { return new javaemul.internal.stream.QuiteRunnable(closeHandler).run(); });
                    if (this.onCloseChain == null) {
                        this.onCloseChain = chainItem;
                    }
                    else {
                        this.onCloseChain.chain(chainItem);
                    }
                    return this;
                }
                close() {
                    if (this.onCloseChain == null) {
                        return;
                    }
                    this.onCloseChain.runChain();
                }
                mapToInt(mapper) {
                    throw new java.lang.IllegalStateException();
                }
                mapToLong(mapper) {
                    throw new java.lang.IllegalStateException();
                }
                mapToDouble(mapper) {
                    throw new java.lang.IllegalStateException();
                }
                flatMapToInt(mapper) {
                    throw new java.lang.IllegalStateException();
                }
                flatMapToLong(mapper) {
                    throw new java.lang.IllegalStateException();
                }
                flatMapToDouble(mapper) {
                    throw new java.lang.IllegalStateException();
                }
                spliterator() {
                    throw new java.lang.IllegalStateException();
                }
                reduce$java_lang_Object$java_util_function_BiFunction$java_util_function_BinaryOperator(identity, accumulator, combiner) {
                    throw new java.lang.IllegalStateException();
                }
                reduce(identity, accumulator, combiner) {
                    if (((identity != null) || identity === null) && ((typeof accumulator === 'function' && accumulator.length == 2) || accumulator === null) && ((typeof combiner === 'function' && combiner.length == 2) || combiner === null)) {
                        return this.reduce$java_lang_Object$java_util_function_BiFunction$java_util_function_BinaryOperator(identity, accumulator, combiner);
                    }
                    else if (((identity != null) || identity === null) && ((typeof accumulator === 'function' && accumulator.length == 2) || accumulator === null) && combiner === undefined) {
                        return this.reduce$java_lang_Object$java_util_function_BinaryOperator(identity, accumulator);
                    }
                    else if (((typeof identity === 'function' && identity.length == 2) || identity === null) && accumulator === undefined && combiner === undefined) {
                        return this.reduce$java_util_function_BinaryOperator(identity);
                    }
                    else
                        throw new Error('invalid overload');
                }
                collect$java_util_function_Supplier$java_util_function_BiConsumer$java_util_function_BiConsumer(supplier, accumulator, combiner) {
                    throw new java.lang.IllegalStateException();
                }
                collect(supplier, accumulator, combiner) {
                    if (((typeof supplier === 'function' && supplier.length == 0) || supplier === null) && ((typeof accumulator === 'function' && accumulator.length == 2) || accumulator === null) && ((typeof combiner === 'function' && combiner.length == 2) || combiner === null)) {
                        return this.collect$java_util_function_Supplier$java_util_function_BiConsumer$java_util_function_BiConsumer(supplier, accumulator, combiner);
                    }
                    else if (((supplier != null && (supplier["__interfaces"] != null && supplier["__interfaces"].indexOf("java.util.stream.Collector") >= 0 || supplier.constructor != null && supplier.constructor["__interfaces"] != null && supplier.constructor["__interfaces"].indexOf("java.util.stream.Collector") >= 0)) || supplier === null) && accumulator === undefined && combiner === undefined) {
                        return this.collect$java_util_stream_Collector(supplier);
                    }
                    else
                        throw new Error('invalid overload');
                }
            }
            stream.StreamHelper = StreamHelper;
            StreamHelper["__class"] = "javaemul.internal.stream.StreamHelper";
            StreamHelper["__interfaces"] = ["java.util.stream.Stream"];
        })(stream = internal.stream || (internal.stream = {}));
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
(function (javaemul) {
    var internal;
    (function (internal) {
        var stream;
        (function (stream) {
            class TerminalStreamRow {
                constructor() {
                }
                chain(next) {
                    if (next.constructor === javaemul.internal.stream.StreamRowEnd) {
                        return;
                    }
                    throw new java.lang.IllegalStateException();
                }
                end() {
                }
            }
            stream.TerminalStreamRow = TerminalStreamRow;
            TerminalStreamRow["__class"] = "javaemul.internal.stream.TerminalStreamRow";
            TerminalStreamRow["__interfaces"] = ["javaemul.internal.stream.StreamRow"];
        })(stream = internal.stream || (internal.stream = {}));
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
(function (javaemul) {
    var internal;
    (function (internal) {
        var stream;
        (function (stream) {
            class TransientStreamRow {
                constructor() {
                    if (this.next === undefined)
                        this.next = null;
                }
                chain(next) {
                    this.next = next;
                }
            }
            stream.TransientStreamRow = TransientStreamRow;
            TransientStreamRow["__class"] = "javaemul.internal.stream.TransientStreamRow";
            TransientStreamRow["__interfaces"] = ["javaemul.internal.stream.StreamRow"];
        })(stream = internal.stream || (internal.stream = {}));
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
(function (javaemul) {
    var internal;
    (function (internal) {
        var stream;
        (function (stream) {
            class VoidRunnable {
                constructor() {
                }
                static dryRun_$LI$() { if (VoidRunnable.dryRun == null)
                    VoidRunnable.dryRun = new VoidRunnable(); return VoidRunnable.dryRun; }
                ;
                run() {
                }
            }
            stream.VoidRunnable = VoidRunnable;
            VoidRunnable["__class"] = "javaemul.internal.stream.VoidRunnable";
            VoidRunnable["__interfaces"] = ["java.lang.Runnable"];
        })(stream = internal.stream || (internal.stream = {}));
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
(function (javaemul) {
    var internal;
    (function (internal) {
        /**
         * Hashcode caching for strings.
         * @class
         */
        class StringHashCache {
            static back_$LI$() { if (StringHashCache.back == null)
                StringHashCache.back = StringHashCache.createNativeObject(); return StringHashCache.back; }
            ;
            static front_$LI$() { if (StringHashCache.front == null)
                StringHashCache.front = StringHashCache.createNativeObject(); return StringHashCache.front; }
            ;
            static getHashCode(str) {
                let key = ":" + str;
                let result = StringHashCache.getProperty(StringHashCache.front_$LI$(), key);
                if (!javaemul.internal.JsUtils.isUndefined(result)) {
                    return StringHashCache.unsafeCastToInt(result);
                }
                result = StringHashCache.getProperty(StringHashCache.back_$LI$(), key);
                let hashCode = javaemul.internal.JsUtils.isUndefined(result) ? StringHashCache.compute(str) : StringHashCache.unsafeCastToInt(result);
                StringHashCache.increment();
                javaemul.internal.JsUtils.setIntProperty(StringHashCache.front_$LI$(), key, hashCode);
                return hashCode;
            }
            /*private*/ static compute(str) {
                let hashCode = 0;
                let n = str.length;
                let nBatch = n - 4;
                let i = 0;
                while ((i < nBatch)) {
                    {
                        hashCode = (c => c.charCodeAt == null ? c : c.charCodeAt(0))(str.charAt(i + 3)) + 31 * ((c => c.charCodeAt == null ? c : c.charCodeAt(0))(str.charAt(i + 2)) + 31 * ((c => c.charCodeAt == null ? c : c.charCodeAt(0))(str.charAt(i + 1)) + 31 * ((c => c.charCodeAt == null ? c : c.charCodeAt(0))(str.charAt(i)) + 31 * hashCode)));
                        hashCode = javaemul.internal.Coercions.ensureInt(hashCode);
                        i += 4;
                    }
                }
                ;
                while ((i < n)) {
                    {
                        hashCode = hashCode * 31 + (c => c.charCodeAt == null ? c : c.charCodeAt(0))(str.charAt(i++));
                    }
                }
                ;
                hashCode = javaemul.internal.Coercions.ensureInt(hashCode);
                return hashCode;
            }
            /*private*/ static increment() {
                if (StringHashCache.count === StringHashCache.MAX_CACHE) {
                    StringHashCache.back = StringHashCache.front;
                    StringHashCache.front = StringHashCache.createNativeObject();
                    StringHashCache.count = 0;
                }
                ++StringHashCache.count;
            }
            /*private*/ static getProperty(map, key) {
                return (map[key]);
            }
            /*private*/ static createNativeObject() {
                return ({});
            }
            /*private*/ static unsafeCastToInt(o) {
                return (o);
            }
        }
        /**
         * Tracks the number of entries in front.
         */
        StringHashCache.count = 0;
        /**
         * Pulled this number out of thin air.
         */
        StringHashCache.MAX_CACHE = 256;
        internal.StringHashCache = StringHashCache;
        StringHashCache["__class"] = "javaemul.internal.StringHashCache";
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
var test;
(function (test) {
    class Test {
        static main(args) {
            console.info(java.util.Arrays.asList("a", "b", "c"));
        }
        static assertEquals(o1, o2) {
            if (!(o1 === o2)) {
                throw new Error("invalid assertion: " + o1 + "!=" + o2);
            }
        }
        static assertTrue(b) {
            if (!b) {
                throw new Error("invalid assertion");
            }
        }
        static assertFalse(b) {
            if (b) {
                throw new Error("invalid assertion");
            }
        }
        static test() {
            try {
                Test.testArrays();
                Test.testList();
                Test.testMap();
                Test.testSet();
                Test.testString();
                Test.testIO();
                console.error("OS NAME: " + java.lang.System.getProperty$java_lang_String("os.name"));
                console.info("Get input: ");
                let scanner = new java.util.Scanner(java.lang.System.in_$LI$());
                if (scanner.hasNextLine()) {
                    console.info("Got input: " + scanner.nextLine());
                }
                else {
                    console.info("No any input :(");
                }
                if (java.lang.System.ENVIRONMENT_IS_WEB_$LI$()) {
                    let result = document.getElementById("result");
                    if (result != null) {
                        result.innerHTML = "Success!";
                    }
                }
                else {
                    console.info("Success!");
                }
            }
            catch (e) {
                console.error(e);
                if (java.lang.System.ENVIRONMENT_IS_WEB_$LI$()) {
                    let result = document.getElementById("result");
                    if (result != null) {
                        result.innerHTML = "Failure: " + e.message;
                    }
                }
                else {
                    console.info("Failure: " + e.message);
                }
            }
            ;
        }
        static testArrays() {
            console.info("testing arrays");
            let srcArray = ["a", "b", "c"];
            let dstArray = (s => { let a = []; while (s-- > 0)
                a.push(null); return a; })(srcArray.length - 1);
            java.lang.System.arraycopy(srcArray, 1, dstArray, 0, srcArray.length - 1);
            Test.assertEquals(2, dstArray.length);
            Test.assertEquals("b", dstArray[0]);
            Test.assertEquals("c", dstArray[1]);
            let myArray = [3, 2, 1];
            Test.assertEquals(3, myArray[0]);
            java.util.Arrays.sort$int_A(myArray);
            Test.assertEquals(1, myArray[0]);
            let l = java.util.Arrays.asList("a", "b", "c", "d");
            Test.assertEquals(4, l.size());
            let a = (java.util.Arrays.copyOf$java_lang_Object_A$int(l['toArray$java_lang_Object_A']([]), 3));
            Test.assertEquals(3, a.length);
            let reverse = new Test.Test$0();
            java.util.Arrays.sort$java_lang_Object_A$java_util_Comparator(a, reverse);
            Test.assertEquals("[c, b, a]", java.util.Arrays.asList(a[0], a[1], a[2]).toString());
            console.info("end testing arrays");
        }
        static testList() {
            console.info("testing lists");
            let l = (new java.util.ArrayList());
            l.add("a");
            l.add("b");
            l.add("c");
            Test.assertEquals(l.toString(), "[a, b, c]");
            Test.assertEquals(l.subList(1, 3).toString(), "[b, c]");
            Test.assertEquals(l['remove$java_lang_Object']("b"), true);
            Test.assertEquals(l['remove$java_lang_Object']("d"), false);
            Test.assertEquals(l['remove$int'](1), "c");
            l.add("c");
            Test.assertEquals(l.toString(), "[a, c]");
            Test.assertEquals(l.size(), 2);
            Test.assertEquals(l.get(1), "c");
            Test.assertEquals(l.indexOf("a"), 0);
            let res = "";
            for (let index130 = l.iterator(); index130.hasNext();) {
                let s = index130.next();
                {
                    res += s;
                }
            }
            Test.assertEquals("ac", res);
            let it = l.iterator();
            Test.assertTrue(it.hasNext());
            Test.assertEquals("a", it.next());
            Test.assertTrue(it.hasNext());
            Test.assertEquals("c", it.next());
            Test.assertFalse(it.hasNext());
            l.clear();
            l.add("bb");
            l.add("aa");
            Test.assertEquals(l.toString(), "[bb, aa]");
            java.util.Collections.sort$java_util_List$java_util_Comparator(l, java.text.Collator.getInstance());
            Test.assertEquals(l.toString(), "[aa, bb]");
            console.info("end testing lists");
        }
        static testSet() {
            console.info("testing sets");
            let s = (new java.util.HashSet());
            s.add("a");
            s.add("a");
            s.add("b");
            s.add("c");
            s.add("c");
            Test.assertEquals(s.toString(), "[a, b, c]");
            s.remove("b");
            Test.assertTrue(s.contains("a"));
            Test.assertTrue(s.contains("c"));
            Test.assertFalse(s.contains("b"));
            Test.assertEquals(s.size(), 2);
            console.info("testing bit sets");
            let bs = java.util.BitSet.valueOf([255]);
            Test.assertTrue(bs.get$int(0));
            Test.assertTrue(bs.get$int(1));
            Test.assertTrue(bs.get$int(7));
            Test.assertFalse(bs.get$int(8));
            let bs2 = java.util.BitSet.valueOf([1]);
            Test.assertTrue(bs2.get$int(0));
            Test.assertFalse(bs2.get$int(1));
            bs.and(bs2);
            Test.assertTrue(bs.get$int(0));
            Test.assertFalse(bs.get$int(1));
            console.info("end testing sets");
        }
        static testMap() {
            console.info("testing maps");
            let m = (new java.util.HashMap());
            m.put("a", "aa");
            m.put("b", "bb");
            m.put("c", "cc");
            Test.assertEquals(m.size(), 3);
            Test.assertEquals("bb", m.get("b"));
            m.remove("aa");
            Test.assertEquals(m.size(), 3);
            m.remove("a");
            Test.assertEquals(m.size(), 2);
            Test.assertEquals(null, m.get("undefinedKey"));
            Test.assertFalse(m.get("undefinedKey") === undefined);
            let m2 = (new java.util.HashMap());
            m2.put(Test.key1(), "a");
            m2.put(new test.MyKey("2"), "b");
            Test.assertEquals(2, m2.size());
            Test.assertEquals("a", m2.get(new test.MyKey("1")));
            Test.assertTrue(m2.containsKey(new test.MyKey("2")));
            Test.assertEquals("[1, 2]", m2.keySet().toString());
            Test.assertEquals("[a, b]", m2.values().toString());
            m2.remove(new test.MyKey("1"));
            Test.assertEquals(1, m2.size());
            Test.assertEquals(null, m2.get(new test.MyKey("1")));
            Test.assertEquals(null, java.util.Collections.singletonMap(Test.key1(), "1").get(new test.MyKey("a")));
            Test.assertEquals("1", java.util.Collections.singletonMap(Test.key2(), "1").get(new test.MyKey("a")));
            Test.assertEquals("2", java.util.Collections.singletonMap(new test.MyKey("b"), "2").get(new test.MyKey("b")));
            console.info("end testing maps");
        }
        static testString() {
            console.info("testing strings");
            let sb = new java.lang.StringBuilder();
            sb.append$boolean(true);
            sb.append$char('c');
            sb.append$java_lang_String("test");
            sb.deleteCharAt(sb.length() - 1);
            Test.assertEquals("truectes", sb.toString());
            sb.append$java_lang_CharSequence$int$int("abc", 0, 1);
            Test.assertEquals("truectesa", sb.toString());
            let sb2 = new java.lang.StringBuffer();
            sb2.append$boolean(true);
            sb2.append$char('c');
            sb2.append$java_lang_String("test");
            sb2.deleteCharAt(sb2.length() - 1);
            Test.assertEquals("truectes", sb2.toString());
            Test.assertEquals('a', javaemul.internal.CharacterHelper.toLowerCase('A'));
            Test.assertEquals("abc", "ABC".toLowerCase());
            console.info("end testing strings");
        }
        static testIO() {
            console.info("testing io");
            let s = new java.io.ByteArrayInputStream(/* getBytes */ ("abc").split('').map(s => s.charCodeAt(0)));
            Test.assertEquals(javaemul.internal.CharacterHelper.getNumericValue('a'), s.read());
            console.info("end testing io");
        }
        static key1() {
            return new test.MyKey("1");
        }
        static key2() {
            return new test.MyKey("a");
        }
    }
    test.Test = Test;
    Test["__class"] = "test.Test";
    (function (Test) {
        class Test$0 {
            constructor() {
            }
            compare$java_lang_String$java_lang_String(o1, o2) {
                return o2.localeCompare(o1);
            }
            /**
             *
             * @param {string} o1
             * @param {string} o2
             * @return {number}
             */
            compare(o1, o2) {
                if (((typeof o1 === 'string') || o1 === null) && ((typeof o2 === 'string') || o2 === null)) {
                    return this.compare$java_lang_String$java_lang_String(o1, o2);
                }
                else
                    throw new Error('invalid overload');
            }
        }
        Test.Test$0 = Test$0;
        Test$0["__interfaces"] = ["java.util.Comparator"];
    })(Test = test.Test || (test.Test = {}));
    class MyKey {
        constructor(data) {
            if (this.data === undefined)
                this.data = null;
            this.data = data;
        }
        toString() {
            return this.data;
        }
        /**
         *
         * @param {*} obj
         * @return {boolean}
         */
        equals(obj) {
            return ((o1, o2) => { if (o1 && o1.equals) {
                return o1.equals(o2);
            }
            else {
                return o1 === o2;
            } })(this.data, obj.data);
        }
        /**
         *
         * @return {number}
         */
        hashCode() {
            return ((o) => { if (o.hashCode) {
                return o.hashCode();
            }
            else {
                return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
            } })(this.data);
        }
    }
    test.MyKey = MyKey;
    MyKey["__class"] = "test.MyKey";
})(test || (test = {}));
(function (java) {
    var io;
    (function (io) {
        /**
         * Constructs a new {@code ByteArrayInputStream} on the byte array
         * {@code buf} with the initial position set to {@code offset} and the
         * number of bytes available set to {@code offset} + {@code length}.
         *
         * @param {Array} buf
         * the byte array to stream over.
         * @param {number} offset
         * the initial position in {@code buf} to start streaming from.
         * @param {number} length
         * the number of bytes available for streaming.
         * @class
         * @extends java.io.InputStream
         */
        class ByteArrayInputStream extends java.io.InputStream {
            constructor(buf, offset, length) {
                if (((buf != null && buf instanceof Array && (buf.length == 0 || buf[0] == null || (typeof buf[0] === 'number'))) || buf === null) && ((typeof offset === 'number') || offset === null) && ((typeof length === 'number') || length === null)) {
                    let __args = arguments;
                    super();
                    if (this.buf === undefined)
                        this.buf = null;
                    if (this.pos === undefined)
                        this.pos = 0;
                    if (this._mark === undefined)
                        this._mark = 0;
                    if (this.count === undefined)
                        this.count = 0;
                    if (this.buf === undefined)
                        this.buf = null;
                    if (this.pos === undefined)
                        this.pos = 0;
                    if (this._mark === undefined)
                        this._mark = 0;
                    if (this.count === undefined)
                        this.count = 0;
                    (() => {
                        if (length === -1) {
                            length = buf.length;
                        }
                        this.buf = buf;
                        this.pos = offset;
                        this._mark = offset;
                        this.count = offset + length > buf.length ? buf.length : offset + length;
                    })();
                }
                else if (((buf != null && buf instanceof Array && (buf.length == 0 || buf[0] == null || (typeof buf[0] === 'number'))) || buf === null) && offset === undefined && length === undefined) {
                    let __args = arguments;
                    {
                        let __args = arguments;
                        let offset = 0;
                        let length = -1;
                        super();
                        if (this.buf === undefined)
                            this.buf = null;
                        if (this.pos === undefined)
                            this.pos = 0;
                        if (this._mark === undefined)
                            this._mark = 0;
                        if (this.count === undefined)
                            this.count = 0;
                        if (this.buf === undefined)
                            this.buf = null;
                        if (this.pos === undefined)
                            this.pos = 0;
                        if (this._mark === undefined)
                            this._mark = 0;
                        if (this.count === undefined)
                            this.count = 0;
                        (() => {
                            if (length === -1) {
                                length = buf.length;
                            }
                            this.buf = buf;
                            this.pos = offset;
                            this._mark = offset;
                            this.count = offset + length > buf.length ? buf.length : offset + length;
                        })();
                    }
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             * Returns the number of remaining bytes.
             *
             * @return {number} {@code count - pos}
             */
            available() {
                return this.count - this.pos;
            }
            /**
             * Closes this stream and frees resources associated with this stream.
             *
             * @throws IOException
             * if an I/O error occurs while closing this stream.
             */
            close() {
            }
            /**
             * Sets a mark position in this ByteArrayInputStream. The parameter
             * {@code readlimit} is ignored. Sending {@code reset()} will reposition the
             * stream back to the marked position.
             *
             * @param {number} readlimit
             * ignored.
             * @see #markSupported()
             * @see #reset()
             */
            mark(readlimit) {
                this._mark = this.pos;
            }
            /**
             * Indicates whether this stream supports the {@code mark()} and
             * {@code reset()} methods. Returns {@code true} since this class supports
             * these methods.
             *
             * @return {boolean} always {@code true}.
             * @see #mark(int)
             * @see #reset()
             */
            markSupported() {
                return true;
            }
            read$() {
                return this.read$byte_A$int$int(null, 0, 0);
            }
            read$byte_A$int$int(buffer, byteOffset, byteCount) {
                if (buffer == null) {
                    return this.pos < this.count ? this.buf[this.pos++] & 255 : -1;
                }
                java.io.IOUtils.checkOffsetAndCount$byte_A$int$int(buffer, byteOffset, byteCount);
                if (this.pos >= this.count) {
                    return -1;
                }
                if (byteCount === 0) {
                    return 0;
                }
                let copylen = this.count - this.pos < byteCount ? this.count - this.pos : byteCount;
                java.lang.System.arraycopy(this.buf, this.pos, buffer, byteOffset, copylen);
                this.pos += copylen;
                return copylen;
            }
            /**
             *
             * @param {Array} buffer
             * @param {number} byteOffset
             * @param {number} byteCount
             * @return {number}
             */
            read(buffer, byteOffset, byteCount) {
                if (((buffer != null && buffer instanceof Array && (buffer.length == 0 || buffer[0] == null || (typeof buffer[0] === 'number'))) || buffer === null) && ((typeof byteOffset === 'number') || byteOffset === null) && ((typeof byteCount === 'number') || byteCount === null)) {
                    return this.read$byte_A$int$int(buffer, byteOffset, byteCount);
                }
                else if (((buffer != null && buffer instanceof Array && (buffer.length == 0 || buffer[0] == null || (typeof buffer[0] === 'number'))) || buffer === null) && byteOffset === undefined && byteCount === undefined) {
                    return this.read$byte_A(buffer);
                }
                else if (buffer === undefined && byteOffset === undefined && byteCount === undefined) {
                    return this.read$();
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             * Resets this stream to the last marked location. This implementation
             * resets the position to either the marked position, the start position
             * supplied in the constructor or 0 if neither has been provided.
             *
             * @see #mark(int)
             */
            reset() {
                this.pos = this._mark;
            }
            /**
             * Skips {@code byteCount} bytes in this InputStream. Subsequent calls to
             * {@code read} will not return these bytes unless {@code reset} is used.
             * This implementation skips {@code byteCount} number of bytes in the target
             * stream. It does nothing and returns 0 if {@code byteCount} is negative.
             *
             * @return {number} the number of bytes actually skipped.
             * @param {number} byteCount
             */
            skip(byteCount) {
                if (byteCount <= 0) {
                    return 0;
                }
                let temp = this.pos;
                this.pos = this.count - this.pos < byteCount ? this.count : ((this.pos + byteCount) | 0);
                return this.pos - temp;
            }
        }
        io.ByteArrayInputStream = ByteArrayInputStream;
        ByteArrayInputStream["__class"] = "java.io.ByteArrayInputStream";
        ByteArrayInputStream["__interfaces"] = ["java.io.Closeable", "java.lang.AutoCloseable"];
    })(io = java.io || (java.io = {}));
})(java || (java = {}));
(function (java) {
    var io;
    (function (io) {
        /**
         * Wraps an existing {@link InputStream} and performs some transformation on
         * the input data while it is being read. Transformations can be anything from a
         * simple byte-wise filtering input data to an on-the-fly compression or
         * decompression of the underlying stream. Input streams that wrap another input
         * stream and provide some additional functionality on top of it usually inherit
         * from this class.
         *
         * @see FilterOutputStream
         * @extends java.io.InputStream
         * @class
         */
        class FilterInputStream extends java.io.InputStream {
            constructor(__in) {
                super();
                if (this.in === undefined)
                    this.in = null;
                this.in = __in;
            }
            /**
             *
             * @return {number}
             */
            available() {
                return this.in.available();
            }
            /**
             * Closes this stream. This implementation closes the filtered stream.
             *
             * @throws IOException
             * if an error occurs while closing this stream.
             */
            close() {
                this.in.close();
            }
            /**
             * Sets a mark position in this stream. The parameter {@code readlimit}
             * indicates how many bytes can be read before the mark is invalidated.
             * Sending {@code reset()} will reposition this stream back to the marked
             * position, provided that {@code readlimit} has not been surpassed.
             * <p>
             * This implementation sets a mark in the filtered stream.
             *
             * @param {number} readlimit
             * the number of bytes that can be read from this stream before
             * the mark is invalidated.
             * @see #markSupported()
             * @see #reset()
             */
            mark(readlimit) {
                this.in.mark(readlimit);
            }
            /**
             * Indicates whether this stream supports {@code mark()} and {@code reset()}.
             * This implementation returns whether or not the filtered stream supports
             * marking.
             *
             * @return {boolean} {@code true} if {@code mark()} and {@code reset()} are supported,
             * {@code false} otherwise.
             * @see #mark(int)
             * @see #reset()
             * @see #skip(long)
             */
            markSupported() {
                return this.in.markSupported();
            }
            read(buffer, byteOffset, byteCount) {
                if (((buffer != null && buffer instanceof Array && (buffer.length == 0 || buffer[0] == null || (typeof buffer[0] === 'number'))) || buffer === null) && ((typeof byteOffset === 'number') || byteOffset === null) && ((typeof byteCount === 'number') || byteCount === null)) {
                    super.read(buffer, byteOffset, byteCount);
                }
                else if (((buffer != null && buffer instanceof Array && (buffer.length == 0 || buffer[0] == null || (typeof buffer[0] === 'number'))) || buffer === null) && byteOffset === undefined && byteCount === undefined) {
                    return this.read$byte_A(buffer);
                }
                else if (buffer === undefined && byteOffset === undefined && byteCount === undefined) {
                    return this.read$();
                }
                else
                    throw new Error('invalid overload');
            }
            read$() {
                return this.in.read();
            }
            /**
             * Resets this stream to the last marked location. This implementation
             * resets the target stream.
             *
             * @throws IOException
             * if this stream is already closed, no mark has been set or the
             * mark is no longer valid because more than {@code readlimit}
             * bytes have been read since setting the mark.
             * @see #mark(int)
             * @see #markSupported()
             */
            reset() {
                this.in.reset();
            }
            /**
             * Skips {@code byteCount} bytes in this stream. Subsequent
             * calls to {@code read} will not return these bytes unless {@code reset} is
             * used. This implementation skips {@code byteCount} bytes in the
             * filtered stream.
             *
             * @return {number} the number of bytes actually skipped.
             * @throws IOException
             * if this stream is closed or another IOException occurs.
             * @see #mark(int)
             * @see #reset()
             * @param {number} byteCount
             */
            skip(byteCount) {
                return this.in.skip(byteCount);
            }
        }
        io.FilterInputStream = FilterInputStream;
        FilterInputStream["__class"] = "java.io.FilterInputStream";
        FilterInputStream["__interfaces"] = ["java.io.Closeable", "java.lang.AutoCloseable"];
    })(io = java.io || (java.io = {}));
})(java || (java = {}));
(function (java) {
    var io;
    (function (io) {
        /**
         * Constructs a new {@code ByteArrayOutputStream} with a default size of
         * {@code size} bytes. If more than {@code size} bytes are written to this
         * instance, the underlying byte array will expand.
         *
         * @param {number} size
         * initial size for the underlying byte array, must be
         * non-negative.
         * @throws IllegalArgumentException
         * if {@code size} < 0.
         * @class
         * @extends java.io.OutputStream
         */
        class ByteArrayOutputStream extends java.io.OutputStream {
            constructor(size) {
                if (((typeof size === 'number') || size === null)) {
                    let __args = arguments;
                    super();
                    if (this.buf === undefined)
                        this.buf = null;
                    if (this.count === undefined)
                        this.count = 0;
                    if (this.buf === undefined)
                        this.buf = null;
                    if (this.count === undefined)
                        this.count = 0;
                    (() => {
                        if (size >= 0) {
                            this.buf = (s => { let a = []; while (s-- > 0)
                                a.push(0); return a; })(size);
                        }
                        else {
                            throw new java.lang.IllegalArgumentException("size < 0");
                        }
                    })();
                }
                else if (size === undefined) {
                    let __args = arguments;
                    super();
                    if (this.buf === undefined)
                        this.buf = null;
                    if (this.count === undefined)
                        this.count = 0;
                    if (this.buf === undefined)
                        this.buf = null;
                    if (this.count === undefined)
                        this.count = 0;
                    (() => {
                        this.buf = (s => { let a = []; while (s-- > 0)
                            a.push(0); return a; })(32);
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             * Closes this stream. This releases system resources used for this stream.
             *
             * @throws IOException
             * if an error occurs while attempting to close this stream.
             */
            close() {
                super.close();
            }
            /*private*/ expand(i) {
                if (this.count + i <= this.buf.length) {
                    return;
                }
                let newbuf = (s => { let a = []; while (s-- > 0)
                    a.push(0); return a; })((this.count + i) * 2);
                java.lang.System.arraycopy(this.buf, 0, newbuf, 0, this.count);
                this.buf = newbuf;
            }
            /**
             * Resets this stream to the beginning of the underlying byte array. All
             * subsequent writes will overwrite any bytes previously stored in this
             * stream.
             */
            reset() {
                this.count = 0;
            }
            /**
             * Returns the total number of bytes written to this stream so far.
             *
             * @return {number} the number of bytes written to this stream.
             */
            size() {
                return this.count;
            }
            /**
             * Returns the contents of this ByteArrayOutputStream as a byte array. Any
             * changes made to the receiver after returning will not be reflected in the
             * byte array returned to the caller.
             *
             * @return {Array} this stream's current contents as a byte array.
             */
            toByteArray() {
                let newArray = (s => { let a = []; while (s-- > 0)
                    a.push(0); return a; })(this.count);
                java.lang.System.arraycopy(this.buf, 0, newArray, 0, this.count);
                return newArray;
            }
            toString$() {
                return ((str, index, len) => str.substring(index, index + len))((this.buf).map(s => String.fromCharCode(s)).join(''), 0, this.count);
            }
            toString$int(hibyte) {
                let newBuf = (s => { let a = []; while (s-- > 0)
                    a.push(null); return a; })(this.size());
                for (let i = 0; i < newBuf.length; i++) {
                    {
                        newBuf[i] = String.fromCharCode((((hibyte & 255) << 8) | (this.buf[i] & 255)));
                    }
                    ;
                }
                return new String(newBuf);
            }
            toString$java_lang_String(charsetName) {
                return ((str, index, len) => str.substring(index, index + len))((this.buf).map(s => String.fromCharCode(s)).join(''), 0, this.count);
            }
            /**
             * Returns the contents of this ByteArrayOutputStream as a string converted
             * according to the encoding declared in {@code charsetName}.
             *
             * @param {string} charsetName
             * a string representing the encoding to use when translating
             * this stream to a string.
             * @return {string} this stream's current contents as an encoded string.
             * @throws UnsupportedEncodingException
             * if the provided encoding is not supported.
             */
            toString(charsetName) {
                if (((typeof charsetName === 'string') || charsetName === null)) {
                    return this.toString$java_lang_String(charsetName);
                }
                else if (((typeof charsetName === 'number') || charsetName === null)) {
                    return this.toString$int(charsetName);
                }
                else if (charsetName === undefined) {
                    return this.toString$();
                }
                else
                    throw new Error('invalid overload');
            }
            write$byte_A$int$int(buffer, offset, len) {
                java.io.IOUtils.checkOffsetAndCount$byte_A$int$int(buffer, offset, len);
                if (len === 0) {
                    return;
                }
                this.expand(len);
                java.lang.System.arraycopy(buffer, offset, this.buf, this.count, len);
                this.count += len;
            }
            /**
             * Writes {@code count} bytes from the byte array {@code buffer} starting at
             * offset {@code index} to this stream.
             *
             * @param {Array} buffer
             * the buffer to be written.
             * @param {number} offset
             * the initial position in {@code buffer} to retrieve bytes.
             * @param {number} len
             * the number of bytes of {@code buffer} to write.
             * @throws NullPointerException
             * if {@code buffer} is {@code null}.
             * @throws IndexOutOfBoundsException
             * if {@code offset < 0} or {@code len < 0}, or if
             * {@code offset + len} is greater than the length of
             * {@code buffer}.
             */
            write(buffer, offset, len) {
                if (((buffer != null && buffer instanceof Array && (buffer.length == 0 || buffer[0] == null || (typeof buffer[0] === 'number'))) || buffer === null) && ((typeof offset === 'number') || offset === null) && ((typeof len === 'number') || len === null)) {
                    return this.write$byte_A$int$int(buffer, offset, len);
                }
                else if (((buffer != null && buffer instanceof Array && (buffer.length == 0 || buffer[0] == null || (typeof buffer[0] === 'number'))) || buffer === null) && offset === undefined && len === undefined) {
                    return this.write$byte_A(buffer);
                }
                else if (((typeof buffer === 'number') || buffer === null) && offset === undefined && len === undefined) {
                    return this.write$int(buffer);
                }
                else
                    throw new Error('invalid overload');
            }
            write$int(oneByte) {
                if (this.count === this.buf.length) {
                    this.expand(1);
                }
                this.buf[this.count++] = (oneByte | 0);
            }
            /**
             * Takes the contents of this stream and writes it to the output stream
             * {@code out}.
             *
             * @param {java.io.OutputStream} out
             * an OutputStream on which to write the contents of this stream.
             * @throws IOException
             * if an error occurs while writing to {@code out}.
             */
            writeTo(out) {
                out.write$byte_A$int$int(this.buf, 0, this.count);
            }
        }
        io.ByteArrayOutputStream = ByteArrayOutputStream;
        ByteArrayOutputStream["__class"] = "java.io.ByteArrayOutputStream";
        ByteArrayOutputStream["__interfaces"] = ["java.io.Closeable", "java.lang.AutoCloseable", "java.io.Flushable"];
    })(io = java.io || (java.io = {}));
})(java || (java = {}));
(function (java) {
    var io;
    (function (io) {
        /**
         * Constructs a new {@code FilterOutputStream} with {@code out} as its
         * target stream.
         *
         * @param {java.io.OutputStream} out
         * the target stream that this stream writes to.
         * @class
         * @extends java.io.OutputStream
         */
        class FilterOutputStream extends java.io.OutputStream {
            constructor(out) {
                super();
                if (this.out === undefined)
                    this.out = null;
                this.out = out;
            }
            /**
             * Closes this stream. This implementation closes the target stream.
             *
             * @throws IOException
             * if an error occurs attempting to close this stream.
             */
            close() {
                let thrown = null;
                try {
                    this.flush();
                }
                catch (e) {
                    thrown = e;
                }
                ;
                try {
                    this.out.close();
                }
                catch (e) {
                    if (thrown == null) {
                        thrown = e;
                    }
                }
                ;
                if (thrown != null) {
                    throw new java.io.IOException(thrown);
                }
            }
            /**
             * Ensures that all pending data is sent out to the target stream. This
             * implementation flushes the target stream.
             *
             * @throws IOException
             * if an error occurs attempting to flush this stream.
             */
            flush() {
                this.out.flush();
            }
            write(buffer, offset, count) {
                if (((buffer != null && buffer instanceof Array && (buffer.length == 0 || buffer[0] == null || (typeof buffer[0] === 'number'))) || buffer === null) && ((typeof offset === 'number') || offset === null) && ((typeof count === 'number') || count === null)) {
                    super.write(buffer, offset, count);
                }
                else if (((buffer != null && buffer instanceof Array && (buffer.length == 0 || buffer[0] == null || (typeof buffer[0] === 'number'))) || buffer === null) && offset === undefined && count === undefined) {
                    return this.write$byte_A(buffer);
                }
                else if (((typeof buffer === 'number') || buffer === null) && offset === undefined && count === undefined) {
                    return this.write$int(buffer);
                }
                else
                    throw new Error('invalid overload');
            }
            write$int(oneByte) {
                this.out.write$int(oneByte);
            }
        }
        io.FilterOutputStream = FilterOutputStream;
        FilterOutputStream["__class"] = "java.io.FilterOutputStream";
        FilterOutputStream["__interfaces"] = ["java.io.Closeable", "java.lang.AutoCloseable", "java.io.Flushable"];
    })(io = java.io || (java.io = {}));
})(java || (java = {}));
(function (java) {
    var io;
    (function (io) {
        /**
         * JSweet implementation.
         * @param {java.io.Reader} in
         * @param {number} sz
         * @class
         * @extends java.io.Reader
         */
        class BufferedReader extends java.io.Reader {
            constructor(__in, sz) {
                if (((__in != null && __in instanceof java.io.Reader) || __in === null) && ((typeof sz === 'number') || sz === null)) {
                    let __args = arguments;
                    super(__in);
                    if (this.in === undefined)
                        this.in = null;
                    if (this.cb === undefined)
                        this.cb = null;
                    if (this.nChars === undefined)
                        this.nChars = 0;
                    if (this.nextChar === undefined)
                        this.nextChar = 0;
                    if (this.markedChar === undefined)
                        this.markedChar = 0;
                    if (this.readAheadLimit === undefined)
                        this.readAheadLimit = 0;
                    if (this.skipLF === undefined)
                        this.skipLF = false;
                    if (this.markedSkipLF === undefined)
                        this.markedSkipLF = false;
                    if (this.in === undefined)
                        this.in = null;
                    if (this.cb === undefined)
                        this.cb = null;
                    if (this.nChars === undefined)
                        this.nChars = 0;
                    if (this.nextChar === undefined)
                        this.nextChar = 0;
                    if (this.markedChar === undefined)
                        this.markedChar = 0;
                    if (this.readAheadLimit === undefined)
                        this.readAheadLimit = 0;
                    if (this.skipLF === undefined)
                        this.skipLF = false;
                    if (this.markedSkipLF === undefined)
                        this.markedSkipLF = false;
                    (() => {
                        this.markedChar = BufferedReader.UNMARKED;
                        this.readAheadLimit = 0;
                        this.skipLF = false;
                        this.markedSkipLF = false;
                        if (sz <= 0)
                            throw new java.lang.IllegalArgumentException("Buffer size <= 0");
                        this.in = __in;
                        this.cb = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(sz);
                        this.nextChar = this.nChars = 0;
                    })();
                }
                else if (((__in != null && __in instanceof java.io.Reader) || __in === null) && sz === undefined) {
                    let __args = arguments;
                    {
                        let __args = arguments;
                        let sz = BufferedReader.defaultCharBufferSize;
                        super(__in);
                        if (this.in === undefined)
                            this.in = null;
                        if (this.cb === undefined)
                            this.cb = null;
                        if (this.nChars === undefined)
                            this.nChars = 0;
                        if (this.nextChar === undefined)
                            this.nextChar = 0;
                        if (this.markedChar === undefined)
                            this.markedChar = 0;
                        if (this.readAheadLimit === undefined)
                            this.readAheadLimit = 0;
                        if (this.skipLF === undefined)
                            this.skipLF = false;
                        if (this.markedSkipLF === undefined)
                            this.markedSkipLF = false;
                        if (this.in === undefined)
                            this.in = null;
                        if (this.cb === undefined)
                            this.cb = null;
                        if (this.nChars === undefined)
                            this.nChars = 0;
                        if (this.nextChar === undefined)
                            this.nextChar = 0;
                        if (this.markedChar === undefined)
                            this.markedChar = 0;
                        if (this.readAheadLimit === undefined)
                            this.readAheadLimit = 0;
                        if (this.skipLF === undefined)
                            this.skipLF = false;
                        if (this.markedSkipLF === undefined)
                            this.markedSkipLF = false;
                        (() => {
                            this.markedChar = BufferedReader.UNMARKED;
                            this.readAheadLimit = 0;
                            this.skipLF = false;
                            this.markedSkipLF = false;
                            if (sz <= 0)
                                throw new java.lang.IllegalArgumentException("Buffer size <= 0");
                            this.in = __in;
                            this.cb = (s => { let a = []; while (s-- > 0)
                                a.push(null); return a; })(sz);
                            this.nextChar = this.nChars = 0;
                        })();
                    }
                }
                else
                    throw new Error('invalid overload');
            }
            /*private*/ ensureOpen() {
                if (this.in == null)
                    throw new java.io.IOException("Stream closed");
            }
            /*private*/ fill() {
                let dst;
                if (this.markedChar <= BufferedReader.UNMARKED) {
                    dst = 0;
                }
                else {
                    let delta = this.nextChar - this.markedChar;
                    if (delta >= this.readAheadLimit) {
                        this.markedChar = BufferedReader.INVALIDATED;
                        this.readAheadLimit = 0;
                        dst = 0;
                    }
                    else {
                        if (this.readAheadLimit <= this.cb.length) {
                            java.lang.System.arraycopy(this.cb, this.markedChar, this.cb, 0, delta);
                            this.markedChar = 0;
                            dst = delta;
                        }
                        else {
                            let ncb = (s => { let a = []; while (s-- > 0)
                                a.push(null); return a; })(this.readAheadLimit);
                            java.lang.System.arraycopy(this.cb, this.markedChar, ncb, 0, delta);
                            this.cb = ncb;
                            this.markedChar = 0;
                            dst = delta;
                        }
                        this.nextChar = this.nChars = delta;
                    }
                }
                let n;
                do {
                    {
                        n = this.in.read$char_A$int$int(this.cb, dst, this.cb.length - dst);
                    }
                } while ((n === 0));
                if (n > 0) {
                    this.nChars = dst + n;
                    this.nextChar = dst;
                }
            }
            read$() {
                {
                    this.ensureOpen();
                    for (;;) {
                        {
                            if (this.nextChar >= this.nChars) {
                                this.fill();
                                if (this.nextChar >= this.nChars)
                                    return -1;
                            }
                            if (this.skipLF) {
                                this.skipLF = false;
                                if ((c => c.charCodeAt == null ? c : c.charCodeAt(0))(this.cb[this.nextChar]) == '\n'.charCodeAt(0)) {
                                    this.nextChar++;
                                    continue;
                                }
                            }
                            return (this.cb[this.nextChar++]).charCodeAt(0);
                        }
                        ;
                    }
                }
                ;
            }
            /*private*/ read1(cbuf, off, len) {
                if (this.nextChar >= this.nChars) {
                    if (len >= this.cb.length && this.markedChar <= BufferedReader.UNMARKED && !this.skipLF) {
                        return this.in.read$char_A$int$int(cbuf, off, len);
                    }
                    this.fill();
                }
                if (this.nextChar >= this.nChars)
                    return -1;
                if (this.skipLF) {
                    this.skipLF = false;
                    if ((c => c.charCodeAt == null ? c : c.charCodeAt(0))(this.cb[this.nextChar]) == '\n'.charCodeAt(0)) {
                        this.nextChar++;
                        if (this.nextChar >= this.nChars)
                            this.fill();
                        if (this.nextChar >= this.nChars)
                            return -1;
                    }
                }
                let n = Math.min(len, this.nChars - this.nextChar);
                java.lang.System.arraycopy(this.cb, this.nextChar, cbuf, off, n);
                this.nextChar += n;
                return n;
            }
            read$char_A$int$int(cbuf, off, len) {
                {
                    this.ensureOpen();
                    if ((off < 0) || (off > cbuf.length) || (len < 0) || ((off + len) > cbuf.length) || ((off + len) < 0)) {
                        throw new java.lang.IndexOutOfBoundsException();
                    }
                    else if (len === 0) {
                        return 0;
                    }
                    let n = this.read1(cbuf, off, len);
                    if (n <= 0)
                        return n;
                    while (((n < len) && this.in.ready())) {
                        {
                            let n1 = this.read1(cbuf, off + n, len - n);
                            if (n1 <= 0)
                                break;
                            n += n1;
                        }
                    }
                    ;
                    return n;
                }
                ;
            }
            read(cbuf, off, len) {
                if (((cbuf != null && cbuf instanceof Array && (cbuf.length == 0 || cbuf[0] == null || (typeof cbuf[0] === 'string'))) || cbuf === null) && ((typeof off === 'number') || off === null) && ((typeof len === 'number') || len === null)) {
                    return this.read$char_A$int$int(cbuf, off, len);
                }
                else if (((cbuf != null && cbuf instanceof Array && (cbuf.length == 0 || cbuf[0] == null || (typeof cbuf[0] === 'string'))) || cbuf === null) && off === undefined && len === undefined) {
                    return this.read$char_A(cbuf);
                }
                else if (cbuf === undefined && off === undefined && len === undefined) {
                    return this.read$();
                }
                else
                    throw new Error('invalid overload');
            }
            readLine$boolean(ignoreLF) {
                let s = null;
                let startChar;
                {
                    this.ensureOpen();
                    let omitLF = ignoreLF || this.skipLF;
                    for (;;) {
                        {
                            if (this.nextChar >= this.nChars)
                                this.fill();
                            if (this.nextChar >= this.nChars) {
                                if (s != null && s.length() > 0)
                                    return s.toString();
                                else
                                    return null;
                            }
                            let eol = false;
                            let c = String.fromCharCode(0);
                            let i;
                            if (omitLF && ((c => c.charCodeAt == null ? c : c.charCodeAt(0))(this.cb[this.nextChar]) == '\n'.charCodeAt(0)))
                                this.nextChar++;
                            this.skipLF = false;
                            omitLF = false;
                            charLoop: for (i = this.nextChar; i < this.nChars; i++) {
                                {
                                    c = this.cb[i];
                                    if (((c => c.charCodeAt == null ? c : c.charCodeAt(0))(c) == '\n'.charCodeAt(0)) || ((c => c.charCodeAt == null ? c : c.charCodeAt(0))(c) == '\r'.charCodeAt(0))) {
                                        eol = true;
                                        break charLoop;
                                    }
                                }
                                ;
                            }
                            startChar = this.nextChar;
                            this.nextChar = i;
                            if (eol) {
                                let str;
                                if (s == null) {
                                    str = ((str, index, len) => str.substring(index, index + len))((this.cb).join(''), startChar, i - startChar);
                                }
                                else {
                                    s.append$char_A$int$int(this.cb, startChar, i - startChar);
                                    str = s.toString();
                                }
                                this.nextChar++;
                                if ((c => c.charCodeAt == null ? c : c.charCodeAt(0))(c) == '\r'.charCodeAt(0)) {
                                    this.skipLF = true;
                                }
                                return str;
                            }
                            if (s == null)
                                s = new java.lang.StringBuffer(BufferedReader.defaultExpectedLineLength);
                            s.append$char_A$int$int(this.cb, startChar, i - startChar);
                        }
                        ;
                    }
                }
                ;
            }
            readLine(ignoreLF) {
                if (((typeof ignoreLF === 'boolean') || ignoreLF === null)) {
                    return this.readLine$boolean(ignoreLF);
                }
                else if (ignoreLF === undefined) {
                    return this.readLine$();
                }
                else
                    throw new Error('invalid overload');
            }
            readLine$() {
                return this.readLine$boolean(false);
            }
            skip(n) {
                if (n < 0) {
                    throw new java.lang.IllegalArgumentException("skip value is negative");
                }
                {
                    this.ensureOpen();
                    let r = n;
                    while ((r > 0)) {
                        {
                            if (this.nextChar >= this.nChars)
                                this.fill();
                            if (this.nextChar >= this.nChars)
                                break;
                            if (this.skipLF) {
                                this.skipLF = false;
                                if ((c => c.charCodeAt == null ? c : c.charCodeAt(0))(this.cb[this.nextChar]) == '\n'.charCodeAt(0)) {
                                    this.nextChar++;
                                }
                            }
                            let d = this.nChars - this.nextChar;
                            if (r <= d) {
                                this.nextChar += r;
                                r = 0;
                                break;
                            }
                            else {
                                r -= d;
                                this.nextChar = this.nChars;
                            }
                        }
                    }
                    ;
                    return n - r;
                }
                ;
            }
            ready() {
                this.ensureOpen();
                if (this.skipLF) {
                    if (this.nextChar >= this.nChars && this.in.ready()) {
                        this.fill();
                    }
                    if (this.nextChar < this.nChars) {
                        if ((c => c.charCodeAt == null ? c : c.charCodeAt(0))(this.cb[this.nextChar]) == '\n'.charCodeAt(0))
                            this.nextChar++;
                        this.skipLF = false;
                    }
                }
                return (this.nextChar < this.nChars) || this.in.ready();
            }
            markSupported() {
                return true;
            }
            mark(readAheadLimit) {
                if (readAheadLimit < 0) {
                    throw new java.lang.IllegalArgumentException("Read-ahead limit < 0");
                }
                this.ensureOpen();
                this.readAheadLimit = readAheadLimit;
                this.markedChar = this.nextChar;
                this.markedSkipLF = this.skipLF;
            }
            reset() {
                this.ensureOpen();
                if (this.markedChar < 0)
                    throw new java.io.IOException((this.markedChar === BufferedReader.INVALIDATED) ? "Mark invalid" : "Stream not marked");
                this.nextChar = this.markedChar;
                this.skipLF = this.markedSkipLF;
            }
            close() {
                if (this.in == null)
                    return;
                try {
                    this.in.close();
                }
                finally {
                    this.in = null;
                    this.cb = null;
                }
                ;
            }
        }
        BufferedReader.INVALIDATED = -2;
        BufferedReader.UNMARKED = -1;
        BufferedReader.defaultCharBufferSize = 8192;
        BufferedReader.defaultExpectedLineLength = 80;
        io.BufferedReader = BufferedReader;
        BufferedReader["__class"] = "java.io.BufferedReader";
        BufferedReader["__interfaces"] = ["java.io.Closeable", "java.lang.AutoCloseable"];
    })(io = java.io || (java.io = {}));
})(java || (java = {}));
(function (java) {
    var io;
    (function (io) {
        /**
         * JSweet implementation.
         * @param {java.io.InputStream} in
         * @param {string} charsetName
         * @class
         * @extends java.io.Reader
         */
        class InputStreamReader extends java.io.Reader {
            constructor(__in, charsetName) {
                if (((__in != null && __in instanceof java.io.InputStream) || __in === null) && ((typeof charsetName === 'string') || charsetName === null)) {
                    let __args = arguments;
                    super(__in);
                    if (this.in === undefined)
                        this.in = null;
                    if (this.in === undefined)
                        this.in = null;
                    (() => {
                        this.in = __in;
                    })();
                }
                else if (((__in != null && __in instanceof java.io.InputStream) || __in === null) && ((charsetName != null && charsetName instanceof java.nio.charset.Charset) || charsetName === null)) {
                    let __args = arguments;
                    let cs = __args[1];
                    super(__in);
                    if (this.in === undefined)
                        this.in = null;
                    if (this.in === undefined)
                        this.in = null;
                    (() => {
                        this.in = __in;
                        if (cs == null)
                            throw new java.lang.NullPointerException("charset");
                    })();
                }
                else if (((__in != null && __in instanceof java.io.InputStream) || __in === null) && charsetName === undefined) {
                    let __args = arguments;
                    super(__in);
                    if (this.in === undefined)
                        this.in = null;
                    if (this.in === undefined)
                        this.in = null;
                    (() => {
                        this.in = __in;
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            read$char_A$int$int(cbuf, offset, length) {
                let buf = (s => { let a = []; while (s-- > 0)
                    a.push(0); return a; })(length - offset);
                let success = this.in.read$byte_A$int$int(buf, 0, length);
                if (success > 0) {
                    for (let i = 0; i < success; ++i) {
                        {
                            cbuf[i + offset] = (String.fromCharCode(buf[i])).charAt(0);
                        }
                        ;
                    }
                }
                return success;
            }
            read(cbuf, offset, length) {
                if (((cbuf != null && cbuf instanceof Array && (cbuf.length == 0 || cbuf[0] == null || (typeof cbuf[0] === 'string'))) || cbuf === null) && ((typeof offset === 'number') || offset === null) && ((typeof length === 'number') || length === null)) {
                    return this.read$char_A$int$int(cbuf, offset, length);
                }
                else if (((cbuf != null && cbuf instanceof Array && (cbuf.length == 0 || cbuf[0] == null || (typeof cbuf[0] === 'string'))) || cbuf === null) && offset === undefined && length === undefined) {
                    return this.read$char_A(cbuf);
                }
                else if (cbuf === undefined && offset === undefined && length === undefined) {
                    return this.read$();
                }
                else
                    throw new Error('invalid overload');
            }
            ready() {
                return this.in.available() > 0;
            }
            close() {
                this.in.close();
            }
        }
        io.InputStreamReader = InputStreamReader;
        InputStreamReader["__class"] = "java.io.InputStreamReader";
        InputStreamReader["__interfaces"] = ["java.io.Closeable", "java.lang.AutoCloseable"];
    })(io = java.io || (java.io = {}));
})(java || (java = {}));
(function (java) {
    var io;
    (function (io) {
        class StringReader extends java.io.Reader {
            constructor(start) {
                super();
                /*private*/ this.marked = -1;
                if (this.charArray === undefined)
                    this.charArray = null;
                if (this.where === undefined)
                    this.where = 0;
                if (this.markedLen === undefined)
                    this.markedLen = 0;
                this.charArray = (start).split('');
            }
            read$char_A$int$int(cbuf, off, len) {
                if ((off < 0) || (off > cbuf.length) || (len < 0) || ((off + len) > cbuf.length) || ((off + len) < 0)) {
                    throw new java.lang.IndexOutOfBoundsException();
                }
                else if (len === 0) {
                    return 0;
                }
                if (this.where === this.charArray.length)
                    return -1;
                let size = Math.min(this.charArray.length - this.where, len);
                java.lang.System.arraycopy(this.charArray, this.where, cbuf, off, size);
                this.where += size;
                return size;
            }
            /**
             *
             * @param {Array} cbuf
             * @param {number} off
             * @param {number} len
             * @return {number}
             */
            read(cbuf, off, len) {
                if (((cbuf != null && cbuf instanceof Array && (cbuf.length == 0 || cbuf[0] == null || (typeof cbuf[0] === 'string'))) || cbuf === null) && ((typeof off === 'number') || off === null) && ((typeof len === 'number') || len === null)) {
                    return this.read$char_A$int$int(cbuf, off, len);
                }
                else if (((cbuf != null && cbuf instanceof Array && (cbuf.length == 0 || cbuf[0] == null || (typeof cbuf[0] === 'string'))) || cbuf === null) && off === undefined && len === undefined) {
                    return this.read$char_A(cbuf);
                }
                else if (cbuf === undefined && off === undefined && len === undefined) {
                    return this.read$();
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             *
             */
            close() {
                this.where = this.charArray.length;
            }
            /**
             *
             * @return {boolean}
             */
            ready() {
                return this.where < this.charArray.length;
            }
            /**
             *
             * @return {boolean}
             */
            markSupported() {
                return true;
            }
            /**
             *
             * @param {number} readAheadLimit
             */
            mark(readAheadLimit) {
                this.marked = this.where;
                this.markedLen = readAheadLimit;
            }
            /**
             *
             */
            reset() {
                if (this.marked === -1 || this.where > this.marked + this.markedLen) {
                    throw new java.io.IOException("The stream not been marked or mark has been invalidated");
                }
                this.where = this.marked;
            }
        }
        io.StringReader = StringReader;
        StringReader["__class"] = "java.io.StringReader";
        StringReader["__interfaces"] = ["java.io.Closeable", "java.lang.AutoCloseable"];
    })(io = java.io || (java.io = {}));
})(java || (java = {}));
(function (java) {
    var io;
    (function (io) {
        /**
         * JSweet implementation (partial).
         *
         * TODO: actual support of charsets.
         * @param {java.io.OutputStream} out
         * @param {string} charsetName
         * @class
         * @extends java.io.Writer
         */
        class OutputStreamWriter extends java.io.Writer {
            constructor(out, charsetName) {
                if (((out != null && out instanceof java.io.OutputStream) || out === null) && ((typeof charsetName === 'string') || charsetName === null)) {
                    let __args = arguments;
                    super(out);
                    if (this.out === undefined)
                        this.out = null;
                    if (this.out === undefined)
                        this.out = null;
                    (() => {
                        if (charsetName == null)
                            throw new java.lang.NullPointerException("charsetName");
                        this.out = out;
                    })();
                }
                else if (((out != null && out instanceof java.io.OutputStream) || out === null) && ((charsetName != null && charsetName instanceof java.nio.charset.Charset) || charsetName === null)) {
                    let __args = arguments;
                    let cs = __args[1];
                    super(out);
                    if (this.out === undefined)
                        this.out = null;
                    if (this.out === undefined)
                        this.out = null;
                    (() => {
                        if (cs == null)
                            throw new java.lang.NullPointerException("charset");
                        this.out = out;
                    })();
                }
                else if (((out != null && out instanceof java.io.OutputStream) || out === null) && charsetName === undefined) {
                    let __args = arguments;
                    super(out);
                    if (this.out === undefined)
                        this.out = null;
                    if (this.out === undefined)
                        this.out = null;
                    (() => {
                        this.out = out;
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            flushBuffer() {
                this.out.flush();
            }
            write$int(c) {
                this.out.write$int(c);
            }
            write$char_A$int$int(cbuf, off, len) {
                let buf = (s => { let a = []; while (s-- > 0)
                    a.push(0); return a; })(len);
                for (let i = 0; i < len; ++i) {
                    buf[i] = ((cbuf[i + off]).charCodeAt(0) | 0);
                }
                this.out.write$byte_A$int$int(buf, 0, len);
            }
            write(cbuf, off, len) {
                if (((cbuf != null && cbuf instanceof Array && (cbuf.length == 0 || cbuf[0] == null || (typeof cbuf[0] === 'string'))) || cbuf === null) && ((typeof off === 'number') || off === null) && ((typeof len === 'number') || len === null)) {
                    return this.write$char_A$int$int(cbuf, off, len);
                }
                else if (((typeof cbuf === 'string') || cbuf === null) && ((typeof off === 'number') || off === null) && ((typeof len === 'number') || len === null)) {
                    return this.write$java_lang_String$int$int(cbuf, off, len);
                }
                else if (((cbuf != null && cbuf instanceof Array && (cbuf.length == 0 || cbuf[0] == null || (typeof cbuf[0] === 'string'))) || cbuf === null) && off === undefined && len === undefined) {
                    return this.write$char_A(cbuf);
                }
                else if (((typeof cbuf === 'string') || cbuf === null) && off === undefined && len === undefined) {
                    return this.write$java_lang_String(cbuf);
                }
                else if (((typeof cbuf === 'number') || cbuf === null) && off === undefined && len === undefined) {
                    return this.write$int(cbuf);
                }
                else
                    throw new Error('invalid overload');
            }
            write$java_lang_String$int$int(str, off, len) {
                this.out.write$byte_A$int$int(/* getBytes */ (str).split('').map(s => s.charCodeAt(0)), off, len);
            }
            flush() {
                this.out.flush();
            }
            close() {
                this.out.close();
            }
        }
        io.OutputStreamWriter = OutputStreamWriter;
        OutputStreamWriter["__class"] = "java.io.OutputStreamWriter";
        OutputStreamWriter["__interfaces"] = ["java.lang.Appendable", "java.io.Closeable", "java.lang.AutoCloseable", "java.io.Flushable"];
    })(io = java.io || (java.io = {}));
})(java || (java = {}));
(function (java) {
    var lang;
    (function (lang) {
        /**
         * A fast way to create strings using multiple appends.
         *
         * This class is an exact clone of {@link StringBuilder} except for the name.
         * Any change made to one should be mirrored in the other.
         * @param {*} s
         * @class
         * @extends java.lang.AbstractStringBuilder
         */
        class StringBuffer extends java.lang.AbstractStringBuilder {
            constructor(s) {
                if (((typeof s === 'string') || s === null)) {
                    let __args = arguments;
                    super(s);
                }
                else if (((s != null && (s["__interfaces"] != null && s["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || s.constructor != null && s.constructor["__interfaces"] != null && s.constructor["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || typeof s === "string")) || s === null)) {
                    let __args = arguments;
                    super(/* valueOf */ new String(s).toString());
                }
                else if (((typeof s === 'number') || s === null)) {
                    let __args = arguments;
                    let ignoredCapacity = __args[0];
                    super("");
                }
                else if (s === undefined) {
                    let __args = arguments;
                    super("");
                }
                else
                    throw new Error('invalid overload');
            }
            append$boolean(x) {
                this.string += x;
                return this;
            }
            append$char(x) {
                this.string += x;
                return this;
            }
            append$char_A(x) {
                this.string += new String(x).toString();
                return this;
            }
            append$char_A$int$int(x, start, len) {
                this.string += ((str, index, len) => str.join('').substring(index, index + len))(x, start, len);
                return this;
            }
            append(x, start, len) {
                if (((x != null && x instanceof Array && (x.length == 0 || x[0] == null || (typeof x[0] === 'string'))) || x === null) && ((typeof start === 'number') || start === null) && ((typeof len === 'number') || len === null)) {
                    return this.append$char_A$int$int(x, start, len);
                }
                else if (((x != null && (x["__interfaces"] != null && x["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || x.constructor != null && x.constructor["__interfaces"] != null && x.constructor["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || typeof x === "string")) || x === null) && ((typeof start === 'number') || start === null) && ((typeof len === 'number') || len === null)) {
                    return this.append$java_lang_CharSequence$int$int(x, start, len);
                }
                else if (((x != null && x instanceof Array && (x.length == 0 || x[0] == null || (typeof x[0] === 'string'))) || x === null) && start === undefined && len === undefined) {
                    return this.append$char_A(x);
                }
                else if (((typeof x === 'string') || x === null) && start === undefined && len === undefined) {
                    return this.append$java_lang_String(x);
                }
                else if (((x != null && x instanceof java.lang.StringBuffer) || x === null) && start === undefined && len === undefined) {
                    return this.append$java_lang_StringBuffer(x);
                }
                else if (((x != null && (x["__interfaces"] != null && x["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || x.constructor != null && x.constructor["__interfaces"] != null && x.constructor["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || typeof x === "string")) || x === null) && start === undefined && len === undefined) {
                    return this.append$java_lang_CharSequence(x);
                }
                else if (((typeof x === 'boolean') || x === null) && start === undefined && len === undefined) {
                    return this.append$boolean(x);
                }
                else if (((typeof x === 'string') || x === null) && start === undefined && len === undefined) {
                    return this.append$char(x);
                }
                else if (((typeof x === 'number') || x === null) && start === undefined && len === undefined) {
                    return this.append$int(x);
                }
                else if (((typeof x === 'number') || x === null) && start === undefined && len === undefined) {
                    return this.append$long(x);
                }
                else if (((typeof x === 'number') || x === null) && start === undefined && len === undefined) {
                    return this.append$float(x);
                }
                else if (((typeof x === 'number') || x === null) && start === undefined && len === undefined) {
                    return this.append$double(x);
                }
                else if (((x != null) || x === null) && start === undefined && len === undefined) {
                    return this.append$java_lang_Object(x);
                }
                else
                    throw new Error('invalid overload');
            }
            append$java_lang_CharSequence(x) {
                this.string += x;
                return this;
            }
            append$java_lang_CharSequence$int$int(x, start, end) {
                this.append0(x, start, end);
                return this;
            }
            append$double(x) {
                this.string += x;
                return this;
            }
            append$float(x) {
                this.string += x;
                return this;
            }
            append$int(x) {
                this.string += x;
                return this;
            }
            append$long(x) {
                this.string += x;
                return this;
            }
            append$java_lang_Object(x) {
                this.string += x;
                return this;
            }
            append$java_lang_String(x) {
                this.string += x;
                return this;
            }
            append$java_lang_StringBuffer(x) {
                this.string += x;
                return this;
            }
            appendCodePoint(x) {
                this.appendCodePoint0(x);
                return this;
            }
            delete(start, end) {
                this.replace0(start, end, "");
                return this;
            }
            deleteCharAt(start) {
                this.replace0(start, start + 1, "");
                return this;
            }
            insert$int$boolean(index, x) {
                return this.insert$int$java_lang_String(index, /* valueOf */ new String(x).toString());
            }
            insert$int$char(index, x) {
                return this.insert$int$java_lang_String(index, /* valueOf */ new String(x).toString());
            }
            insert$int$char_A(index, x) {
                return this.insert$int$java_lang_String(index, /* valueOf */ new String(x).toString());
            }
            insert$int$char_A$int$int(index, x, offset, len) {
                return this.insert$int$java_lang_String(index, /* valueOf */ ((str, index, len) => str.join('').substring(index, index + len))(x, offset, len));
            }
            insert(index, x, offset, len) {
                if (((typeof index === 'number') || index === null) && ((x != null && x instanceof Array && (x.length == 0 || x[0] == null || (typeof x[0] === 'string'))) || x === null) && ((typeof offset === 'number') || offset === null) && ((typeof len === 'number') || len === null)) {
                    return this.insert$int$char_A$int$int(index, x, offset, len);
                }
                else if (((typeof index === 'number') || index === null) && ((x != null && (x["__interfaces"] != null && x["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || x.constructor != null && x.constructor["__interfaces"] != null && x.constructor["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || typeof x === "string")) || x === null) && ((typeof offset === 'number') || offset === null) && ((typeof len === 'number') || len === null)) {
                    return this.insert$int$java_lang_CharSequence$int$int(index, x, offset, len);
                }
                else if (((typeof index === 'number') || index === null) && ((x != null && x instanceof Array && (x.length == 0 || x[0] == null || (typeof x[0] === 'string'))) || x === null) && offset === undefined && len === undefined) {
                    return this.insert$int$char_A(index, x);
                }
                else if (((typeof index === 'number') || index === null) && ((typeof x === 'string') || x === null) && offset === undefined && len === undefined) {
                    return this.insert$int$java_lang_String(index, x);
                }
                else if (((typeof index === 'number') || index === null) && ((x != null && (x["__interfaces"] != null && x["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || x.constructor != null && x.constructor["__interfaces"] != null && x.constructor["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || typeof x === "string")) || x === null) && offset === undefined && len === undefined) {
                    return this.insert$int$java_lang_CharSequence(index, x);
                }
                else if (((typeof index === 'number') || index === null) && ((typeof x === 'boolean') || x === null) && offset === undefined && len === undefined) {
                    return this.insert$int$boolean(index, x);
                }
                else if (((typeof index === 'number') || index === null) && ((typeof x === 'string') || x === null) && offset === undefined && len === undefined) {
                    return this.insert$int$char(index, x);
                }
                else if (((typeof index === 'number') || index === null) && ((typeof x === 'number') || x === null) && offset === undefined && len === undefined) {
                    return this.insert$int$int(index, x);
                }
                else if (((typeof index === 'number') || index === null) && ((typeof x === 'number') || x === null) && offset === undefined && len === undefined) {
                    return this.insert$int$long(index, x);
                }
                else if (((typeof index === 'number') || index === null) && ((typeof x === 'number') || x === null) && offset === undefined && len === undefined) {
                    return this.insert$int$float(index, x);
                }
                else if (((typeof index === 'number') || index === null) && ((typeof x === 'number') || x === null) && offset === undefined && len === undefined) {
                    return this.insert$int$double(index, x);
                }
                else if (((typeof index === 'number') || index === null) && ((x != null) || x === null) && offset === undefined && len === undefined) {
                    return this.insert$int$java_lang_Object(index, x);
                }
                else
                    throw new Error('invalid overload');
            }
            insert$int$java_lang_CharSequence(index, chars) {
                return this.insert$int$java_lang_String(index, chars.toString());
            }
            insert$int$java_lang_CharSequence$int$int(index, chars, start, end) {
                return this.insert$int$java_lang_String(index, /* subSequence */ chars.substring(start, end).toString());
            }
            insert$int$double(index, x) {
                return this.insert$int$java_lang_String(index, /* valueOf */ new String(x).toString());
            }
            insert$int$float(index, x) {
                return this.insert$int$java_lang_String(index, /* valueOf */ new String(x).toString());
            }
            insert$int$int(index, x) {
                return this.insert$int$java_lang_String(index, /* valueOf */ new String(x).toString());
            }
            insert$int$long(index, x) {
                return this.insert$int$java_lang_String(index, /* valueOf */ new String(x).toString());
            }
            insert$int$java_lang_Object(index, x) {
                return this.insert$int$java_lang_String(index, /* valueOf */ new String(x).toString());
            }
            insert$int$java_lang_String(index, x) {
                this.replace0(index, index, x);
                return this;
            }
            replace(start, end, toInsert) {
                this.replace0(start, end, toInsert);
                return this;
            }
            reverse() {
                this.reverse0();
                return this;
            }
        }
        lang.StringBuffer = StringBuffer;
        StringBuffer["__class"] = "java.lang.StringBuffer";
        StringBuffer["__interfaces"] = ["java.lang.CharSequence", "java.lang.Appendable"];
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
(function (java) {
    var lang;
    (function (lang) {
        /**
         * A fast way to create strings using multiple appends.
         *
         * This class is an exact clone of {@link StringBuffer} except for the name. Any
         * change made to one should be mirrored in the other.
         * @param {*} s
         * @class
         * @extends java.lang.AbstractStringBuilder
         */
        class StringBuilder extends java.lang.AbstractStringBuilder {
            constructor(s) {
                if (((typeof s === 'string') || s === null)) {
                    let __args = arguments;
                    super(s);
                }
                else if (((s != null && (s["__interfaces"] != null && s["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || s.constructor != null && s.constructor["__interfaces"] != null && s.constructor["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || typeof s === "string")) || s === null)) {
                    let __args = arguments;
                    super(/* valueOf */ new String(s).toString());
                }
                else if (((typeof s === 'number') || s === null)) {
                    let __args = arguments;
                    let ignoredCapacity = __args[0];
                    super("");
                }
                else if (s === undefined) {
                    let __args = arguments;
                    super("");
                }
                else
                    throw new Error('invalid overload');
            }
            append$boolean(x) {
                this.string += x;
                return this;
            }
            append$char(x) {
                this.string += new String(x).toString();
                return this;
            }
            append$char_A(x) {
                this.string += new String(x).toString();
                return this;
            }
            append$char_A$int$int(x, start, len) {
                this.string += ((str, index, len) => str.join('').substring(index, index + len))(x, start, len);
                return this;
            }
            append(x, start, len) {
                if (((x != null && x instanceof Array && (x.length == 0 || x[0] == null || (typeof x[0] === 'string'))) || x === null) && ((typeof start === 'number') || start === null) && ((typeof len === 'number') || len === null)) {
                    return this.append$char_A$int$int(x, start, len);
                }
                else if (((x != null && (x["__interfaces"] != null && x["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || x.constructor != null && x.constructor["__interfaces"] != null && x.constructor["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || typeof x === "string")) || x === null) && ((typeof start === 'number') || start === null) && ((typeof len === 'number') || len === null)) {
                    return this.append$java_lang_CharSequence$int$int(x, start, len);
                }
                else if (((x != null && x instanceof Array && (x.length == 0 || x[0] == null || (typeof x[0] === 'string'))) || x === null) && start === undefined && len === undefined) {
                    return this.append$char_A(x);
                }
                else if (((typeof x === 'string') || x === null) && start === undefined && len === undefined) {
                    return this.append$java_lang_String(x);
                }
                else if (((x != null && x instanceof java.lang.StringBuffer) || x === null) && start === undefined && len === undefined) {
                    return this.append$java_lang_StringBuffer(x);
                }
                else if (((x != null && (x["__interfaces"] != null && x["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || x.constructor != null && x.constructor["__interfaces"] != null && x.constructor["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || typeof x === "string")) || x === null) && start === undefined && len === undefined) {
                    return this.append$java_lang_CharSequence(x);
                }
                else if (((typeof x === 'boolean') || x === null) && start === undefined && len === undefined) {
                    return this.append$boolean(x);
                }
                else if (((typeof x === 'string') || x === null) && start === undefined && len === undefined) {
                    return this.append$char(x);
                }
                else if (((typeof x === 'number') || x === null) && start === undefined && len === undefined) {
                    return this.append$int(x);
                }
                else if (((typeof x === 'number') || x === null) && start === undefined && len === undefined) {
                    return this.append$long(x);
                }
                else if (((typeof x === 'number') || x === null) && start === undefined && len === undefined) {
                    return this.append$float(x);
                }
                else if (((typeof x === 'number') || x === null) && start === undefined && len === undefined) {
                    return this.append$double(x);
                }
                else if (((x != null) || x === null) && start === undefined && len === undefined) {
                    return this.append$java_lang_Object(x);
                }
                else
                    throw new Error('invalid overload');
            }
            append$java_lang_CharSequence(x) {
                this.string += x;
                return this;
            }
            append$java_lang_CharSequence$int$int(x, start, end) {
                this.append0(x, start, end);
                return this;
            }
            append$double(x) {
                this.string += x;
                return this;
            }
            append$float(x) {
                this.string += x;
                return this;
            }
            append$int(x) {
                this.string += x;
                return this;
            }
            append$long(x) {
                this.string += x;
                return this;
            }
            append$java_lang_Object(x) {
                this.string += x;
                return this;
            }
            append$java_lang_String(x) {
                this.string += x;
                return this;
            }
            append$java_lang_StringBuffer(x) {
                this.string += x;
                return this;
            }
            appendCodePoint(x) {
                this.appendCodePoint0(x);
                return this;
            }
            delete(start, end) {
                this.replace0(start, end, "");
                return this;
            }
            deleteCharAt(start) {
                this.replace0(start, start + 1, "");
                return this;
            }
            insert$int$boolean(index, x) {
                return this.insert$int$java_lang_String(index, /* valueOf */ new String(x).toString());
            }
            insert$int$char(index, x) {
                this.replace0(index, index, /* valueOf */ new String(x).toString());
                return this;
            }
            insert$int$char_A(index, x) {
                return this.insert$int$java_lang_String(index, /* valueOf */ new String(x).toString());
            }
            insert$int$char_A$int$int(index, x, offset, len) {
                return this.insert$int$java_lang_String(index, /* valueOf */ ((str, index, len) => str.join('').substring(index, index + len))(x, offset, len));
            }
            insert(index, x, offset, len) {
                if (((typeof index === 'number') || index === null) && ((x != null && x instanceof Array && (x.length == 0 || x[0] == null || (typeof x[0] === 'string'))) || x === null) && ((typeof offset === 'number') || offset === null) && ((typeof len === 'number') || len === null)) {
                    return this.insert$int$char_A$int$int(index, x, offset, len);
                }
                else if (((typeof index === 'number') || index === null) && ((x != null && (x["__interfaces"] != null && x["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || x.constructor != null && x.constructor["__interfaces"] != null && x.constructor["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || typeof x === "string")) || x === null) && ((typeof offset === 'number') || offset === null) && ((typeof len === 'number') || len === null)) {
                    return this.insert$int$java_lang_CharSequence$int$int(index, x, offset, len);
                }
                else if (((typeof index === 'number') || index === null) && ((x != null && x instanceof Array && (x.length == 0 || x[0] == null || (typeof x[0] === 'string'))) || x === null) && offset === undefined && len === undefined) {
                    return this.insert$int$char_A(index, x);
                }
                else if (((typeof index === 'number') || index === null) && ((typeof x === 'string') || x === null) && offset === undefined && len === undefined) {
                    return this.insert$int$java_lang_String(index, x);
                }
                else if (((typeof index === 'number') || index === null) && ((x != null && (x["__interfaces"] != null && x["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || x.constructor != null && x.constructor["__interfaces"] != null && x.constructor["__interfaces"].indexOf("java.lang.CharSequence") >= 0 || typeof x === "string")) || x === null) && offset === undefined && len === undefined) {
                    return this.insert$int$java_lang_CharSequence(index, x);
                }
                else if (((typeof index === 'number') || index === null) && ((typeof x === 'boolean') || x === null) && offset === undefined && len === undefined) {
                    return this.insert$int$boolean(index, x);
                }
                else if (((typeof index === 'number') || index === null) && ((typeof x === 'string') || x === null) && offset === undefined && len === undefined) {
                    return this.insert$int$char(index, x);
                }
                else if (((typeof index === 'number') || index === null) && ((typeof x === 'number') || x === null) && offset === undefined && len === undefined) {
                    return this.insert$int$int(index, x);
                }
                else if (((typeof index === 'number') || index === null) && ((typeof x === 'number') || x === null) && offset === undefined && len === undefined) {
                    return this.insert$int$long(index, x);
                }
                else if (((typeof index === 'number') || index === null) && ((typeof x === 'number') || x === null) && offset === undefined && len === undefined) {
                    return this.insert$int$float(index, x);
                }
                else if (((typeof index === 'number') || index === null) && ((typeof x === 'number') || x === null) && offset === undefined && len === undefined) {
                    return this.insert$int$double(index, x);
                }
                else if (((typeof index === 'number') || index === null) && ((x != null) || x === null) && offset === undefined && len === undefined) {
                    return this.insert$int$java_lang_Object(index, x);
                }
                else
                    throw new Error('invalid overload');
            }
            insert$int$java_lang_CharSequence(index, chars) {
                return this.insert$int$java_lang_String(index, chars.toString());
            }
            insert$int$java_lang_CharSequence$int$int(index, chars, start, end) {
                return this.insert$int$java_lang_String(index, /* subSequence */ chars.substring(start, end).toString());
            }
            insert$int$double(index, x) {
                return this.insert$int$java_lang_String(index, /* valueOf */ new String(x).toString());
            }
            insert$int$float(index, x) {
                return this.insert$int$java_lang_String(index, /* valueOf */ new String(x).toString());
            }
            insert$int$int(index, x) {
                return this.insert$int$java_lang_String(index, /* valueOf */ new String(x).toString());
            }
            insert$int$long(index, x) {
                return this.insert$int$java_lang_String(index, /* valueOf */ new String(x).toString());
            }
            insert$int$java_lang_Object(index, x) {
                return this.insert$int$java_lang_String(index, /* valueOf */ new String(x).toString());
            }
            insert$int$java_lang_String(index, x) {
                this.replace0(index, index, x);
                return this;
            }
            replace(start, end, toInsert) {
                this.replace0(start, end, toInsert);
                return this;
            }
            reverse() {
                this.reverse0();
                return this;
            }
        }
        lang.StringBuilder = StringBuilder;
        StringBuilder["__class"] = "java.lang.StringBuilder";
        StringBuilder["__interfaces"] = ["java.lang.CharSequence", "java.lang.Appendable"];
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
(function (java) {
    var io;
    (function (io) {
        /**
         * See <a
         * href="http://java.sun.com/javase/6/docs/api/java/io/IOException.html">the
         * official Java API doc</a> for details.
         * @param {string} message
         * @param {java.lang.Throwable} throwable
         * @class
         * @extends java.lang.Exception
         */
        class IOException extends Error {
            constructor(message, throwable) {
                if (((typeof message === 'string') || message === null) && ((throwable != null && throwable instanceof Error) || throwable === null)) {
                    let __args = arguments;
                    super(message);
                    this.message = message;
                    Object.setPrototypeOf(this, IOException.prototype);
                }
                else if (((typeof message === 'string') || message === null) && throwable === undefined) {
                    let __args = arguments;
                    super(message);
                    this.message = message;
                    Object.setPrototypeOf(this, IOException.prototype);
                }
                else if (((message != null && message instanceof Error) || message === null) && throwable === undefined) {
                    let __args = arguments;
                    let throwable = __args[0];
                    super(throwable);
                    this.message = throwable;
                    Object.setPrototypeOf(this, IOException.prototype);
                }
                else if (message === undefined && throwable === undefined) {
                    let __args = arguments;
                    super();
                    Object.setPrototypeOf(this, IOException.prototype);
                }
                else
                    throw new Error('invalid overload');
            }
        }
        io.IOException = IOException;
        IOException["__class"] = "java.io.IOException";
        IOException["__interfaces"] = ["java.io.Serializable"];
    })(io = java.io || (java.io = {}));
})(java || (java = {}));
(function (java) {
    var lang;
    (function (lang) {
        /**
         * See <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/CloneNotSupportedException.html">
         * the official Java API doc</a> for details.
         * @param {string} msg
         * @class
         * @extends java.lang.Exception
         */
        class CloneNotSupportedException extends Error {
            constructor(msg) {
                if (((typeof msg === 'string') || msg === null)) {
                    let __args = arguments;
                    super(msg);
                    this.message = msg;
                    Object.setPrototypeOf(this, CloneNotSupportedException.prototype);
                }
                else if (msg === undefined) {
                    let __args = arguments;
                    super();
                    Object.setPrototypeOf(this, CloneNotSupportedException.prototype);
                }
                else
                    throw new Error('invalid overload');
            }
        }
        lang.CloneNotSupportedException = CloneNotSupportedException;
        CloneNotSupportedException["__class"] = "java.lang.CloneNotSupportedException";
        CloneNotSupportedException["__interfaces"] = ["java.io.Serializable"];
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
(function (java) {
    var lang;
    (function (lang) {
        /**
         * See <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/NoSuchMethodException.html">the
         * official Java API doc</a> for details.
         *
         * This exception is never thrown by GWT or GWT's libraries, as GWT does not support reflection. It
         * is provided in GWT only for compatibility with user code that explicitly throws or catches it for
         * non-reflection purposes.
         * @param {string} message
         * @class
         * @extends java.lang.Exception
         */
        class NoSuchMethodException extends Error {
            constructor(message) {
                if (((typeof message === 'string') || message === null)) {
                    let __args = arguments;
                    super(message);
                    this.message = message;
                    Object.setPrototypeOf(this, NoSuchMethodException.prototype);
                }
                else if (message === undefined) {
                    let __args = arguments;
                    super();
                    Object.setPrototypeOf(this, NoSuchMethodException.prototype);
                }
                else
                    throw new Error('invalid overload');
            }
        }
        lang.NoSuchMethodException = NoSuchMethodException;
        NoSuchMethodException["__class"] = "java.lang.NoSuchMethodException";
        NoSuchMethodException["__interfaces"] = ["java.io.Serializable"];
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
(function (java) {
    var lang;
    (function (lang) {
        /**
         * See <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/RuntimeException.html">the
         * official Java API doc</a> for details.
         * @param {string} message
         * @param {java.lang.Throwable} cause
         * @class
         * @extends java.lang.Exception
         */
        class RuntimeException extends Error {
            constructor(message, cause, enableSuppression, writableStackTrace) {
                if (((typeof message === 'string') || message === null) && ((cause != null && cause instanceof Error) || cause === null) && ((typeof enableSuppression === 'boolean') || enableSuppression === null) && ((typeof writableStackTrace === 'boolean') || writableStackTrace === null)) {
                    let __args = arguments;
                    super(message);
                    this.message = message;
                    Object.setPrototypeOf(this, RuntimeException.prototype);
                }
                else if (((typeof message === 'string') || message === null) && ((cause != null && cause instanceof Error) || cause === null) && enableSuppression === undefined && writableStackTrace === undefined) {
                    let __args = arguments;
                    super(message);
                    this.message = message;
                    Object.setPrototypeOf(this, RuntimeException.prototype);
                }
                else if (((typeof message === 'string') || message === null) && cause === undefined && enableSuppression === undefined && writableStackTrace === undefined) {
                    let __args = arguments;
                    super(message);
                    this.message = message;
                    Object.setPrototypeOf(this, RuntimeException.prototype);
                }
                else if (((message != null && message instanceof Error) || message === null) && cause === undefined && enableSuppression === undefined && writableStackTrace === undefined) {
                    let __args = arguments;
                    let cause = __args[0];
                    super(cause);
                    this.message = cause;
                    Object.setPrototypeOf(this, RuntimeException.prototype);
                }
                else if (message === undefined && cause === undefined && enableSuppression === undefined && writableStackTrace === undefined) {
                    let __args = arguments;
                    super();
                    Object.setPrototypeOf(this, RuntimeException.prototype);
                }
                else
                    throw new Error('invalid overload');
            }
        }
        lang.RuntimeException = RuntimeException;
        RuntimeException["__class"] = "java.lang.RuntimeException";
        RuntimeException["__interfaces"] = ["java.io.Serializable"];
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
(function (java) {
    var security;
    (function (security) {
        /**
         * A generic security exception type - <a
         * href="http://java.sun.com/j2se/1.4.2/docs/api/java/security/GeneralSecurityException.html">[Sun's
         * docs]</a>.
         * @param {string} msg
         * @class
         * @extends java.lang.Exception
         */
        class GeneralSecurityException extends Error {
            constructor(msg) {
                if (((typeof msg === 'string') || msg === null)) {
                    let __args = arguments;
                    super(msg);
                    this.message = msg;
                    Object.setPrototypeOf(this, GeneralSecurityException.prototype);
                }
                else if (msg === undefined) {
                    let __args = arguments;
                    super();
                    Object.setPrototypeOf(this, GeneralSecurityException.prototype);
                }
                else
                    throw new Error('invalid overload');
            }
        }
        security.GeneralSecurityException = GeneralSecurityException;
        GeneralSecurityException["__class"] = "java.security.GeneralSecurityException";
        GeneralSecurityException["__interfaces"] = ["java.io.Serializable"];
    })(security = java.security || (java.security = {}));
})(java || (java = {}));
(function (java) {
    var text;
    (function (text) {
        /**
         * Emulation of {@code java.text.ParseException}.
         * @param {string} s
         * @param {number} errorOffset
         * @class
         * @extends java.lang.Exception
         */
        class ParseException extends Error {
            constructor(s, errorOffset) {
                super(s);
                this.message = s;
                Object.setPrototypeOf(this, ParseException.prototype);
                if (this.errorOffset === undefined)
                    this.errorOffset = 0;
                this.errorOffset = errorOffset;
            }
            getErrorOffset() {
                return this.errorOffset;
            }
        }
        text.ParseException = ParseException;
        ParseException["__class"] = "java.text.ParseException";
        ParseException["__interfaces"] = ["java.io.Serializable"];
    })(text = java.text || (java.text = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        /**
         * Thrown when the subject of an observer cannot support additional observers.
         *
         * @param {string} message
         * @class
         * @extends java.lang.Exception
         */
        class TooManyListenersException extends Error {
            constructor(message) {
                if (((typeof message === 'string') || message === null)) {
                    let __args = arguments;
                    super(message);
                    this.message = message;
                    Object.setPrototypeOf(this, TooManyListenersException.prototype);
                }
                else if (message === undefined) {
                    let __args = arguments;
                    super();
                    Object.setPrototypeOf(this, TooManyListenersException.prototype);
                }
                else
                    throw new Error('invalid overload');
            }
        }
        util.TooManyListenersException = TooManyListenersException;
        TooManyListenersException["__class"] = "java.util.TooManyListenersException";
        TooManyListenersException["__interfaces"] = ["java.io.Serializable"];
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var lang;
    (function (lang) {
        var ref;
        (function (ref) {
            /**
             * This implements the reference API in a minimal way. In JavaScript, there is
             * no control over the reference and the GC. So this implementation's only
             * purpose is for compilation.
             * @param {*} referent
             * @class
             * @extends java.lang.ref.Reference
             */
            class WeakReference extends java.lang.ref.Reference {
                constructor(referent) {
                    super(referent);
                }
            }
            ref.WeakReference = WeakReference;
            WeakReference["__class"] = "java.lang.ref.WeakReference";
        })(ref = lang.ref || (lang.ref = {}));
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
(function (java) {
    var lang;
    (function (lang) {
        /**
         * Constructs an {@code InternalError} with the specified detail
         * message and cause.  <p>Note that the detail message associated
         * with {@code cause} is <i>not</i> automatically incorporated in
         * this error's detail message.
         *
         * @param  {string} message the detail message (which is saved for later retrieval
         * by the {@link #getMessage()} method).
         * @param  {java.lang.Throwable} cause the cause (which is saved for later retrieval by the
         * {@link #getCause()} method).  (A {@code null} value is
         * permitted, and indicates that the cause is nonexistent or
         * unknown.)
         * @since  1.8
         * @class
         * @extends java.lang.VirtualMachineError
         * @author  unascribed
         */
        class InternalError extends java.lang.VirtualMachineError {
            constructor(message, cause) {
                if (((typeof message === 'string') || message === null) && ((cause != null && cause instanceof Error) || cause === null)) {
                    let __args = arguments;
                    super(message, cause);
                    Object.setPrototypeOf(this, InternalError.prototype);
                }
                else if (((typeof message === 'string') || message === null) && cause === undefined) {
                    let __args = arguments;
                    super(message);
                    Object.setPrototypeOf(this, InternalError.prototype);
                }
                else if (((message != null && message instanceof Error) || message === null) && cause === undefined) {
                    let __args = arguments;
                    let cause = __args[0];
                    super(cause);
                    Object.setPrototypeOf(this, InternalError.prototype);
                }
                else if (message === undefined && cause === undefined) {
                    let __args = arguments;
                    super();
                    Object.setPrototypeOf(this, InternalError.prototype);
                }
                else
                    throw new Error('invalid overload');
            }
        }
        InternalError.__java_lang_InternalError_serialVersionUID = -9062593416125562365;
        lang.InternalError = InternalError;
        InternalError["__class"] = "java.lang.InternalError";
        InternalError["__interfaces"] = ["java.io.Serializable"];
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
(function (java) {
    var nio;
    (function (nio) {
        class ByteBuffer extends java.nio.Buffer {
            constructor(_buffer, readOnly) {
                super((_buffer.byteLength | 0), readOnly);
                this._order = java.nio.ByteOrder.BIG_ENDIAN_$LI$();
                if (this._buffer === undefined)
                    this._buffer = null;
                if (this._array === undefined)
                    this._array = null;
                if (this._data === undefined)
                    this._data = null;
                this._buffer = _buffer;
                this._array = new Int8Array(_buffer);
                this._data = new DataView(_buffer);
            }
            static allocate(capacity) {
                return new ByteBuffer(new ArrayBuffer(capacity), false);
            }
            /**
             *
             * @return {Array}
             */
            array() {
                return (this._array);
            }
            asReadOnlyBuffer() {
                let byteBuffer = new ByteBuffer(this._buffer, true);
                byteBuffer.limit$int(this.limit());
                byteBuffer.position$int(this.position());
                byteBuffer._mark = this._mark;
                return byteBuffer;
            }
            compact() {
                if (this.isReadOnly())
                    throw new java.nio.ReadOnlyBufferException();
                let current = this.position();
                for (let i = current; i < this.limit(); ++i) {
                    {
                        this.put$int$byte(i - current, this.get$int(i));
                    }
                    ;
                }
                this.position$int(this.limit() - this.position());
                this.limit$int(this.capacity());
                this._mark = -1;
                return this;
            }
            compareTo$java_nio_ByteBuffer(byteBuffer) {
                return this._array.toString().localeCompare(byteBuffer.toString());
            }
            /**
             *
             * @param {java.nio.ByteBuffer} byteBuffer
             * @return {number}
             */
            compareTo(byteBuffer) {
                if (((byteBuffer != null && byteBuffer instanceof java.nio.ByteBuffer) || byteBuffer === null)) {
                    return this.compareTo$java_nio_ByteBuffer(byteBuffer);
                }
                else
                    throw new Error('invalid overload');
            }
            duplicate() {
                let byteBuffer = new ByteBuffer(this._buffer, this.isReadOnly());
                byteBuffer.limit$int(this.limit());
                byteBuffer.position$int(this.position());
                byteBuffer._mark = this._mark;
                return byteBuffer;
            }
            /**
             *
             * @param {*} o
             * @return {boolean}
             */
            equals(o) {
                return this === o || (o != null && o instanceof java.nio.ByteBuffer) && java.util.Objects.equals(this._array, o._array);
            }
            get$() {
                if (this.position() === this.limit())
                    throw new java.nio.BufferUnderflowException();
                let b = (this._array[this.position()]);
                this.position$int(this.position() + 1);
                return b;
            }
            get$byte_A(dest) {
                return this.get$byte_A$int$int(dest, 0, dest.length);
            }
            get$byte_A$int$int(dest, offset, length) {
                if (this.remaining() < length)
                    throw new java.nio.BufferUnderflowException();
                for (let i = offset; i < offset + length; i++) {
                    dest[i] = this.get();
                }
                return this;
            }
            get(dest, offset, length) {
                if (((dest != null && dest instanceof Array && (dest.length == 0 || dest[0] == null || (typeof dest[0] === 'number'))) || dest === null) && ((typeof offset === 'number') || offset === null) && ((typeof length === 'number') || length === null)) {
                    return this.get$byte_A$int$int(dest, offset, length);
                }
                else if (((dest != null && dest instanceof Array && (dest.length == 0 || dest[0] == null || (typeof dest[0] === 'number'))) || dest === null) && offset === undefined && length === undefined) {
                    return this.get$byte_A(dest);
                }
                else if (((typeof dest === 'number') || dest === null) && offset === undefined && length === undefined) {
                    return this.get$int(dest);
                }
                else if (dest === undefined && offset === undefined && length === undefined) {
                    return this.get$();
                }
                else
                    throw new Error('invalid overload');
            }
            get$int(from) {
                if (from < 0 || from > this.limit())
                    throw new java.lang.IndexOutOfBoundsException();
                return (this._array[from]);
            }
            getChar$() {
                if (this.remaining() < 2)
                    throw new java.nio.BufferUnderflowException();
                let res = (String.fromCharCode((this._data.getInt16(this.position(), this._order === java.nio.ByteOrder.LITTLE_ENDIAN_$LI$()) | 0))).charAt(0);
                this.position$int(this.position() + 2);
                return res;
            }
            getChar$int(from) {
                if (from < 0 || from > this.limit() - 1)
                    throw new java.lang.IndexOutOfBoundsException();
                return (String.fromCharCode((this._data.getInt16(from, this._order === java.nio.ByteOrder.LITTLE_ENDIAN_$LI$()) | 0))).charAt(0);
            }
            getChar(from) {
                if (((typeof from === 'number') || from === null)) {
                    return this.getChar$int(from);
                }
                else if (from === undefined) {
                    return this.getChar$();
                }
                else
                    throw new Error('invalid overload');
            }
            getDouble$() {
                if (this.remaining() < 8)
                    throw new java.nio.BufferUnderflowException();
                let res = this._data.getFloat64(this.position(), this._order === java.nio.ByteOrder.LITTLE_ENDIAN_$LI$());
                this.position$int(this.position() + 8);
                return res;
            }
            getDouble$int(from) {
                if (from < 0 || from > this.limit() - 7)
                    throw new java.lang.IndexOutOfBoundsException();
                return this._data.getFloat64(from, this._order === java.nio.ByteOrder.LITTLE_ENDIAN_$LI$());
            }
            getDouble(from) {
                if (((typeof from === 'number') || from === null)) {
                    return this.getDouble$int(from);
                }
                else if (from === undefined) {
                    return this.getDouble$();
                }
                else
                    throw new Error('invalid overload');
            }
            getFloat$() {
                if (this.remaining() < 4)
                    throw new java.nio.BufferUnderflowException();
                let res = (this._data.getFloat32(this.position(), this._order === java.nio.ByteOrder.LITTLE_ENDIAN_$LI$()));
                this.position$int(this.position() + 4);
                return res;
            }
            getFloat$int(from) {
                if (from < 0 || from > this.limit() - 3)
                    throw new java.lang.IndexOutOfBoundsException();
                return (this._data.getFloat32(from, this._order === java.nio.ByteOrder.LITTLE_ENDIAN_$LI$()));
            }
            getFloat(from) {
                if (((typeof from === 'number') || from === null)) {
                    return this.getFloat$int(from);
                }
                else if (from === undefined) {
                    return this.getFloat$();
                }
                else
                    throw new Error('invalid overload');
            }
            getInt$() {
                if (this.remaining() < 4)
                    throw new java.nio.BufferUnderflowException();
                let res = (this._data.getInt32(this.position(), this._order === java.nio.ByteOrder.LITTLE_ENDIAN_$LI$()));
                this.position$int(this.position() + 4);
                return res;
            }
            getInt$int(from) {
                if (from < 0 || from > this.limit() - 3)
                    throw new java.lang.IndexOutOfBoundsException();
                return (this._data.getInt32(from, this._order === java.nio.ByteOrder.LITTLE_ENDIAN_$LI$()));
            }
            getInt(from) {
                if (((typeof from === 'number') || from === null)) {
                    return this.getInt$int(from);
                }
                else if (from === undefined) {
                    return this.getInt$();
                }
                else
                    throw new Error('invalid overload');
            }
            getLong$() {
                if (this.remaining() < 8)
                    throw new java.nio.BufferUnderflowException();
                let res1 = (this._data.getInt32(this.position(), this._order === java.nio.ByteOrder.LITTLE_ENDIAN_$LI$()));
                let res2 = (this._data.getInt32(this.position() + 4, this._order === java.nio.ByteOrder.LITTLE_ENDIAN_$LI$()));
                if (this._order === java.nio.ByteOrder.LITTLE_ENDIAN_$LI$()) {
                    let tmp = res1;
                    res1 = res2;
                    res2 = tmp;
                }
                this.position$int(this.position() + 8);
                return res1 * 4294967296 + res2;
            }
            getLong$int(from) {
                if (from < 0 || from > this.limit() - 7)
                    throw new java.lang.IndexOutOfBoundsException();
                let res1 = (this._data.getInt32(from, this._order === java.nio.ByteOrder.LITTLE_ENDIAN_$LI$()));
                let res2 = (this._data.getInt32(from + 4, this._order === java.nio.ByteOrder.LITTLE_ENDIAN_$LI$()));
                if (this._order === java.nio.ByteOrder.LITTLE_ENDIAN_$LI$()) {
                    let tmp = res1;
                    res1 = res2;
                    res2 = tmp;
                }
                return res1 * 4294967296 + res2;
            }
            getLong(from) {
                if (((typeof from === 'number') || from === null)) {
                    return this.getLong$int(from);
                }
                else if (from === undefined) {
                    return this.getLong$();
                }
                else
                    throw new Error('invalid overload');
            }
            getShort$() {
                if (this.remaining() < 2)
                    throw new java.nio.BufferUnderflowException();
                let res = (this._data.getInt16(this.position(), this._order === java.nio.ByteOrder.LITTLE_ENDIAN_$LI$()));
                this.position$int(this.position() + 2);
                return res;
            }
            getShort$int(from) {
                if (from < 0 || from > this.limit() - 1)
                    throw new java.lang.IndexOutOfBoundsException();
                return (this._data.getInt16(from, this._order === java.nio.ByteOrder.LITTLE_ENDIAN_$LI$()));
            }
            getShort(from) {
                if (((typeof from === 'number') || from === null)) {
                    return this.getShort$int(from);
                }
                else if (from === undefined) {
                    return this.getShort$();
                }
                else
                    throw new Error('invalid overload');
            }
            order$() {
                return this._order;
            }
            order$java_nio_ByteOrder(newOrder) {
                this._order = newOrder;
                return this;
            }
            order(newOrder) {
                if (((newOrder != null && newOrder instanceof java.nio.ByteOrder) || newOrder === null)) {
                    return this.order$java_nio_ByteOrder(newOrder);
                }
                else if (newOrder === undefined) {
                    return this.order$();
                }
                else
                    throw new Error('invalid overload');
            }
            put$byte(b) {
                if (this.isReadOnly())
                    throw new java.nio.ReadOnlyBufferException();
                if (this.position() === this.limit())
                    throw new java.nio.BufferOverflowException();
                this._array.set(this.position(), b);
                this.position$int(this.position() + 1);
                return this;
            }
            put$byte_A(src) {
                return this.put$byte_A$int$int(src, 0, src.length);
            }
            put$byte_A$int$int(src, offset, length) {
                if (this.isReadOnly())
                    throw new java.nio.ReadOnlyBufferException();
                if (this.remaining() < length)
                    throw new java.nio.BufferOverflowException();
                for (let i = offset; i < offset + length; i++) {
                    this.put$byte(src[i]);
                }
                return this;
            }
            put(src, offset, length) {
                if (((src != null && src instanceof Array && (src.length == 0 || src[0] == null || (typeof src[0] === 'number'))) || src === null) && ((typeof offset === 'number') || offset === null) && ((typeof length === 'number') || length === null)) {
                    return this.put$byte_A$int$int(src, offset, length);
                }
                else if (((typeof src === 'number') || src === null) && ((typeof offset === 'number') || offset === null) && length === undefined) {
                    return this.put$int$byte(src, offset);
                }
                else if (((src != null && src instanceof Array && (src.length == 0 || src[0] == null || (typeof src[0] === 'number'))) || src === null) && offset === undefined && length === undefined) {
                    return this.put$byte_A(src);
                }
                else if (((typeof src === 'number') || src === null) && offset === undefined && length === undefined) {
                    return this.put$byte(src);
                }
                else
                    throw new Error('invalid overload');
            }
            put$int$byte(to, b) {
                if (this.isReadOnly())
                    throw new java.nio.ReadOnlyBufferException();
                if (to < 0 || to > this.limit())
                    throw new java.lang.IndexOutOfBoundsException();
                this._array.set(to, b);
                return this;
            }
            putChar$char(value) {
                if (this.isReadOnly())
                    throw new java.nio.ReadOnlyBufferException();
                if (this.remaining() < 2)
                    throw new java.nio.BufferOverflowException();
                this._data.setInt16(this.position(), (value).charCodeAt(0), this._order === java.nio.ByteOrder.LITTLE_ENDIAN_$LI$());
                this.position$int(this.position() + 2);
                return this;
            }
            putChar$int$char(to, value) {
                if (this.isReadOnly())
                    throw new java.nio.ReadOnlyBufferException();
                if (to < 0 || to > this.limit() - 1)
                    throw new java.lang.IndexOutOfBoundsException();
                this._data.setInt16(to, (value).charCodeAt(0), this._order === java.nio.ByteOrder.LITTLE_ENDIAN_$LI$());
                return this;
            }
            putChar(to, value) {
                if (((typeof to === 'number') || to === null) && ((typeof value === 'string') || value === null)) {
                    return this.putChar$int$char(to, value);
                }
                else if (((typeof to === 'string') || to === null) && value === undefined) {
                    return this.putChar$char(to);
                }
                else
                    throw new Error('invalid overload');
            }
            putDouble$double(value) {
                if (this.isReadOnly())
                    throw new java.nio.ReadOnlyBufferException();
                if (this.remaining() < 8)
                    throw new java.nio.BufferOverflowException();
                this._data.setFloat64(this.position(), value, this._order === java.nio.ByteOrder.LITTLE_ENDIAN_$LI$());
                this.position$int(this.position() + 8);
                return this;
            }
            putDouble$int$double(to, value) {
                if (this.isReadOnly())
                    throw new java.nio.ReadOnlyBufferException();
                if (to < 0 || to > this.limit() - 7)
                    throw new java.lang.IndexOutOfBoundsException();
                this._data.setFloat64(to, value, this._order === java.nio.ByteOrder.LITTLE_ENDIAN_$LI$());
                return this;
            }
            putDouble(to, value) {
                if (((typeof to === 'number') || to === null) && ((typeof value === 'number') || value === null)) {
                    return this.putDouble$int$double(to, value);
                }
                else if (((typeof to === 'number') || to === null) && value === undefined) {
                    return this.putDouble$double(to);
                }
                else
                    throw new Error('invalid overload');
            }
            putFloat$float(value) {
                if (this.isReadOnly())
                    throw new java.nio.ReadOnlyBufferException();
                if (this.remaining() < 4)
                    throw new java.nio.BufferOverflowException();
                this._data.setFloat32(this.position(), value, this._order === java.nio.ByteOrder.LITTLE_ENDIAN_$LI$());
                this.position$int(this.position() + 4);
                return this;
            }
            putFloat$int$float(to, value) {
                if (this.isReadOnly())
                    throw new java.nio.ReadOnlyBufferException();
                if (to < 0 || to > this.limit() - 3)
                    throw new java.lang.IndexOutOfBoundsException();
                this._data.setFloat32(to, value, this._order === java.nio.ByteOrder.LITTLE_ENDIAN_$LI$());
                return this;
            }
            putFloat(to, value) {
                if (((typeof to === 'number') || to === null) && ((typeof value === 'number') || value === null)) {
                    return this.putFloat$int$float(to, value);
                }
                else if (((typeof to === 'number') || to === null) && value === undefined) {
                    return this.putFloat$float(to);
                }
                else
                    throw new Error('invalid overload');
            }
            putInt$int(value) {
                if (this.isReadOnly())
                    throw new java.nio.ReadOnlyBufferException();
                if (this.remaining() < 4)
                    throw new java.nio.BufferOverflowException();
                this._data.setInt32(this.position(), value, this._order === java.nio.ByteOrder.LITTLE_ENDIAN_$LI$());
                this.position$int(this.position() + 4);
                return this;
            }
            putInt$int$int(to, value) {
                if (this.isReadOnly())
                    throw new java.nio.ReadOnlyBufferException();
                if (to < 0 || to > this.limit() - 3)
                    throw new java.lang.IndexOutOfBoundsException();
                this._data.setInt32(to, value, this._order === java.nio.ByteOrder.LITTLE_ENDIAN_$LI$());
                return this;
            }
            putInt(to, value) {
                if (((typeof to === 'number') || to === null) && ((typeof value === 'number') || value === null)) {
                    return this.putInt$int$int(to, value);
                }
                else if (((typeof to === 'number') || to === null) && value === undefined) {
                    return this.putInt$int(to);
                }
                else
                    throw new Error('invalid overload');
            }
            putLong$long(value) {
                if (this.isReadOnly())
                    throw new java.nio.ReadOnlyBufferException();
                if (this.remaining() < 8)
                    throw new java.nio.BufferOverflowException();
                let big = (((n => n < 0 ? Math.ceil(n) : Math.floor(n))(value / 4294967296)) | 0);
                let small = ((value % 4294967296) | 0);
                if (this._order === java.nio.ByteOrder.LITTLE_ENDIAN_$LI$()) {
                    let tmp = big;
                    big = small;
                    small = tmp;
                }
                this._data.setInt32(this.position(), big, this._order === java.nio.ByteOrder.LITTLE_ENDIAN_$LI$());
                this._data.setInt32(this.position() + 4, small, this._order === java.nio.ByteOrder.LITTLE_ENDIAN_$LI$());
                this.position$int(this.position() + 8);
                return this;
            }
            putLong$int$long(to, value) {
                if (this.isReadOnly())
                    throw new java.nio.ReadOnlyBufferException();
                if (to < 0 || to > this.limit() - 7)
                    throw new java.lang.IndexOutOfBoundsException();
                let big = (((n => n < 0 ? Math.ceil(n) : Math.floor(n))(value / 4294967296)) | 0);
                let small = ((value % 4294967296) | 0);
                if (this._order === java.nio.ByteOrder.LITTLE_ENDIAN_$LI$()) {
                    let tmp = big;
                    big = small;
                    small = tmp;
                }
                this._data.setInt32(to, big, this._order === java.nio.ByteOrder.LITTLE_ENDIAN_$LI$());
                this._data.setInt32(to + 4, small, this._order === java.nio.ByteOrder.LITTLE_ENDIAN_$LI$());
                return this;
            }
            putLong(to, value) {
                if (((typeof to === 'number') || to === null) && ((typeof value === 'number') || value === null)) {
                    return this.putLong$int$long(to, value);
                }
                else if (((typeof to === 'number') || to === null) && value === undefined) {
                    return this.putLong$long(to);
                }
                else
                    throw new Error('invalid overload');
            }
            putShort$short(value) {
                if (this.isReadOnly())
                    throw new java.nio.ReadOnlyBufferException();
                if (this.remaining() < 2)
                    throw new java.nio.BufferOverflowException();
                this._data.setInt16(this.position(), value, this._order === java.nio.ByteOrder.LITTLE_ENDIAN_$LI$());
                this.position$int(this.position() + 2);
                return this;
            }
            putShort$int$short(to, value) {
                if (this.isReadOnly())
                    throw new java.nio.ReadOnlyBufferException();
                if (to < 0 || to > this.limit() - 1)
                    throw new java.lang.IndexOutOfBoundsException();
                this._data.setInt16(to, value, this._order === java.nio.ByteOrder.LITTLE_ENDIAN_$LI$());
                return this;
            }
            putShort(to, value) {
                if (((typeof to === 'number') || to === null) && ((typeof value === 'number') || value === null)) {
                    return this.putShort$int$short(to, value);
                }
                else if (((typeof to === 'number') || to === null) && value === undefined) {
                    return this.putShort$short(to);
                }
                else
                    throw new Error('invalid overload');
            }
            slice() {
                return new ByteBuffer(this._buffer, this.isReadOnly());
            }
            /**
             *
             * @return {number}
             */
            hashCode() {
                return java.util.Objects.hash(this._array);
            }
            static wrap$byte_A(array) {
                return ByteBuffer.wrap$byte_A$int$int(array, 0, array.length);
            }
            static wrap$byte_A$int$int(array, offset, length) {
                let buffer = new ArrayBuffer(length);
                let bytes = new Int8Array(buffer);
                bytes.set(Int8Array.from((array).slice(offset, offset + length)));
                return new ByteBuffer(buffer, true);
            }
            static wrap(array, offset, length) {
                if (((array != null && array instanceof Array && (array.length == 0 || array[0] == null || (typeof array[0] === 'number'))) || array === null) && ((typeof offset === 'number') || offset === null) && ((typeof length === 'number') || length === null)) {
                    return java.nio.ByteBuffer.wrap$byte_A$int$int(array, offset, length);
                }
                else if (((array != null && array instanceof ArrayBuffer) || array === null) && ((typeof offset === 'number') || offset === null) && ((typeof length === 'number') || length === null)) {
                    return java.nio.ByteBuffer.wrap$def_js_ArrayBuffer$int$double(array, offset, length);
                }
                else if (((array != null && array instanceof Array && (array.length == 0 || array[0] == null || (typeof array[0] === 'number'))) || array === null) && offset === undefined && length === undefined) {
                    return java.nio.ByteBuffer.wrap$byte_A(array);
                }
                else if (((array != null && array instanceof ArrayBuffer) || array === null) && offset === undefined && length === undefined) {
                    return java.nio.ByteBuffer.wrap$def_js_ArrayBuffer(array);
                }
                else
                    throw new Error('invalid overload');
            }
            static wrap$def_js_ArrayBuffer(array) {
                return ByteBuffer.wrap$def_js_ArrayBuffer$int$double(array, 0, array.byteLength);
            }
            /*private*/ static wrap$def_js_ArrayBuffer$int$double(array, offset, length) {
                return new ByteBuffer(array.slice(offset, offset + length), false);
            }
        }
        nio.ByteBuffer = ByteBuffer;
        ByteBuffer["__class"] = "java.nio.ByteBuffer";
        ByteBuffer["__interfaces"] = ["java.lang.Comparable"];
    })(nio = java.nio || (java.nio = {}));
})(java || (java = {}));
(function (javaemul) {
    var internal;
    (function (internal) {
        /**
         * Provides Charset implementations.
         * @param {string} name
         * @class
         * @extends java.nio.charset.Charset
         */
        class EmulatedCharset extends java.nio.charset.Charset {
            constructor(name) {
                super(name, null);
            }
            static UTF_8_$LI$() { if (EmulatedCharset.UTF_8 == null)
                EmulatedCharset.UTF_8 = new EmulatedCharset.UtfCharset("UTF-8"); return EmulatedCharset.UTF_8; }
            ;
            static ISO_LATIN_1_$LI$() { if (EmulatedCharset.ISO_LATIN_1 == null)
                EmulatedCharset.ISO_LATIN_1 = new EmulatedCharset.LatinCharset("ISO-LATIN-1"); return EmulatedCharset.ISO_LATIN_1; }
            ;
            static ISO_8859_1_$LI$() { if (EmulatedCharset.ISO_8859_1 == null)
                EmulatedCharset.ISO_8859_1 = new EmulatedCharset.LatinCharset("ISO-8859-1"); return EmulatedCharset.ISO_8859_1; }
            ;
        }
        internal.EmulatedCharset = EmulatedCharset;
        EmulatedCharset["__class"] = "javaemul.internal.EmulatedCharset";
        EmulatedCharset["__interfaces"] = ["java.lang.Comparable"];
        (function (EmulatedCharset) {
            class LatinCharset extends javaemul.internal.EmulatedCharset {
                constructor(name) {
                    super(name);
                }
                /**
                 *
                 * @param {string} str
                 * @return {Array}
                 */
                getBytes(str) {
                    let n = str.length;
                    let bytes = (s => { let a = []; while (s-- > 0)
                        a.push(0); return a; })(n);
                    for (let i = 0; i < n; ++i) {
                        {
                            bytes[i] = (((c => c.charCodeAt == null ? c : c.charCodeAt(0))(str.charAt(i)) & 255) | 0);
                        }
                        ;
                    }
                    return bytes;
                }
                /**
                 *
                 * @param {Array} bytes
                 * @param {number} ofs
                 * @param {number} len
                 * @return {Array}
                 */
                decodeString(bytes, ofs, len) {
                    let chars = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(len);
                    for (let i = 0; i < len; ++i) {
                        {
                            chars[i] = String.fromCharCode((bytes[ofs + i] & 255));
                        }
                        ;
                    }
                    return chars;
                }
            }
            EmulatedCharset.LatinCharset = LatinCharset;
            LatinCharset["__class"] = "javaemul.internal.EmulatedCharset.LatinCharset";
            LatinCharset["__interfaces"] = ["java.lang.Comparable"];
            class UtfCharset extends javaemul.internal.EmulatedCharset {
                constructor(name) {
                    super(name);
                }
                /**
                 *
                 * @param {Array} bytes
                 * @param {number} ofs
                 * @param {number} len
                 * @return {Array}
                 */
                decodeString(bytes, ofs, len) {
                    let charCount = 0;
                    for (let i = 0; i < len;) {
                        {
                            ++charCount;
                            let ch = bytes[ofs + i];
                            if ((ch & 192) === 128) {
                                throw new java.lang.IllegalArgumentException("Invalid UTF8 sequence");
                            }
                            else if ((ch & 128) === 0) {
                                ++i;
                            }
                            else if ((ch & 224) === 192) {
                                i += 2;
                            }
                            else if ((ch & 240) === 224) {
                                i += 3;
                            }
                            else if ((ch & 248) === 240) {
                                i += 4;
                            }
                            else {
                                throw new java.lang.IllegalArgumentException("Invalid UTF8 sequence");
                            }
                            if (i > len) {
                                throw new java.lang.IndexOutOfBoundsException("Invalid UTF8 sequence");
                            }
                        }
                        ;
                    }
                    let chars = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(charCount);
                    let outIdx = 0;
                    let count = 0;
                    for (let i = 0; i < len;) {
                        {
                            let ch = bytes[ofs + i++];
                            if ((ch & 128) === 0) {
                                count = 1;
                                ch &= 127;
                            }
                            else if ((ch & 224) === 192) {
                                count = 2;
                                ch &= 31;
                            }
                            else if ((ch & 240) === 224) {
                                count = 3;
                                ch &= 15;
                            }
                            else if ((ch & 248) === 240) {
                                count = 4;
                                ch &= 7;
                            }
                            else if ((ch & 252) === 248) {
                                count = 5;
                                ch &= 3;
                            }
                            while ((--count > 0)) {
                                {
                                    let b = bytes[ofs + i++];
                                    if ((b & 192) !== 128) {
                                        throw new java.lang.IllegalArgumentException("Invalid UTF8 sequence at " + (ofs + i - 1) + ", byte=" + javaemul.internal.IntegerHelper.toHexString(b));
                                    }
                                    ch = (ch << 6) | (b & 63);
                                }
                            }
                            ;
                            outIdx += javaemul.internal.CharacterHelper.toChars$int$char_A$int(ch, chars, outIdx);
                        }
                        ;
                    }
                    return chars;
                }
                /**
                 *
                 * @param {string} str
                 * @return {Array}
                 */
                getBytes(str) {
                    let n = str.length;
                    let byteCount = 0;
                    for (let i = 0; i < n;) {
                        {
                            let ch = str.charCodeAt(i);
                            i += javaemul.internal.CharacterHelper.charCount(ch);
                            if (ch < (1 << 7)) {
                                byteCount++;
                            }
                            else if (ch < (1 << 11)) {
                                byteCount += 2;
                            }
                            else if (ch < (1 << 16)) {
                                byteCount += 3;
                            }
                            else if (ch < (1 << 21)) {
                                byteCount += 4;
                            }
                            else if (ch < (1 << 26)) {
                                byteCount += 5;
                            }
                        }
                        ;
                    }
                    let bytes = (s => { let a = []; while (s-- > 0)
                        a.push(0); return a; })(byteCount);
                    let out = 0;
                    for (let i = 0; i < n;) {
                        {
                            let ch = str.charCodeAt(i);
                            i += javaemul.internal.CharacterHelper.charCount(ch);
                            out += this.encodeUtf8(bytes, out, ch);
                        }
                        ;
                    }
                    return bytes;
                }
                /**
                 * Encode a single character in UTF8.
                 *
                 * @param {Array} bytes byte array to store character in
                 * @param {number} ofs offset into byte array to store first byte
                 * @param {number} codePoint character to encode
                 * @return {number} number of bytes consumed by encoding the character
                 * @throws IllegalArgumentException if codepoint >= 2^26
                 * @private
                 */
                encodeUtf8(bytes, ofs, codePoint) {
                    if (codePoint < (1 << 7)) {
                        bytes[ofs] = ((codePoint & 127) | 0);
                        return 1;
                    }
                    else if (codePoint < (1 << 11)) {
                        bytes[ofs++] = ((((codePoint >> 6) & 31) | 192) | 0);
                        bytes[ofs] = (((codePoint & 63) | 128) | 0);
                        return 2;
                    }
                    else if (codePoint < (1 << 16)) {
                        bytes[ofs++] = ((((codePoint >> 12) & 15) | 224) | 0);
                        bytes[ofs++] = ((((codePoint >> 6) & 63) | 128) | 0);
                        bytes[ofs] = (((codePoint & 63) | 128) | 0);
                        return 3;
                    }
                    else if (codePoint < (1 << 21)) {
                        bytes[ofs++] = ((((codePoint >> 18) & 7) | 240) | 0);
                        bytes[ofs++] = ((((codePoint >> 12) & 63) | 128) | 0);
                        bytes[ofs++] = ((((codePoint >> 6) & 63) | 128) | 0);
                        bytes[ofs] = (((codePoint & 63) | 128) | 0);
                        return 4;
                    }
                    else if (codePoint < (1 << 26)) {
                        bytes[ofs++] = ((((codePoint >> 24) & 3) | 248) | 0);
                        bytes[ofs++] = ((((codePoint >> 18) & 63) | 128) | 0);
                        bytes[ofs++] = ((((codePoint >> 12) & 63) | 128) | 0);
                        bytes[ofs++] = ((((codePoint >> 6) & 63) | 128) | 0);
                        bytes[ofs] = (((codePoint & 63) | 128) | 0);
                        return 5;
                    }
                    throw new java.lang.IllegalArgumentException("Character out of range: " + codePoint);
                }
            }
            EmulatedCharset.UtfCharset = UtfCharset;
            UtfCharset["__class"] = "javaemul.internal.EmulatedCharset.UtfCharset";
            UtfCharset["__interfaces"] = ["java.lang.Comparable"];
        })(EmulatedCharset = internal.EmulatedCharset || (internal.EmulatedCharset = {}));
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
(function (java) {
    var security;
    (function (security) {
        /**
         * Message Digest algorithm - <a href=
         * "http://java.sun.com/j2se/1.4.2/docs/api/java/security/MessageDigest.html"
         * >[Sun's docs]</a>.
         * @extends java.security.MessageDigestSpi
         * @class
         */
        class MessageDigest extends java.security.MessageDigestSpi {
            constructor(algorithm) {
                super();
                if (this.algorithm === undefined)
                    this.algorithm = null;
                this.algorithm = algorithm;
            }
            static getInstance(algorithm) {
                if (((o1, o2) => { if (o1 && o1.equals) {
                    return o1.equals(o2);
                }
                else {
                    return o1 === o2;
                } })("MD5", algorithm)) {
                    return new MessageDigest.Md5Digest();
                }
                throw new java.security.NoSuchAlgorithmException(algorithm + " not supported");
            }
            static isEqual(digestA, digestB) {
                let n = digestA.length;
                if (n !== digestB.length) {
                    return false;
                }
                for (let i = 0; i < n; ++i) {
                    {
                        if (digestA[i] !== digestB[i]) {
                            return false;
                        }
                    }
                    ;
                }
                return true;
            }
            digest$() {
                return this.engineDigest();
            }
            digest$byte_A(input) {
                this.update$byte_A(input);
                return this.digest();
            }
            digest$byte_A$int$int(buf, offset, len) {
                return this.engineDigest$byte_A$int$int(buf, offset, len);
            }
            digest(buf, offset, len) {
                if (((buf != null && buf instanceof Array && (buf.length == 0 || buf[0] == null || (typeof buf[0] === 'number'))) || buf === null) && ((typeof offset === 'number') || offset === null) && ((typeof len === 'number') || len === null)) {
                    return this.digest$byte_A$int$int(buf, offset, len);
                }
                else if (((buf != null && buf instanceof Array && (buf.length == 0 || buf[0] == null || (typeof buf[0] === 'number'))) || buf === null) && offset === undefined && len === undefined) {
                    return this.digest$byte_A(buf);
                }
                else if (buf === undefined && offset === undefined && len === undefined) {
                    return this.digest$();
                }
                else
                    throw new Error('invalid overload');
            }
            getAlgorithm() {
                return this.algorithm;
            }
            getDigestLength() {
                return this.engineGetDigestLength();
            }
            reset() {
                this.engineReset();
            }
            update$byte(input) {
                this.engineUpdate$byte(input);
            }
            update$byte_A(input) {
                this.engineUpdate$byte_A$int$int(input, 0, input.length);
            }
            update$byte_A$int$int(input, offset, len) {
                this.engineUpdate$byte_A$int$int(input, offset, len);
            }
            update(input, offset, len) {
                if (((input != null && input instanceof Array && (input.length == 0 || input[0] == null || (typeof input[0] === 'number'))) || input === null) && ((typeof offset === 'number') || offset === null) && ((typeof len === 'number') || len === null)) {
                    return this.update$byte_A$int$int(input, offset, len);
                }
                else if (((input != null && input instanceof Array && (input.length == 0 || input[0] == null || (typeof input[0] === 'number'))) || input === null) && offset === undefined && len === undefined) {
                    return this.update$byte_A(input);
                }
                else if (((typeof input === 'number') || input === null) && offset === undefined && len === undefined) {
                    return this.update$byte(input);
                }
                else
                    throw new Error('invalid overload');
            }
        }
        security.MessageDigest = MessageDigest;
        MessageDigest["__class"] = "java.security.MessageDigest";
        (function (MessageDigest) {
            class Md5Digest extends java.security.MessageDigest {
                constructor() {
                    super("MD5");
                    this.oneByte = [0];
                    if (this.buffer === undefined)
                        this.buffer = null;
                    if (this.counter === undefined)
                        this.counter = 0;
                    if (this.remainder === undefined)
                        this.remainder = 0;
                    if (this.state === undefined)
                        this.state = null;
                    if (this.x === undefined)
                        this.x = null;
                    this.engineReset();
                }
                static padding_$LI$() { if (Md5Digest.padding == null)
                    Md5Digest.padding = [(128 | 0), 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; return Md5Digest.padding; }
                ;
                /**
                 * Converts a long to a 8-byte array using low order first.
                 *
                 * @param {number} n A long.
                 * @return {Array} A byte[].
                 */
                static toBytes(n) {
                    let b = [0, 0, 0, 0, 0, 0, 0, 0];
                    b[0] = ((n) | 0);
                    n >>>= 8;
                    b[1] = ((n) | 0);
                    n >>>= 8;
                    b[2] = ((n) | 0);
                    n >>>= 8;
                    b[3] = ((n) | 0);
                    n >>>= 8;
                    b[4] = ((n) | 0);
                    n >>>= 8;
                    b[5] = ((n) | 0);
                    n >>>= 8;
                    b[6] = ((n) | 0);
                    n >>>= 8;
                    b[7] = ((n) | 0);
                    return b;
                }
                /**
                 * Converts a 64-byte array into a 16-int array.
                 *
                 * @param {Array} in A byte[].
                 * @param {Array} out An int[].
                 * @private
                 */
                static byte2int(__in, out) {
                    for (let inpos = 0, outpos = 0; outpos < 16; outpos++) {
                        {
                            out[outpos] = ((__in[inpos++] & 255) | ((__in[inpos++] & 255) << 8) | ((__in[inpos++] & 255) << 16) | ((__in[inpos++] & 255) << 24));
                        }
                        ;
                    }
                }
                static f(x, y, z) {
                    return (z ^ (x & (y ^ z)));
                }
                static ff(a, b, c, d, x, s, ac) {
                    a += x + ac + Md5Digest.f(b, c, d);
                    a = (a << s | a >>> -s);
                    return a + b;
                }
                static g(x, y, z) {
                    return (y ^ (z & (x ^ y)));
                }
                static gg(a, b, c, d, x, s, ac) {
                    a += x + ac + Md5Digest.g(b, c, d);
                    a = (a << s | a >>> -s);
                    return a + b;
                }
                static h(x, y, z) {
                    return (x ^ y ^ z);
                }
                static hh(a, b, c, d, x, s, ac) {
                    a += x + ac + Md5Digest.h(b, c, d);
                    a = (a << s | a >>> -s);
                    return a + b;
                }
                static i(x, y, z) {
                    return (y ^ (x | ~z));
                }
                static ii(a, b, c, d, x, s, ac) {
                    a += x + ac + Md5Digest.i(b, c, d);
                    a = (a << s | a >>> -s);
                    return a + b;
                }
                /**
                 * Converts a 4-int array into a 16-byte array.
                 *
                 * @param {Array} in An int[].
                 * @param {Array} out A byte[].
                 * @private
                 */
                static int2byte(__in, out) {
                    for (let inpos = 0, outpos = 0; inpos < 4; inpos++) {
                        {
                            out[outpos++] = ((__in[inpos] & 255) | 0);
                            out[outpos++] = (((__in[inpos] >>> 8) & 255) | 0);
                            out[outpos++] = (((__in[inpos] >>> 16) & 255) | 0);
                            out[outpos++] = (((__in[inpos] >>> 24) & 255) | 0);
                        }
                        ;
                    }
                }
                engineDigest(buf, offset, len) {
                    if (((buf != null && buf instanceof Array && (buf.length == 0 || buf[0] == null || (typeof buf[0] === 'number'))) || buf === null) && ((typeof offset === 'number') || offset === null) && ((typeof len === 'number') || len === null)) {
                        super.engineDigest(buf, offset, len);
                    }
                    else if (buf === undefined && offset === undefined && len === undefined) {
                        return this.engineDigest$();
                    }
                    else
                        throw new Error('invalid overload');
                }
                engineDigest$() {
                    let bits = Md5Digest.toBytes(this.counter << 3);
                    let digest = (s => { let a = []; while (s-- > 0)
                        a.push(0); return a; })(16);
                    if (this.remainder > 8) {
                        this.engineUpdate$byte_A$int$int(Md5Digest.padding_$LI$(), 0, this.remainder - 8);
                    }
                    else {
                        this.engineUpdate$byte_A$int$int(Md5Digest.padding_$LI$(), 0, 64 + (this.remainder - 8));
                    }
                    this.engineUpdate$byte_A$int$int(bits, 0, 8);
                    Md5Digest.int2byte(this.state, digest);
                    this.reset();
                    return digest;
                }
                /**
                 *
                 * @return {number}
                 */
                engineGetDigestLength() {
                    return 16;
                }
                /**
                 *
                 */
                engineReset() {
                    this.buffer = (s => { let a = []; while (s-- > 0)
                        a.push(0); return a; })(64);
                    this.state = [0, 0, 0, 0];
                    this.x = (s => { let a = []; while (s-- > 0)
                        a.push(0); return a; })(16);
                    this.state[0] = 1732584193;
                    this.state[1] = -271733879;
                    this.state[2] = -1732584194;
                    this.state[3] = 271733878;
                    this.counter = 0;
                    this.remainder = 64;
                }
                engineUpdate$byte(input) {
                    this.oneByte[0] = input;
                    this.engineUpdate$byte_A$int$int(this.oneByte, 0, 1);
                }
                engineUpdate$byte_A$int$int(input, offset, len) {
                    while ((true)) {
                        {
                            if (len >= this.remainder) {
                                java.lang.System.arraycopy(input, offset, this.buffer, ((this.counter & 63) | 0), this.remainder);
                                this.transform(this.buffer);
                                this.counter += this.remainder;
                                offset += this.remainder;
                                len -= this.remainder;
                                this.remainder = 64;
                            }
                            else {
                                java.lang.System.arraycopy(input, offset, this.buffer, ((this.counter & 63) | 0), len);
                                this.counter += len;
                                this.remainder -= len;
                                break;
                            }
                        }
                    }
                    ;
                }
                /**
                 *
                 * @param {Array} input
                 * @param {number} offset
                 * @param {number} len
                 */
                engineUpdate(input, offset, len) {
                    if (((input != null && input instanceof Array && (input.length == 0 || input[0] == null || (typeof input[0] === 'number'))) || input === null) && ((typeof offset === 'number') || offset === null) && ((typeof len === 'number') || len === null)) {
                        return this.engineUpdate$byte_A$int$int(input, offset, len);
                    }
                    else if (((typeof input === 'number') || input === null) && offset === undefined && len === undefined) {
                        return this.engineUpdate$byte(input);
                    }
                    else
                        throw new Error('invalid overload');
                }
                transform(buffer) {
                    let a;
                    let b;
                    let c;
                    let d;
                    Md5Digest.byte2int(buffer, this.x);
                    a = this.state[0];
                    b = this.state[1];
                    c = this.state[2];
                    d = this.state[3];
                    a = Md5Digest.ff(a, b, c, d, this.x[0], 7, -680876936);
                    d = Md5Digest.ff(d, a, b, c, this.x[1], 12, -389564586);
                    c = Md5Digest.ff(c, d, a, b, this.x[2], 17, 606105819);
                    b = Md5Digest.ff(b, c, d, a, this.x[3], 22, -1044525330);
                    a = Md5Digest.ff(a, b, c, d, this.x[4], 7, -176418897);
                    d = Md5Digest.ff(d, a, b, c, this.x[5], 12, 1200080426);
                    c = Md5Digest.ff(c, d, a, b, this.x[6], 17, -1473231341);
                    b = Md5Digest.ff(b, c, d, a, this.x[7], 22, -45705983);
                    a = Md5Digest.ff(a, b, c, d, this.x[8], 7, 1770035416);
                    d = Md5Digest.ff(d, a, b, c, this.x[9], 12, -1958414417);
                    c = Md5Digest.ff(c, d, a, b, this.x[10], 17, -42063);
                    b = Md5Digest.ff(b, c, d, a, this.x[11], 22, -1990404162);
                    a = Md5Digest.ff(a, b, c, d, this.x[12], 7, 1804603682);
                    d = Md5Digest.ff(d, a, b, c, this.x[13], 12, -40341101);
                    c = Md5Digest.ff(c, d, a, b, this.x[14], 17, -1502002290);
                    b = Md5Digest.ff(b, c, d, a, this.x[15], 22, 1236535329);
                    a = Md5Digest.gg(a, b, c, d, this.x[1], 5, -165796510);
                    d = Md5Digest.gg(d, a, b, c, this.x[6], 9, -1069501632);
                    c = Md5Digest.gg(c, d, a, b, this.x[11], 14, 643717713);
                    b = Md5Digest.gg(b, c, d, a, this.x[0], 20, -373897302);
                    a = Md5Digest.gg(a, b, c, d, this.x[5], 5, -701558691);
                    d = Md5Digest.gg(d, a, b, c, this.x[10], 9, 38016083);
                    c = Md5Digest.gg(c, d, a, b, this.x[15], 14, -660478335);
                    b = Md5Digest.gg(b, c, d, a, this.x[4], 20, -405537848);
                    a = Md5Digest.gg(a, b, c, d, this.x[9], 5, 568446438);
                    d = Md5Digest.gg(d, a, b, c, this.x[14], 9, -1019803690);
                    c = Md5Digest.gg(c, d, a, b, this.x[3], 14, -187363961);
                    b = Md5Digest.gg(b, c, d, a, this.x[8], 20, 1163531501);
                    a = Md5Digest.gg(a, b, c, d, this.x[13], 5, -1444681467);
                    d = Md5Digest.gg(d, a, b, c, this.x[2], 9, -51403784);
                    c = Md5Digest.gg(c, d, a, b, this.x[7], 14, 1735328473);
                    b = Md5Digest.gg(b, c, d, a, this.x[12], 20, -1926607734);
                    a = Md5Digest.hh(a, b, c, d, this.x[5], 4, -378558);
                    d = Md5Digest.hh(d, a, b, c, this.x[8], 11, -2022574463);
                    c = Md5Digest.hh(c, d, a, b, this.x[11], 16, 1839030562);
                    b = Md5Digest.hh(b, c, d, a, this.x[14], 23, -35309556);
                    a = Md5Digest.hh(a, b, c, d, this.x[1], 4, -1530992060);
                    d = Md5Digest.hh(d, a, b, c, this.x[4], 11, 1272893353);
                    c = Md5Digest.hh(c, d, a, b, this.x[7], 16, -155497632);
                    b = Md5Digest.hh(b, c, d, a, this.x[10], 23, -1094730640);
                    a = Md5Digest.hh(a, b, c, d, this.x[13], 4, 681279174);
                    d = Md5Digest.hh(d, a, b, c, this.x[0], 11, -358537222);
                    c = Md5Digest.hh(c, d, a, b, this.x[3], 16, -722521979);
                    b = Md5Digest.hh(b, c, d, a, this.x[6], 23, 76029189);
                    a = Md5Digest.hh(a, b, c, d, this.x[9], 4, -640364487);
                    d = Md5Digest.hh(d, a, b, c, this.x[12], 11, -421815835);
                    c = Md5Digest.hh(c, d, a, b, this.x[15], 16, 530742520);
                    b = Md5Digest.hh(b, c, d, a, this.x[2], 23, -995338651);
                    a = Md5Digest.ii(a, b, c, d, this.x[0], 6, -198630844);
                    d = Md5Digest.ii(d, a, b, c, this.x[7], 10, 1126891415);
                    c = Md5Digest.ii(c, d, a, b, this.x[14], 15, -1416354905);
                    b = Md5Digest.ii(b, c, d, a, this.x[5], 21, -57434055);
                    a = Md5Digest.ii(a, b, c, d, this.x[12], 6, 1700485571);
                    d = Md5Digest.ii(d, a, b, c, this.x[3], 10, -1894986606);
                    c = Md5Digest.ii(c, d, a, b, this.x[10], 15, -1051523);
                    b = Md5Digest.ii(b, c, d, a, this.x[1], 21, -2054922799);
                    a = Md5Digest.ii(a, b, c, d, this.x[8], 6, 1873313359);
                    d = Md5Digest.ii(d, a, b, c, this.x[15], 10, -30611744);
                    c = Md5Digest.ii(c, d, a, b, this.x[6], 15, -1560198380);
                    b = Md5Digest.ii(b, c, d, a, this.x[13], 21, 1309151649);
                    a = Md5Digest.ii(a, b, c, d, this.x[4], 6, -145523070);
                    d = Md5Digest.ii(d, a, b, c, this.x[11], 10, -1120210379);
                    c = Md5Digest.ii(c, d, a, b, this.x[2], 15, 718787259);
                    b = Md5Digest.ii(b, c, d, a, this.x[9], 21, -343485551);
                    this.state[0] = javaemul.internal.Coercions.ensureInt(this.state[0] + a);
                    this.state[1] = javaemul.internal.Coercions.ensureInt(this.state[1] + b);
                    this.state[2] = javaemul.internal.Coercions.ensureInt(this.state[2] + c);
                    this.state[3] = javaemul.internal.Coercions.ensureInt(this.state[3] + d);
                }
            }
            MessageDigest.Md5Digest = Md5Digest;
            Md5Digest["__class"] = "java.security.MessageDigest.Md5Digest";
        })(MessageDigest = security.MessageDigest || (security.MessageDigest = {}));
    })(security = java.security || (java.security = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        /**
         * Skeletal implementation of the List interface. <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/AbstractList.html">[Sun
         * docs]</a>
         *
         * @param <E> the element type.
         * @extends java.util.AbstractCollection
         * @class
         */
        class AbstractList extends java.util.AbstractCollection {
            constructor() {
                super();
                if (this.modCount === undefined)
                    this.modCount = 0;
            }
            stream() {
                return (new javaemul.internal.stream.StreamHelper(this));
            }
            forEach(action) {
                javaemul.internal.InternalPreconditions.checkNotNull((action));
                for (let index131 = this.iterator(); index131.hasNext();) {
                    let t = index131.next();
                    {
                        (target => (typeof target === 'function') ? target(t) : target.accept(t))(action);
                    }
                }
            }
            removeIf(filter) {
                javaemul.internal.InternalPreconditions.checkNotNull((filter));
                let removed = false;
                for (let it = this.iterator(); it.hasNext();) {
                    {
                        if ((target => (typeof target === 'function') ? target(it.next()) : target.test(it.next()))(filter)) {
                            it.remove();
                            removed = true;
                        }
                    }
                    ;
                }
                return removed;
            }
            add$java_lang_Object(obj) {
                this.add(this.size(), obj);
                return true;
            }
            add$int$java_lang_Object(index, element) {
                throw new java.lang.UnsupportedOperationException("Add not supported on this list");
            }
            /**
             *
             * @param {number} index
             * @param {*} element
             */
            add(index, element) {
                if (((typeof index === 'number') || index === null) && ((element != null) || element === null)) {
                    return this.add$int$java_lang_Object(index, element);
                }
                else if (((index != null) || index === null) && element === undefined) {
                    return this.add$java_lang_Object(index);
                }
                else
                    throw new Error('invalid overload');
            }
            addAll$int$java_util_Collection(index, c) {
                javaemul.internal.InternalPreconditions.checkNotNull(c);
                let changed = false;
                for (let index132 = c.iterator(); index132.hasNext();) {
                    let e = index132.next();
                    {
                        this.add(index++, e);
                        changed = true;
                    }
                }
                return changed;
            }
            /**
             *
             * @param {number} index
             * @param {*} c
             * @return {boolean}
             */
            addAll(index, c) {
                if (((typeof index === 'number') || index === null) && ((c != null && (c["__interfaces"] != null && c["__interfaces"].indexOf("java.util.Collection") >= 0 || c.constructor != null && c.constructor["__interfaces"] != null && c.constructor["__interfaces"].indexOf("java.util.Collection") >= 0)) || c === null)) {
                    return this.addAll$int$java_util_Collection(index, c);
                }
                else if (((index != null && (index["__interfaces"] != null && index["__interfaces"].indexOf("java.util.Collection") >= 0 || index.constructor != null && index.constructor["__interfaces"] != null && index.constructor["__interfaces"].indexOf("java.util.Collection") >= 0)) || index === null) && c === undefined) {
                    super.addAll(index);
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             *
             */
            clear() {
                this.removeRange(0, this.size());
            }
            /**
             *
             * @param {*} o
             * @return {boolean}
             */
            equals(o) {
                if (o === this) {
                    return true;
                }
                if (!(o != null && (o["__interfaces"] != null && o["__interfaces"].indexOf("java.util.List") >= 0 || o.constructor != null && o.constructor["__interfaces"] != null && o.constructor["__interfaces"].indexOf("java.util.List") >= 0))) {
                    return false;
                }
                let other = o;
                if (this.size() !== other.size()) {
                    return false;
                }
                let iterOther = other.iterator();
                for (let index133 = this.iterator(); index133.hasNext();) {
                    let elem = index133.next();
                    {
                        let elemOther = iterOther.next();
                        if (!java.util.Objects.equals(elem, elemOther)) {
                            return false;
                        }
                    }
                }
                return true;
            }
            /**
             *
             * @return {number}
             */
            hashCode() {
                return java.util.Collections.hashCode$java_lang_Iterable(this);
            }
            /**
             *
             * @param {*} toFind
             * @return {number}
             */
            indexOf(toFind) {
                for (let i = 0, n = this.size(); i < n; ++i) {
                    {
                        if (java.util.Objects.equals(toFind, this.get(i))) {
                            return i;
                        }
                    }
                    ;
                }
                return -1;
            }
            /**
             *
             * @return {*}
             */
            iterator() {
                return new AbstractList.IteratorImpl(this);
            }
            /**
             *
             * @param {*} toFind
             * @return {number}
             */
            lastIndexOf(toFind) {
                for (let i = this.size() - 1; i > -1; --i) {
                    {
                        if (java.util.Objects.equals(toFind, this.get(i))) {
                            return i;
                        }
                    }
                    ;
                }
                return -1;
            }
            listIterator$() {
                return this.listIterator$int(0);
            }
            listIterator$int(from) {
                return new AbstractList.ListIteratorImpl(this, from);
            }
            /**
             *
             * @param {number} from
             * @return {*}
             */
            listIterator(from) {
                if (((typeof from === 'number') || from === null)) {
                    return this.listIterator$int(from);
                }
                else if (from === undefined) {
                    return this.listIterator$();
                }
                else
                    throw new Error('invalid overload');
            }
            remove$int(index) {
                throw new java.lang.UnsupportedOperationException("Remove not supported on this list");
            }
            /**
             *
             * @param {number} index
             * @return {*}
             */
            remove(index) {
                if (((typeof index === 'number') || index === null)) {
                    return this.remove$int(index);
                }
                else if (((index != null) || index === null)) {
                    super.remove(index);
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             *
             * @param {number} index
             * @param {*} o
             * @return {*}
             */
            set(index, o) {
                throw new java.lang.UnsupportedOperationException("Set not supported on this list");
            }
            /**
             *
             * @param {number} fromIndex
             * @param {number} toIndex
             * @return {*}
             */
            subList(fromIndex, toIndex) {
                return (new AbstractList.SubList(this, fromIndex, toIndex));
            }
            removeRange(fromIndex, endIndex) {
                let iter = this.listIterator$int(fromIndex);
                for (let i = fromIndex; i < endIndex; ++i) {
                    {
                        iter.next();
                        iter.remove();
                    }
                    ;
                }
            }
        }
        util.AbstractList = AbstractList;
        AbstractList["__class"] = "java.util.AbstractList";
        AbstractList["__interfaces"] = ["java.util.List", "java.util.Collection", "java.lang.Iterable"];
        (function (AbstractList) {
            class IteratorImpl {
                constructor(__parent) {
                    this.__parent = __parent;
                    if (this.i === undefined)
                        this.i = 0;
                    if (this.last === undefined)
                        this.last = 0;
                    this.i = 0;
                    this.last = -1;
                }
                forEachRemaining(consumer) {
                    javaemul.internal.InternalPreconditions.checkNotNull((consumer));
                    while ((this.hasNext())) {
                        {
                            (target => (typeof target === 'function') ? target(this.next()) : target.accept(this.next()))(consumer);
                        }
                    }
                    ;
                }
                /**
                 *
                 * @return {boolean}
                 */
                hasNext() {
                    return this.i < this.__parent.size();
                }
                /**
                 *
                 * @return {*}
                 */
                next() {
                    javaemul.internal.InternalPreconditions.checkElement(this.hasNext());
                    return this.__parent.get(this.last = this.i++);
                }
                /**
                 *
                 */
                remove() {
                    javaemul.internal.InternalPreconditions.checkState(this.last !== -1);
                    this.__parent.remove$int(this.last);
                    this.i = this.last;
                    this.last = -1;
                }
            }
            AbstractList.IteratorImpl = IteratorImpl;
            IteratorImpl["__class"] = "java.util.AbstractList.IteratorImpl";
            IteratorImpl["__interfaces"] = ["java.util.Iterator"];
            class SubList extends java.util.AbstractList {
                constructor(wrapped, fromIndex, toIndex) {
                    super();
                    if (this.wrapped === undefined)
                        this.wrapped = null;
                    if (this.fromIndex === undefined)
                        this.fromIndex = 0;
                    if (this.__size === undefined)
                        this.__size = 0;
                    javaemul.internal.InternalPreconditions.checkCriticalPositionIndexes(fromIndex, toIndex, wrapped.size());
                    this.wrapped = wrapped;
                    this.fromIndex = fromIndex;
                    this.__size = toIndex - fromIndex;
                }
                add$int$java_lang_Object(index, element) {
                    javaemul.internal.InternalPreconditions.checkPositionIndex(index, this.__size);
                    this.wrapped.add(this.fromIndex + index, element);
                    this.__size++;
                }
                /**
                 *
                 * @param {number} index
                 * @param {*} element
                 */
                add(index, element) {
                    if (((typeof index === 'number') || index === null) && ((element != null) || element === null)) {
                        return this.add$int$java_lang_Object(index, element);
                    }
                    else if (((index != null) || index === null) && element === undefined) {
                        return this.add$java_lang_Object(index);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 *
                 * @param {number} index
                 * @return {*}
                 */
                get(index) {
                    javaemul.internal.InternalPreconditions.checkElementIndex(index, this.__size);
                    return this.wrapped.get(this.fromIndex + index);
                }
                remove$int(index) {
                    javaemul.internal.InternalPreconditions.checkElementIndex(index, this.__size);
                    let result = this.wrapped['remove$int'](this.fromIndex + index);
                    this.__size--;
                    return result;
                }
                /**
                 *
                 * @param {number} index
                 * @return {*}
                 */
                remove(index) {
                    if (((typeof index === 'number') || index === null)) {
                        return this.remove$int(index);
                    }
                    else if (((index != null) || index === null)) {
                        super.remove(index);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 *
                 * @param {number} index
                 * @param {*} element
                 * @return {*}
                 */
                set(index, element) {
                    javaemul.internal.InternalPreconditions.checkElementIndex(index, this.__size);
                    return this.wrapped.set(this.fromIndex + index, element);
                }
                /**
                 *
                 * @return {number}
                 */
                size() {
                    return this.__size;
                }
            }
            AbstractList.SubList = SubList;
            SubList["__class"] = "java.util.AbstractList.SubList";
            SubList["__interfaces"] = ["java.util.List", "java.util.Collection", "java.lang.Iterable"];
            /**
             * Implementation of <code>ListIterator</code> for abstract lists.
             * @extends java.util.AbstractList.IteratorImpl
             * @class
             */
            class ListIteratorImpl extends AbstractList.IteratorImpl {
                constructor(__parent, start) {
                    if (((typeof start === 'number') || start === null)) {
                        let __args = Array.prototype.slice.call(arguments, [1]);
                        super(__parent);
                        this.__parent = __parent;
                        (() => {
                            javaemul.internal.InternalPreconditions.checkPositionIndex(start, __parent.size());
                            this.i = start;
                        })();
                    }
                    else if (start === undefined) {
                        let __args = Array.prototype.slice.call(arguments, [1]);
                        super(__parent);
                        this.__parent = __parent;
                    }
                    else
                        throw new Error('invalid overload');
                }
                forEachRemaining(consumer) {
                    javaemul.internal.InternalPreconditions.checkNotNull((consumer));
                    while ((this.hasNext())) {
                        {
                            (target => (typeof target === 'function') ? target(this.next()) : target.accept(this.next()))(consumer);
                        }
                    }
                    ;
                }
                /**
                 *
                 * @param {*} o
                 */
                add(o) {
                    this.__parent.add(this.i, o);
                    this.i++;
                    this.last = -1;
                }
                /**
                 *
                 * @return {boolean}
                 */
                hasPrevious() {
                    return this.i > 0;
                }
                /**
                 *
                 * @return {number}
                 */
                nextIndex() {
                    return this.i;
                }
                /**
                 *
                 * @return {*}
                 */
                previous() {
                    javaemul.internal.InternalPreconditions.checkElement(this.hasPrevious());
                    return this.__parent.get(this.last = --this.i);
                }
                /**
                 *
                 * @return {number}
                 */
                previousIndex() {
                    return this.i - 1;
                }
                /**
                 *
                 * @param {*} o
                 */
                set(o) {
                    javaemul.internal.InternalPreconditions.checkState(this.last !== -1);
                    this.__parent.set(this.last, o);
                }
            }
            AbstractList.ListIteratorImpl = ListIteratorImpl;
            ListIteratorImpl["__class"] = "java.util.AbstractList.ListIteratorImpl";
            ListIteratorImpl["__interfaces"] = ["java.util.Iterator", "java.util.ListIterator"];
        })(AbstractList = util.AbstractList || (util.AbstractList = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        /**
         * Skeletal implementation of the Queue interface. <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/AbstractQueue.html">[Sun
         * docs]</a>
         *
         * @param <E> element type.
         * @extends java.util.AbstractCollection
         * @class
         */
        class AbstractQueue extends java.util.AbstractCollection {
            constructor() {
                super();
            }
            stream() {
                return (new javaemul.internal.stream.StreamHelper(this));
            }
            forEach(action) {
                javaemul.internal.InternalPreconditions.checkNotNull((action));
                for (let index134 = this.iterator(); index134.hasNext();) {
                    let t = index134.next();
                    {
                        (target => (typeof target === 'function') ? target(t) : target.accept(t))(action);
                    }
                }
            }
            removeIf(filter) {
                javaemul.internal.InternalPreconditions.checkNotNull((filter));
                let removed = false;
                for (let it = this.iterator(); it.hasNext();) {
                    {
                        if ((target => (typeof target === 'function') ? target(it.next()) : target.test(it.next()))(filter)) {
                            it.remove();
                            removed = true;
                        }
                    }
                    ;
                }
                return removed;
            }
            /**
             *
             * @param {*} o
             * @return {boolean}
             */
            add(o) {
                javaemul.internal.InternalPreconditions.checkState(this.offer(o), "Unable to add element to queue");
                return true;
            }
            /**
             *
             * @param {*} c
             * @return {boolean}
             */
            addAll(c) {
                javaemul.internal.InternalPreconditions.checkNotNull(c);
                javaemul.internal.InternalPreconditions.checkArgument(c !== this, "Can\'t add a queue to itself");
                return super.addAll(c);
            }
            /**
             *
             */
            clear() {
                while ((this.poll() != null)) {
                    {
                    }
                }
                ;
            }
            /**
             *
             * @return {*}
             */
            element() {
                let e = this.peek();
                javaemul.internal.InternalPreconditions.checkElement(e != null, "Queue is empty");
                return e;
            }
            /**
             *
             * @param {*} o
             * @return {boolean}
             */
            remove(o) {
                if (((o != null) || o === null)) {
                    super.remove(o);
                }
                else if (o === undefined) {
                    return this.remove$();
                }
                else
                    throw new Error('invalid overload');
            }
            remove$() {
                let e = this.poll();
                javaemul.internal.InternalPreconditions.checkElement(e != null, "Queue is empty");
                return e;
            }
        }
        util.AbstractQueue = AbstractQueue;
        AbstractQueue["__class"] = "java.util.AbstractQueue";
        AbstractQueue["__interfaces"] = ["java.util.Collection", "java.util.Queue", "java.lang.Iterable"];
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        /**
         * Skeletal implementation of the Set interface. <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/AbstractSet.html">[Sun
         * docs]</a>
         *
         * @param <E> the element type.
         * @class
         * @extends java.util.AbstractCollection
         */
        class AbstractSet extends java.util.AbstractCollection {
            constructor() {
                super();
            }
            stream() {
                return (new javaemul.internal.stream.StreamHelper(this));
            }
            forEach(action) {
                javaemul.internal.InternalPreconditions.checkNotNull((action));
                for (let index135 = this.iterator(); index135.hasNext();) {
                    let t = index135.next();
                    {
                        (target => (typeof target === 'function') ? target(t) : target.accept(t))(action);
                    }
                }
            }
            removeIf(filter) {
                javaemul.internal.InternalPreconditions.checkNotNull((filter));
                let removed = false;
                for (let it = this.iterator(); it.hasNext();) {
                    {
                        if ((target => (typeof target === 'function') ? target(it.next()) : target.test(it.next()))(filter)) {
                            it.remove();
                            removed = true;
                        }
                    }
                    ;
                }
                return removed;
            }
            /**
             *
             * @param {*} o
             * @return {boolean}
             */
            equals(o) {
                if (o === this) {
                    return true;
                }
                if (!(o != null && (o["__interfaces"] != null && o["__interfaces"].indexOf("java.util.Set") >= 0 || o.constructor != null && o.constructor["__interfaces"] != null && o.constructor["__interfaces"].indexOf("java.util.Set") >= 0))) {
                    return false;
                }
                let other = o;
                if (other.size() !== this.size()) {
                    return false;
                }
                return this.containsAll(other);
            }
            /**
             *
             * @return {number}
             */
            hashCode() {
                return java.util.Collections.hashCode$java_lang_Iterable(this);
            }
            /**
             *
             * @param {*} c
             * @return {boolean}
             */
            removeAll(c) {
                javaemul.internal.InternalPreconditions.checkNotNull(c);
                let size = this.size();
                if (size < c.size()) {
                    for (let iter = this.iterator(); iter.hasNext();) {
                        {
                            let o = iter.next();
                            if (c.contains(o)) {
                                iter.remove();
                            }
                        }
                        ;
                    }
                }
                else {
                    for (let index136 = c.iterator(); index136.hasNext();) {
                        let o1 = index136.next();
                        {
                            this.remove(o1);
                        }
                    }
                }
                return (size !== this.size());
            }
        }
        util.AbstractSet = AbstractSet;
        AbstractSet["__class"] = "java.util.AbstractSet";
        AbstractSet["__interfaces"] = ["java.util.Collection", "java.util.Set", "java.lang.Iterable"];
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        /**
         * A simple wrapper around JavaScript Map for key type is string.
         * @param {java.util.AbstractHashMap} host
         * @class
         */
        class InternalStringMap {
            constructor(host) {
                /*private*/ this.backingMap = java.util.InternalJsMapFactory.newJsMap();
                if (this.host === undefined)
                    this.host = null;
                if (this.size === undefined)
                    this.size = 0;
                if (this.valueMod === undefined)
                    this.valueMod = 0;
                this.host = host;
            }
            forEach(action) {
                javaemul.internal.InternalPreconditions.checkNotNull((action));
                for (let index137 = this.iterator(); index137.hasNext();) {
                    let t = index137.next();
                    {
                        (target => (typeof target === 'function') ? target(t) : target.accept(t))(action);
                    }
                }
            }
            contains(key) {
                return !javaemul.internal.JsUtils.isUndefined(this.backingMap.get(key));
            }
            get(key) {
                return this.backingMap.get(key);
            }
            put(key, value) {
                let oldValue = this.backingMap.get(key);
                this.backingMap.set(key, (InternalStringMap.toNullIfUndefined(value)));
                if (javaemul.internal.JsUtils.isUndefined(oldValue)) {
                    this.size++;
                    java.util.ConcurrentModificationDetector.structureChanged(this.host);
                }
                else {
                    this.valueMod++;
                }
                return oldValue;
            }
            remove(key) {
                let value = this.backingMap.get(key);
                if (!javaemul.internal.JsUtils.isUndefined(value)) {
                    this.backingMap.delete(key);
                    this.size--;
                    java.util.ConcurrentModificationDetector.structureChanged(this.host);
                }
                else {
                    this.valueMod++;
                }
                return value;
            }
            getSize() {
                return this.size;
            }
            /**
             *
             * @return {*}
             */
            iterator() {
                return new InternalStringMap.InternalStringMap$0(this);
            }
            /*private*/ newMapEntry(entry, lastValueMod) {
                return new InternalStringMap.InternalStringMap$1(this, entry, lastValueMod);
            }
            /*private*/ static toNullIfUndefined(value) {
                return javaemul.internal.JsUtils.isUndefined(value) ? null : value;
            }
        }
        util.InternalStringMap = InternalStringMap;
        InternalStringMap["__class"] = "java.util.InternalStringMap";
        InternalStringMap["__interfaces"] = ["java.lang.Iterable"];
        (function (InternalStringMap) {
            class InternalStringMap$0 {
                constructor(__parent) {
                    this.__parent = __parent;
                    this.entries = this.__parent.backingMap.entries();
                    this.current = this.entries.next();
                    if (this.last === undefined)
                        this.last = null;
                }
                forEachRemaining(consumer) {
                    javaemul.internal.InternalPreconditions.checkNotNull((consumer));
                    while ((this.hasNext())) {
                        {
                            (target => (typeof target === 'function') ? target(this.next()) : target.accept(this.next()))(consumer);
                        }
                    }
                    ;
                }
                /**
                 *
                 * @return {boolean}
                 */
                hasNext() {
                    return !this.current.done;
                }
                /**
                 *
                 * @return {*}
                 */
                next() {
                    this.last = this.current;
                    this.current = this.entries.next();
                    return this.__parent.newMapEntry(this.last, this.__parent.valueMod);
                }
                /**
                 *
                 */
                remove() {
                    this.__parent.remove(this.last.value[0]);
                }
            }
            InternalStringMap.InternalStringMap$0 = InternalStringMap$0;
            InternalStringMap$0["__interfaces"] = ["java.util.Iterator"];
            class InternalStringMap$1 extends java.util.AbstractMapEntry {
                constructor(__parent, entry, lastValueMod) {
                    super();
                    this.entry = entry;
                    this.lastValueMod = lastValueMod;
                    this.__parent = __parent;
                }
                /**
                 *
                 * @return {*}
                 */
                getKey() {
                    return this.entry.value[0];
                }
                /**
                 *
                 * @return {*}
                 */
                getValue() {
                    if (this.__parent.valueMod !== this.lastValueMod) {
                        return this.__parent.get(this.entry.value[0]);
                    }
                    return this.entry.value[1];
                }
                /**
                 *
                 * @param {*} object
                 * @return {*}
                 */
                setValue(object) {
                    return this.__parent.put(this.entry.value[0], object);
                }
            }
            InternalStringMap.InternalStringMap$1 = InternalStringMap$1;
            InternalStringMap$1["__interfaces"] = ["java.util.Map.Entry"];
        })(InternalStringMap = util.InternalStringMap || (util.InternalStringMap = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (javaemul) {
    var internal;
    (function (internal) {
        /**
         * Intrinsic string class.
         * @class
         */
        class StringHelper {
            constructor() {
            }
            static CASE_INSENSITIVE_ORDER_$LI$() { if (StringHelper.CASE_INSENSITIVE_ORDER == null)
                StringHelper.CASE_INSENSITIVE_ORDER = new StringHelper.StringHelper$0(); return StringHelper.CASE_INSENSITIVE_ORDER; }
            ;
            static copyValueOf$char_A(v) {
                return StringHelper.valueOf$char_A(v);
            }
            static copyValueOf$char_A$int$int(v, offset, count) {
                return StringHelper.valueOf$char_A$int$int(v, offset, count);
            }
            static copyValueOf(v, offset, count) {
                if (((v != null && v instanceof Array && (v.length == 0 || v[0] == null || (typeof v[0] === 'string'))) || v === null) && ((typeof offset === 'number') || offset === null) && ((typeof count === 'number') || count === null)) {
                    return javaemul.internal.StringHelper.copyValueOf$char_A$int$int(v, offset, count);
                }
                else if (((v != null && v instanceof Array && (v.length == 0 || v[0] == null || (typeof v[0] === 'string'))) || v === null) && offset === undefined && count === undefined) {
                    return javaemul.internal.StringHelper.copyValueOf$char_A(v);
                }
                else
                    throw new Error('invalid overload');
            }
            static valueOf$boolean(x) {
                return "" + x;
            }
            static valueOf$char(x) {
                return "" + x;
            }
            static valueOf$char_A$int$int(x, offset, count) {
                let end = offset + count;
                javaemul.internal.InternalPreconditions.checkStringBounds(offset, end, x.length);
                let batchSize = javaemul.internal.ArrayHelper.ARRAY_PROCESS_BATCH_SIZE;
                let s = "";
                for (let batchStart = offset; batchStart < end;) {
                    {
                        let batchEnd = Math.min(batchStart + batchSize, end);
                        s += (javaemul.internal.ArrayHelper.unsafeClone(x, batchStart, batchEnd)).join("");
                        batchStart = batchEnd;
                    }
                    ;
                }
                return s;
            }
            static valueOf(x, offset, count) {
                if (((x != null && x instanceof Array && (x.length == 0 || x[0] == null || (typeof x[0] === 'string'))) || x === null) && ((typeof offset === 'number') || offset === null) && ((typeof count === 'number') || count === null)) {
                    return javaemul.internal.StringHelper.valueOf$char_A$int$int(x, offset, count);
                }
                else if (((x != null && x instanceof Array && (x.length == 0 || x[0] == null || (typeof x[0] === 'string'))) || x === null) && offset === undefined && count === undefined) {
                    return javaemul.internal.StringHelper.valueOf$char_A(x);
                }
                else if (((typeof x === 'boolean') || x === null) && offset === undefined && count === undefined) {
                    return javaemul.internal.StringHelper.valueOf$boolean(x);
                }
                else if (((typeof x === 'string') || x === null) && offset === undefined && count === undefined) {
                    return javaemul.internal.StringHelper.valueOf$char(x);
                }
                else if (((typeof x === 'number') || x === null) && offset === undefined && count === undefined) {
                    return javaemul.internal.StringHelper.valueOf$int(x);
                }
                else if (((typeof x === 'number') || x === null) && offset === undefined && count === undefined) {
                    return javaemul.internal.StringHelper.valueOf$long(x);
                }
                else if (((typeof x === 'number') || x === null) && offset === undefined && count === undefined) {
                    return javaemul.internal.StringHelper.valueOf$float(x);
                }
                else if (((typeof x === 'number') || x === null) && offset === undefined && count === undefined) {
                    return javaemul.internal.StringHelper.valueOf$double(x);
                }
                else if (((x != null) || x === null) && offset === undefined && count === undefined) {
                    return javaemul.internal.StringHelper.valueOf$java_lang_Object(x);
                }
                else
                    throw new Error('invalid overload');
            }
            /*private*/ static fromCharCode(array) {
                return String.fromCharCode((array | 0));
            }
            static valueOf$char_A(x) {
                return StringHelper.valueOf$char_A$int$int(x, 0, x.length);
            }
            static valueOf$double(x) {
                return "" + x;
            }
            static valueOf$float(x) {
                return "" + x;
            }
            static valueOf$int(x) {
                return "" + x;
            }
            static valueOf$long(x) {
                return "" + x;
            }
            static valueOf$java_lang_Object(x) {
                return x == null ? "null" : x.toString();
            }
            /**
             * This method converts Java-escaped dollar signs "\$" into
             * JavaScript-escaped dollar signs "$$", and removes all other lone
             * backslashes, which serve as escapes in Java but are passed through
             * literally in JavaScript.
             *
             * @skip
             * @param {string} replaceStr
             * @return {string}
             * @private
             */
            /*private*/ static translateReplaceString(replaceStr) {
                let pos = 0;
                while ((0 <= (pos = replaceStr.indexOf("\\", pos)))) {
                    {
                        if ((c => c.charCodeAt == null ? c : c.charCodeAt(0))(replaceStr.charAt(pos + 1)) == '$'.charCodeAt(0)) {
                            replaceStr = replaceStr.substring(0, pos) + "$" + replaceStr.substring(++pos);
                        }
                        else {
                            replaceStr = replaceStr.substring(0, pos) + replaceStr.substring(++pos);
                        }
                    }
                }
                ;
                return replaceStr;
            }
            /*private*/ static compareTo(thisStr, otherStr) {
                if (thisStr == otherStr) {
                    return 0;
                }
                ;
                return (thisStr < otherStr ? -1 : 1);
            }
            /*private*/ static getCharset(charsetName) {
                try {
                    return java.nio.charset.Charset.forName(charsetName);
                }
                catch (e) {
                    throw new java.io.UnsupportedEncodingException(charsetName);
                }
                ;
            }
            static fromCodePoint(codePoint) {
                if (codePoint >= javaemul.internal.CharacterHelper.MIN_SUPPLEMENTARY_CODE_POINT) {
                    let hiSurrogate = javaemul.internal.CharacterHelper.getHighSurrogate(codePoint);
                    let loSurrogate = javaemul.internal.CharacterHelper.getLowSurrogate(codePoint);
                    return new String(hiSurrogate).toString() + new String(loSurrogate).toString();
                }
                else {
                    return new String(String.fromCharCode(codePoint)).toString();
                }
            }
            static format(formatString, ...args) {
                return "";
            }
        }
        internal.StringHelper = StringHelper;
        StringHelper["__class"] = "javaemul.internal.StringHelper";
        (function (StringHelper) {
            class StringHelper$0 {
                constructor() {
                }
                compare$java_lang_String$java_lang_String(a, b) {
                    return a.toUpperCase().localeCompare(b.toUpperCase());
                }
                /**
                 *
                 * @param {string} a
                 * @param {string} b
                 * @return {number}
                 */
                compare(a, b) {
                    if (((typeof a === 'string') || a === null) && ((typeof b === 'string') || b === null)) {
                        return this.compare$java_lang_String$java_lang_String(a, b);
                    }
                    else
                        throw new Error('invalid overload');
                }
            }
            StringHelper.StringHelper$0 = StringHelper$0;
            StringHelper$0["__interfaces"] = ["java.util.Comparator"];
        })(StringHelper = internal.StringHelper || (internal.StringHelper = {}));
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
(function (java) {
    var sql;
    (function (sql) {
        /**
         * An implementation of java.sql.Date. Derived from
         * http://java.sun.com/j2se/1.5.0/docs/api/java/sql/Date.html
         * @param {number} year
         * @param {number} month
         * @param {number} day
         * @class
         * @extends java.util.Date
         */
        class Date extends java.util.Date {
            constructor(year, month, day) {
                if (((typeof year === 'number') || year === null) && ((typeof month === 'number') || month === null) && ((typeof day === 'number') || day === null)) {
                    let __args = arguments;
                    super(year, month, day);
                }
                else if (((typeof year === 'number') || year === null) && month === undefined && day === undefined) {
                    let __args = arguments;
                    let date = __args[0];
                    super(date);
                }
                else
                    throw new Error('invalid overload');
            }
            static valueOf(s) {
                let split = s.split("-");
                if (split.length !== 3) {
                    throw new java.lang.IllegalArgumentException("Invalid escape format: " + s);
                }
                try {
                    let y = javaemul.internal.IntegerHelper.parseInt(split[0]) - 1900;
                    let m = javaemul.internal.IntegerHelper.parseInt(split[1]) - 1;
                    let d = javaemul.internal.IntegerHelper.parseInt(split[2]);
                    return new Date(y, m, d);
                }
                catch (e) {
                    throw new java.lang.IllegalArgumentException("Invalid escape format: " + s);
                }
                ;
            }
            /**
             *
             * @return {number}
             */
            getHours() {
                throw new java.lang.IllegalArgumentException();
            }
            /**
             *
             * @return {number}
             */
            getMinutes() {
                throw new java.lang.IllegalArgumentException();
            }
            /**
             *
             * @return {number}
             */
            getSeconds() {
                throw new java.lang.IllegalArgumentException();
            }
            /**
             *
             * @param {number} i
             */
            setHours(i) {
                throw new java.lang.IllegalArgumentException();
            }
            /**
             *
             * @param {number} i
             */
            setMinutes(i) {
                throw new java.lang.IllegalArgumentException();
            }
            /**
             *
             * @param {number} i
             */
            setSeconds(i) {
                throw new java.lang.IllegalArgumentException();
            }
        }
        sql.Date = Date;
        Date["__class"] = "java.sql.Date";
        Date["__interfaces"] = ["java.lang.Cloneable", "java.lang.Comparable", "java.io.Serializable"];
    })(sql = java.sql || (java.sql = {}));
})(java || (java = {}));
(function (java) {
    var sql;
    (function (sql) {
        /**
         * An implementation of java.sql.Time. Derived from
         * http://java.sun.com/j2se/1.5.0/docs/api/java/sql/Time.html
         * @param {number} hour
         * @param {number} minute
         * @param {number} second
         * @class
         * @extends java.util.Date
         */
        class Time extends java.util.Date {
            constructor(hour, minute, second) {
                if (((typeof hour === 'number') || hour === null) && ((typeof minute === 'number') || minute === null) && ((typeof second === 'number') || second === null)) {
                    let __args = arguments;
                    super(70, 0, 1, hour, minute, second);
                }
                else if (((typeof hour === 'number') || hour === null) && minute === undefined && second === undefined) {
                    let __args = arguments;
                    let time = __args[0];
                    super(time);
                }
                else
                    throw new Error('invalid overload');
            }
            static valueOf(s) {
                let split = s.split(":");
                if (split.length !== 3) {
                    throw new java.lang.IllegalArgumentException("Invalid escape format: " + s);
                }
                try {
                    let hh = javaemul.internal.IntegerHelper.parseInt(split[0]);
                    let mm = javaemul.internal.IntegerHelper.parseInt(split[1]);
                    let ss = javaemul.internal.IntegerHelper.parseInt(split[2]);
                    return new Time(hh, mm, ss);
                }
                catch (e) {
                    throw new java.lang.IllegalArgumentException("Invalid escape format: " + s);
                }
                ;
            }
            /**
             *
             * @return {number}
             */
            getDate() {
                throw new java.lang.IllegalArgumentException();
            }
            /**
             *
             * @return {number}
             */
            getDay() {
                throw new java.lang.IllegalArgumentException();
            }
            /**
             *
             * @return {number}
             */
            getMonth() {
                throw new java.lang.IllegalArgumentException();
            }
            /**
             *
             * @return {number}
             */
            getYear() {
                throw new java.lang.IllegalArgumentException();
            }
            /**
             *
             * @param {number} i
             */
            setDate(i) {
                throw new java.lang.IllegalArgumentException();
            }
            /**
             *
             * @param {number} i
             */
            setMonth(i) {
                throw new java.lang.IllegalArgumentException();
            }
            /**
             *
             * @param {number} i
             */
            setYear(i) {
                throw new java.lang.IllegalArgumentException();
            }
        }
        sql.Time = Time;
        Time["__class"] = "java.sql.Time";
        Time["__interfaces"] = ["java.lang.Cloneable", "java.lang.Comparable", "java.io.Serializable"];
    })(sql = java.sql || (java.sql = {}));
})(java || (java = {}));
(function (java) {
    var sql;
    (function (sql) {
        /**
         * An implementation of java.sql.Timestame. Derived from
         * http://java.sun.com/j2se/1.5.0/docs/api/java/sql/Timestamp.html. This is
         * basically just regular Date decorated with a nanoseconds field.
         * @param {number} year
         * @param {number} month
         * @param {number} date
         * @param {number} hour
         * @param {number} minute
         * @param {number} second
         * @param {number} nano
         * @class
         * @extends java.util.Date
         */
        class Timestamp extends java.util.Date {
            constructor(year, month, date, hour, minute, second, nano) {
                if (((typeof year === 'number') || year === null) && ((typeof month === 'number') || month === null) && ((typeof date === 'number') || date === null) && ((typeof hour === 'number') || hour === null) && ((typeof minute === 'number') || minute === null) && ((typeof second === 'number') || second === null) && ((typeof nano === 'number') || nano === null)) {
                    let __args = arguments;
                    super(year, month, date, hour, minute, second);
                    if (this.nanos === undefined)
                        this.nanos = 0;
                    if (this.nanos === undefined)
                        this.nanos = 0;
                    (() => {
                        this.setNanos(nano);
                    })();
                }
                else if (((typeof year === 'number') || year === null) && month === undefined && date === undefined && hour === undefined && minute === undefined && second === undefined && nano === undefined) {
                    let __args = arguments;
                    let time = __args[0];
                    super(time);
                    if (this.nanos === undefined)
                        this.nanos = 0;
                    if (this.nanos === undefined)
                        this.nanos = 0;
                    (() => {
                        this.nanos = ((((time % 1000) | 0)) * 1000000);
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            static valueOf(s) {
                let components = s.split(" ");
                if (components.length !== 2) {
                    throw new java.lang.IllegalArgumentException("Invalid escape format: " + s);
                }
                let timeComponents = components[1].split("\\.");
                let hasNanos = true;
                let nanos = 0;
                if (timeComponents.length === 1) {
                    hasNanos = false;
                }
                else if (timeComponents.length !== 2) {
                    throw new java.lang.IllegalArgumentException("Invalid escape format: " + s);
                }
                let d = java.sql.Date.valueOf(components[0]);
                let t = java.sql.Time.valueOf(timeComponents[0]);
                if (hasNanos) {
                    let nanosString = timeComponents[1];
                    let len = nanosString.length;
                    if (len > 9) {
                        throw new java.lang.IllegalArgumentException("Invalid escape format: " + s);
                    }
                    if (len < 9) {
                        nanosString += "00000000".substring(len - 1);
                    }
                    try {
                        nanos = javaemul.internal.IntegerHelper.valueOf(nanosString);
                    }
                    catch (e) {
                        throw new java.lang.IllegalArgumentException("Invalid escape format: " + s);
                    }
                    ;
                }
                return new Timestamp(d.getYear(), d.getMonth(), d.getDate(), t.getHours(), t.getMinutes(), t.getSeconds(), nanos);
            }
            /*private*/ static padNine(value) {
                let toReturn = new java.lang.StringBuilder("000000000");
                let asString = new String(value).toString();
                toReturn = toReturn.replace(9 - asString.length, 9, asString);
                return toReturn.toString();
            }
            after$java_sql_Timestamp(ts) {
                return (this.getTime() > ts.getTime()) || (this.getTime() === ts.getTime() && this.getNanos() > ts.getNanos());
            }
            after(ts) {
                if (((ts != null && ts instanceof java.sql.Timestamp) || ts === null)) {
                    return this.after$java_sql_Timestamp(ts);
                }
                else if (((ts != null && ts instanceof sql.Date) || ts === null)) {
                    super.after(ts);
                }
                else
                    throw new Error('invalid overload');
            }
            before$java_sql_Timestamp(ts) {
                return (this.getTime() < ts.getTime()) || (this.getTime() === ts.getTime() && this.getNanos() < ts.getNanos());
            }
            before(ts) {
                if (((ts != null && ts instanceof java.sql.Timestamp) || ts === null)) {
                    return this.before$java_sql_Timestamp(ts);
                }
                else if (((ts != null && ts instanceof sql.Date) || ts === null)) {
                    super.before(ts);
                }
                else
                    throw new Error('invalid overload');
            }
            compareTo$java_util_Date(o) {
                if (o != null && o instanceof java.sql.Timestamp) {
                    return this.compareTo$java_sql_Timestamp(o);
                }
                else {
                    return this.compareTo$java_sql_Timestamp(new Timestamp(o.getTime()));
                }
            }
            compareTo$java_sql_Timestamp(o) {
                let cmp = (this.getTime() - o.getTime());
                return cmp === 0 ? (this.getNanos() - o.getNanos()) : cmp;
            }
            compareTo(o) {
                if (((o != null && o instanceof java.sql.Timestamp) || o === null)) {
                    return this.compareTo$java_sql_Timestamp(o);
                }
                else if (((o != null && o instanceof sql.Date) || o === null)) {
                    return this.compareTo$java_util_Date(o);
                }
                else
                    throw new Error('invalid overload');
            }
            equals$java_lang_Object(ts) {
                return (ts != null && ts instanceof java.sql.Timestamp) && this.equals$java_sql_Timestamp(ts);
            }
            equals$java_sql_Timestamp(ts) {
                return ts != null && this.getTime() === ts.getTime() && this.getNanos() === ts.getNanos();
            }
            equals(ts) {
                if (((ts != null && ts instanceof java.sql.Timestamp) || ts === null)) {
                    return this.equals$java_sql_Timestamp(ts);
                }
                else if (((ts != null) || ts === null)) {
                    return this.equals$java_lang_Object(ts);
                }
                else
                    throw new Error('invalid overload');
            }
            getNanos() {
                return this.nanos;
            }
            /**
             *
             * @return {number}
             */
            getTime() {
                return super.getTime();
            }
            /**
             *
             * @return {number}
             */
            hashCode() {
                return ((o) => { if (o.hashCode) {
                    return o.hashCode();
                }
                else {
                    return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                } })(this);
            }
            setNanos(n) {
                if (n < 0 || n > 999999999) {
                    throw new java.lang.IllegalArgumentException("nanos out of range " + n);
                }
                this.nanos = n;
                super.setTime(((n => n < 0 ? Math.ceil(n) : Math.floor(n))(this.getTime() / 1000)) * 1000 + ((this.nanos / 1000000 | 0)));
            }
            /**
             *
             * @param {number} time
             */
            setTime(time) {
                super.setTime(time);
                this.nanos = ((((time % 1000) | 0)) * 1000000);
            }
        }
        sql.Timestamp = Timestamp;
        Timestamp["__class"] = "java.sql.Timestamp";
        Timestamp["__interfaces"] = ["java.lang.Cloneable", "java.lang.Comparable", "java.io.Serializable"];
    })(sql = java.sql || (java.sql = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        var logging;
        (function (logging) {
            /**
             * A simple console logger used in super dev mode.
             * @extends java.util.logging.Handler
             * @class
             */
            class SimpleConsoleLogHandler extends java.util.logging.Handler {
                /**
                 *
                 * @param {java.util.logging.LogRecord} record
                 */
                publish(record) {
                    if (!this.isLoggable(record)) {
                        return;
                    }
                    let level = this.toConsoleLogLevel(record.getLevel());
                    console.log(level, record.getMessage());
                    if (record.getThrown() != null) {
                        console.log(level, record.getThrown());
                    }
                }
                /*private*/ toConsoleLogLevel(level) {
                    let val = level.intValue();
                    if (val >= java.util.logging.Level.SEVERE_$LI$().intValue()) {
                        return "error";
                    }
                    else if (val >= java.util.logging.Level.WARNING_$LI$().intValue()) {
                        return "warn";
                    }
                    else if (val >= java.util.logging.Level.INFO_$LI$().intValue()) {
                        return "info";
                    }
                    else {
                        return "log";
                    }
                }
                /**
                 *
                 */
                close() {
                }
                /**
                 *
                 */
                flush() {
                }
            }
            logging.SimpleConsoleLogHandler = SimpleConsoleLogHandler;
            SimpleConsoleLogHandler["__class"] = "java.util.logging.SimpleConsoleLogHandler";
        })(logging = util.logging || (util.logging = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        class Scanner {
            constructor(string) {
                /*private*/ this.currentDelimiter = Scanner.whiteSpacePattern_$LI$();
                /*private*/ this.buf = (s => { let a = []; while (s-- > 0)
                    a.push(null); return a; })(1024);
                /*private*/ this.bufferFilledLength = 0;
                /*private*/ this.currentPosition = 0;
                /*private*/ this.nextTokenStart = 0;
                /*private*/ this.nextDelimiterStart = -1;
                /*private*/ this.nextDelimiterEnd = -1;
                /*private*/ this.defaultRadix = 10;
                /*private*/ this.closed = false;
                if (((typeof string === 'string') || string === null)) {
                    let __args = arguments;
                    {
                        let __args = arguments;
                        let reader = new java.io.StringReader(string);
                        if (this.reader === undefined)
                            this.reader = null;
                        if (this.matcher === undefined)
                            this.matcher = null;
                        if (this.nextDelimiterWithPattern === undefined)
                            this.nextDelimiterWithPattern = null;
                        this.currentDelimiter = Scanner.whiteSpacePattern_$LI$();
                        this.buf = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(1024);
                        this.bufferFilledLength = 0;
                        this.currentPosition = 0;
                        this.nextTokenStart = 0;
                        this.nextDelimiterStart = -1;
                        this.nextDelimiterEnd = -1;
                        this.defaultRadix = 10;
                        this.closed = false;
                        if (this.reader === undefined)
                            this.reader = null;
                        if (this.matcher === undefined)
                            this.matcher = null;
                        if (this.nextDelimiterWithPattern === undefined)
                            this.nextDelimiterWithPattern = null;
                        (() => {
                            this.reader = reader;
                        })();
                    }
                }
                else if (((string != null && string instanceof java.io.InputStream) || string === null)) {
                    let __args = arguments;
                    let inputStream = __args[0];
                    {
                        let __args = arguments;
                        let reader = new java.io.InputStreamReader(inputStream);
                        if (this.reader === undefined)
                            this.reader = null;
                        if (this.matcher === undefined)
                            this.matcher = null;
                        if (this.nextDelimiterWithPattern === undefined)
                            this.nextDelimiterWithPattern = null;
                        this.currentDelimiter = Scanner.whiteSpacePattern_$LI$();
                        this.buf = (s => { let a = []; while (s-- > 0)
                            a.push(null); return a; })(1024);
                        this.bufferFilledLength = 0;
                        this.currentPosition = 0;
                        this.nextTokenStart = 0;
                        this.nextDelimiterStart = -1;
                        this.nextDelimiterEnd = -1;
                        this.defaultRadix = 10;
                        this.closed = false;
                        if (this.reader === undefined)
                            this.reader = null;
                        if (this.matcher === undefined)
                            this.matcher = null;
                        if (this.nextDelimiterWithPattern === undefined)
                            this.nextDelimiterWithPattern = null;
                        (() => {
                            this.reader = reader;
                        })();
                    }
                }
                else if (((string != null && string instanceof java.io.Reader) || string === null)) {
                    let __args = arguments;
                    let reader = __args[0];
                    if (this.reader === undefined)
                        this.reader = null;
                    if (this.matcher === undefined)
                        this.matcher = null;
                    if (this.nextDelimiterWithPattern === undefined)
                        this.nextDelimiterWithPattern = null;
                    this.currentDelimiter = Scanner.whiteSpacePattern_$LI$();
                    this.buf = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(1024);
                    this.bufferFilledLength = 0;
                    this.currentPosition = 0;
                    this.nextTokenStart = 0;
                    this.nextDelimiterStart = -1;
                    this.nextDelimiterEnd = -1;
                    this.defaultRadix = 10;
                    this.closed = false;
                    if (this.reader === undefined)
                        this.reader = null;
                    if (this.matcher === undefined)
                        this.matcher = null;
                    if (this.nextDelimiterWithPattern === undefined)
                        this.nextDelimiterWithPattern = null;
                    (() => {
                        this.reader = reader;
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            forEachRemaining(consumer) {
                javaemul.internal.InternalPreconditions.checkNotNull((consumer));
                while ((this.hasNext())) {
                    {
                        (target => (typeof target === 'function') ? target(this.next()) : target.accept(this.next()))(consumer);
                    }
                }
                ;
            }
            remove() {
                throw new java.lang.UnsupportedOperationException();
            }
            static numeral_$LI$() { if (Scanner.numeral == null)
                Scanner.numeral = Scanner.digit + "+"; return Scanner.numeral; }
            ;
            static decimalNumeral_$LI$() { if (Scanner.decimalNumeral == null)
                Scanner.decimalNumeral = "(?:" + Scanner.numeral_$LI$() + "|" + Scanner.numeral_$LI$() + Scanner.decimalSeparator + Scanner.digit + "*|" + Scanner.decimalSeparator + Scanner.digit + "+)"; return Scanner.decimalNumeral; }
            ;
            static exponent_$LI$() { if (Scanner.exponent == null)
                Scanner.exponent = "(?:[eE][+-]?" + Scanner.digit + "+)"; return Scanner.exponent; }
            ;
            static decimal_$LI$() { if (Scanner.decimal == null)
                Scanner.decimal = "(?:[-+]?" + Scanner.decimalNumeral_$LI$() + Scanner.exponent_$LI$() + "?)"; return Scanner.decimal; }
            ;
            static signedNonNumber_$LI$() { if (Scanner.signedNonNumber == null)
                Scanner.signedNonNumber = "(?:[-+]?" + Scanner.nonNumber + ")"; return Scanner.signedNonNumber; }
            ;
            static booleanPattern_$LI$() { if (Scanner.booleanPattern == null)
                Scanner.booleanPattern = java.util.regex.Pattern.compile("true|TRUE|True|1|false|FALSE|False|0"); return Scanner.booleanPattern; }
            ;
            static integerPattern_$LI$() { if (Scanner.integerPattern == null)
                Scanner.integerPattern = java.util.regex.Pattern.compile("[-+]?" + Scanner.numeral_$LI$()); return Scanner.integerPattern; }
            ;
            static floatPattern_$LI$() { if (Scanner.floatPattern == null)
                Scanner.floatPattern = java.util.regex.Pattern.compile(Scanner.decimal_$LI$() + "|" + Scanner.hexFloat + "|" + Scanner.signedNonNumber_$LI$()); return Scanner.floatPattern; }
            ;
            static endLinePattern_$LI$() { if (Scanner.endLinePattern == null)
                Scanner.endLinePattern = java.util.regex.Pattern.compile("[\\n\\r]+"); return Scanner.endLinePattern; }
            ;
            static whiteSpacePattern_$LI$() { if (Scanner.whiteSpacePattern == null)
                Scanner.whiteSpacePattern = java.util.regex.Pattern.compile("\\s+"); return Scanner.whiteSpacePattern; }
            ;
            /**
             *
             */
            close() {
                this.closed = true;
                this.reader.close();
            }
            delimiter() {
                return this.currentDelimiter;
            }
            useDelimiter$java_lang_String(currentDelimiter) {
                return this.useDelimiter$java_util_regex_Pattern(java.util.regex.Pattern.compile$java_lang_String(currentDelimiter));
            }
            useDelimiter(currentDelimiter) {
                if (((typeof currentDelimiter === 'string') || currentDelimiter === null)) {
                    return this.useDelimiter$java_lang_String(currentDelimiter);
                }
                else if (((currentDelimiter != null && currentDelimiter instanceof java.util.regex.Pattern) || currentDelimiter === null)) {
                    return this.useDelimiter$java_util_regex_Pattern(currentDelimiter);
                }
                else
                    throw new Error('invalid overload');
            }
            useDelimiter$java_util_regex_Pattern(currentDelimiter) {
                this.currentDelimiter = currentDelimiter;
                return this;
            }
            hasNext$() {
                if (this.closed && this.currentPosition === this.bufferFilledLength)
                    return false;
                if (this.nextDelimiterStart === -1 || this.nextDelimiterWithPattern !== this.currentDelimiter) {
                    this.searchNextTo$java_util_regex_Pattern(this.currentDelimiter);
                    this.nextDelimiterWithPattern = this.currentDelimiter;
                }
                return this.currentPosition !== this.bufferFilledLength;
            }
            /*private*/ searchNextTo$java_util_regex_Pattern(pattern) {
                this.searchNextTo$java_util_regex_Pattern$boolean(pattern, false);
            }
            searchNextTo$java_util_regex_Pattern$boolean(pattern, canBeEmpty) {
                try {
                    this.nextTokenStart = 0;
                    while ((!this.closed || this.bufferFilledLength !== this.currentPosition + this.nextTokenStart)) {
                        {
                            this.matcher = pattern.matcher(((str, index, len) => str.substring(index, index + len))((this.buf).join(''), this.currentPosition + this.nextTokenStart, this.bufferFilledLength - this.currentPosition - this.nextTokenStart));
                            if (this.matcher.find()) {
                                if (this.matcher.start() > 0 || canBeEmpty) {
                                    this.nextDelimiterStart = this.currentPosition + this.nextTokenStart + this.matcher.start();
                                    this.nextDelimiterEnd = this.currentPosition + this.nextTokenStart + this.matcher.end();
                                    return;
                                }
                                this.nextTokenStart += this.matcher.end();
                                if (this.currentPosition + this.nextTokenStart < this.bufferFilledLength)
                                    continue;
                            }
                            if (this.buf.length === this.bufferFilledLength) {
                                if (this.currentPosition < (this.buf.length / 2 | 0)) {
                                    let chars = (s => { let a = []; while (s-- > 0)
                                        a.push(null); return a; })(this.buf.length * 2);
                                    java.lang.System.arraycopy(this.buf, this.currentPosition, chars, 0, this.bufferFilledLength - this.currentPosition);
                                    this.buf = chars;
                                }
                                else {
                                    java.lang.System.arraycopy(this.buf, this.currentPosition, this.buf, 0, this.bufferFilledLength - this.currentPosition);
                                }
                                this.bufferFilledLength -= this.currentPosition;
                                this.currentPosition = 0;
                                this.nextDelimiterStart = this.nextDelimiterEnd = -1;
                            }
                            if (this.closed)
                                break;
                            let read = this.reader.read$char_A$int$int(this.buf, this.bufferFilledLength, this.buf.length - this.bufferFilledLength);
                            if (read <= 0) {
                                try {
                                    this.close();
                                }
                                catch (ignored) {
                                }
                                ;
                            }
                            else {
                                this.bufferFilledLength += read;
                            }
                        }
                    }
                    ;
                }
                catch (ignored) {
                    try {
                        this.close();
                    }
                    catch (ignored2) {
                    }
                    ;
                }
                ;
                this.nextDelimiterStart = this.nextDelimiterEnd = this.bufferFilledLength;
            }
            searchNextTo(pattern, canBeEmpty) {
                if (((pattern != null && pattern instanceof java.util.regex.Pattern) || pattern === null) && ((typeof canBeEmpty === 'boolean') || canBeEmpty === null)) {
                    return this.searchNextTo$java_util_regex_Pattern$boolean(pattern, canBeEmpty);
                }
                else if (((pattern != null && pattern instanceof java.util.regex.Pattern) || pattern === null) && canBeEmpty === undefined) {
                    return this.searchNextTo$java_util_regex_Pattern(pattern);
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             *
             * @return {string}
             */
            next() {
                if (!this.hasNext())
                    throw new java.util.NoSuchElementException("No more token");
                let result = ((str, index, len) => str.substring(index, index + len))((this.buf).join(''), this.currentPosition + this.nextTokenStart, this.nextDelimiterStart - this.currentPosition - this.nextTokenStart);
                this.currentPosition = this.nextDelimiterStart;
                this.nextDelimiterStart = this.nextDelimiterEnd = -1;
                return result;
            }
            hasNext$java_util_regex_Pattern(pattern) {
                return this.hasNext() && pattern.matcher(((str, index, len) => str.substring(index, index + len))((this.buf).join(''), this.currentPosition + this.nextTokenStart, this.nextDelimiterStart - this.currentPosition - this.nextTokenStart)).matches();
            }
            hasNext(pattern) {
                if (((pattern != null && pattern instanceof java.util.regex.Pattern) || pattern === null)) {
                    return this.hasNext$java_util_regex_Pattern(pattern);
                }
                else if (((typeof pattern === 'string') || pattern === null)) {
                    return this.hasNext$java_lang_String(pattern);
                }
                else if (pattern === undefined) {
                    return this.hasNext$();
                }
                else
                    throw new Error('invalid overload');
            }
            hasNext$java_lang_String(pattern) {
                return this.hasNext() && java.util.regex.Pattern.matches(pattern, ((str, index, len) => str.substring(index, index + len))((this.buf).join(''), this.currentPosition + this.nextTokenStart, this.nextDelimiterStart - this.currentPosition - this.nextTokenStart));
            }
            radix() {
                return this.defaultRadix;
            }
            hasNextBoolean() {
                return this.hasNext$java_util_regex_Pattern(Scanner.booleanPattern_$LI$());
            }
            nextBoolean() {
                if (!this.hasNextBoolean())
                    throw new java.util.InputMismatchException("Next token is not a boolean");
                let firstChar = this.next().charAt(0);
                return (c => c.charCodeAt == null ? c : c.charCodeAt(0))(firstChar) == 't'.charCodeAt(0) || (c => c.charCodeAt == null ? c : c.charCodeAt(0))(firstChar) == 'T'.charCodeAt(0) || (c => c.charCodeAt == null ? c : c.charCodeAt(0))(firstChar) == '1'.charCodeAt(0);
            }
            hasNextByte() {
                return this.hasNext$java_util_regex_Pattern(Scanner.integerPattern_$LI$());
            }
            nextByte() {
                if (!this.hasNextByte())
                    throw new java.util.InputMismatchException("Next token is not a byte");
                return javaemul.internal.ByteHelper.parseByte(this.next());
            }
            hasNextDouble() {
                return this.hasNext$java_util_regex_Pattern(Scanner.floatPattern_$LI$());
            }
            nextDouble() {
                if (!this.hasNextDouble())
                    throw new java.util.InputMismatchException("Next token is not a double");
                return javaemul.internal.DoubleHelper.parseDouble(this.next());
            }
            hasNextFloat() {
                return this.hasNext$java_util_regex_Pattern(Scanner.floatPattern_$LI$());
            }
            nextFloat() {
                if (!this.hasNextFloat())
                    throw new java.util.InputMismatchException("Next token is not a float");
                return javaemul.internal.FloatHelper.parseFloat(this.next());
            }
            hasNextInt() {
                return this.hasNext$java_util_regex_Pattern(Scanner.integerPattern_$LI$());
            }
            nextInt() {
                if (!this.hasNextInt())
                    throw new java.util.InputMismatchException("Next token is not a int");
                return javaemul.internal.IntegerHelper.parseInt(this.next());
            }
            hasNextLine() {
                if (this.closed && this.currentPosition === this.bufferFilledLength)
                    return false;
                if (this.nextDelimiterStart === -1 || this.nextDelimiterWithPattern !== Scanner.endLinePattern_$LI$()) {
                    this.searchNextTo$java_util_regex_Pattern$boolean(Scanner.endLinePattern_$LI$(), true);
                    this.nextDelimiterWithPattern = Scanner.endLinePattern_$LI$();
                }
                return this.currentPosition !== this.bufferFilledLength;
            }
            nextLine() {
                if (!this.hasNextLine())
                    throw new java.util.InputMismatchException("No new line");
                let result = ((str, index, len) => str.substring(index, index + len))((this.buf).join(''), this.currentPosition, this.nextDelimiterStart - this.currentPosition);
                this.currentPosition = this.nextDelimiterEnd;
                this.nextDelimiterStart = this.nextDelimiterEnd = -1;
                return result;
            }
            hasNextLong() {
                return this.hasNext$java_util_regex_Pattern(Scanner.integerPattern_$LI$());
            }
            nextLong() {
                if (!this.hasNextLong())
                    throw new java.util.InputMismatchException("Next token is not a long");
                return javaemul.internal.LongHelper.parseLong(this.next());
            }
            hasNextShort() {
                return this.hasNext$java_util_regex_Pattern(Scanner.integerPattern_$LI$());
            }
            nextShort() {
                if (!this.hasNextShort())
                    throw new java.util.InputMismatchException("Next token is not a short");
                return javaemul.internal.ShortHelper.parseShort(this.next());
            }
            reset() {
                return this.useDelimiter$java_util_regex_Pattern(Scanner.whiteSpacePattern_$LI$());
            }
            skip$java_lang_String(pattern) {
                return this.skip$java_util_regex_Pattern(java.util.regex.Pattern.compile$java_lang_String(pattern));
            }
            skip(pattern) {
                if (((typeof pattern === 'string') || pattern === null)) {
                    return this.skip$java_lang_String(pattern);
                }
                else if (((pattern != null && pattern instanceof java.util.regex.Pattern) || pattern === null)) {
                    return this.skip$java_util_regex_Pattern(pattern);
                }
                else
                    throw new Error('invalid overload');
            }
            skip$java_util_regex_Pattern(pattern) {
                if (this.closed && this.currentPosition === this.bufferFilledLength)
                    throw new java.util.NoSuchElementException("No more token");
                this.searchNextTo$java_util_regex_Pattern$boolean(pattern, true);
                if (this.nextDelimiterStart !== this.currentPosition) {
                    throw new java.util.NoSuchElementException("The specified pattern was not found");
                }
                this.currentPosition = this.nextDelimiterEnd;
                this.nextDelimiterStart = this.nextDelimiterEnd = -1;
                return this;
            }
            findInLine$java_lang_String(pattern) {
                return this.findInLine$java_util_regex_Pattern(java.util.regex.Pattern.compile$java_lang_String(pattern));
            }
            findInLine(pattern) {
                if (((typeof pattern === 'string') || pattern === null)) {
                    return this.findInLine$java_lang_String(pattern);
                }
                else if (((pattern != null && pattern instanceof java.util.regex.Pattern) || pattern === null)) {
                    return this.findInLine$java_util_regex_Pattern(pattern);
                }
                else
                    throw new Error('invalid overload');
            }
            findInLine$java_util_regex_Pattern(pattern) {
                if (!this.hasNextLine()) {
                    return null;
                }
                this.matcher = pattern.matcher(((str, index, len) => str.substring(index, index + len))((this.buf).join(''), this.currentPosition, this.nextDelimiterStart - this.currentPosition));
                if (this.matcher.find()) {
                    this.nextLine();
                    return this.matcher.group();
                }
                else {
                    this.nextDelimiterStart = this.nextDelimiterEnd = -1;
                    return null;
                }
            }
            match() {
                if (this.matcher == null)
                    throw new java.lang.IllegalStateException("No match result is available");
                return this.matcher;
            }
        }
        Scanner.digit = "[\\d]";
        Scanner.decimalSeparator = "[.,]";
        Scanner.hexFloat = "(?:[-+]?0[xX][0-9a-fA-F]*\\.[0-9a-fA-F]+(?:[pP][-+]?[0-9]+)?)";
        Scanner.nonNumber = "(?:NaN|Infinity)";
        util.Scanner = Scanner;
        Scanner["__class"] = "java.util.Scanner";
        Scanner["__interfaces"] = ["java.util.Iterator", "java.io.Closeable", "java.lang.AutoCloseable"];
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        class Timer {
            constructor(name, daemon) {
                this.timeouts = (new Array());
                this.intervals = (new Array());
                if (((typeof name === 'string') || name === null) && ((typeof daemon === 'boolean') || daemon === null)) {
                    let __args = arguments;
                    if (this.name === undefined)
                        this.name = null;
                    this.timeouts = (new Array());
                    this.intervals = (new Array());
                    if (this.name === undefined)
                        this.name = null;
                    (() => {
                        this.name = name;
                    })();
                }
                else if (((typeof name === 'string') || name === null) && daemon === undefined) {
                    let __args = arguments;
                    {
                        let __args = arguments;
                        let daemon = true;
                        if (this.name === undefined)
                            this.name = null;
                        this.timeouts = (new Array());
                        this.intervals = (new Array());
                        if (this.name === undefined)
                            this.name = null;
                        (() => {
                            this.name = name;
                        })();
                    }
                }
                else if (((typeof name === 'boolean') || name === null) && daemon === undefined) {
                    let __args = arguments;
                    let daemon = __args[0];
                    {
                        let __args = arguments;
                        {
                            let __args = arguments;
                            let name = "Timer-" + ++Timer.nextSerialNumber;
                            let daemon = true;
                            if (this.name === undefined)
                                this.name = null;
                            this.timeouts = (new Array());
                            this.intervals = (new Array());
                            if (this.name === undefined)
                                this.name = null;
                            (() => {
                                this.name = name;
                            })();
                        }
                    }
                }
                else if (name === undefined && daemon === undefined) {
                    let __args = arguments;
                    {
                        let __args = arguments;
                        let name = "Timer-" + ++Timer.nextSerialNumber;
                        let daemon = true;
                        if (this.name === undefined)
                            this.name = null;
                        this.timeouts = (new Array());
                        this.intervals = (new Array());
                        if (this.name === undefined)
                            this.name = null;
                        (() => {
                            this.name = name;
                        })();
                    }
                }
                else
                    throw new Error('invalid overload');
            }
            schedule$java_util_TimerTask$long(task, delay) {
                if (delay < 0) {
                    throw new java.lang.IllegalArgumentException("Negative delay.");
                }
                else {
                    this.schedule$java_util_TimerTask$java_util_Date(task, new util.Date(java.lang.System.currentTimeMillis() + delay));
                }
            }
            schedule$java_util_TimerTask$java_util_Date(task, time) {
                task.nextExecutionTime = time.getTime();
                task.handle = (window.setTimeout((() => {
                    if (task.state !== java.util.TimerTask.CANCELLED) {
                        task.run();
                        task.state = java.util.TimerTask.EXECUTED;
                    }
                    this.timeouts.splice(this.timeouts.indexOf(task), 1);
                }), time.getTime() - java.lang.System.currentTimeMillis()) | 0);
                this.timeouts.push(task);
                task.state = java.util.TimerTask.SCHEDULED;
            }
            schedule$java_util_TimerTask$long$long(task, delay, period) {
                if (delay < 0) {
                    throw new java.lang.IllegalArgumentException("Negative delay.");
                }
                else {
                    this.schedule$java_util_TimerTask$java_util_Date$long(task, new util.Date(java.lang.System.currentTimeMillis() + delay), period);
                }
            }
            schedule$java_util_TimerTask$java_util_Date$long(task, time, period) {
                if (period <= 0) {
                    throw new java.lang.IllegalArgumentException("Non-positive period.");
                }
                else {
                    task.period = period;
                    task.nextExecutionTime = time.getTime();
                    task.handle = (window.setTimeout((() => {
                        if (task.state !== java.util.TimerTask.CANCELLED) {
                            task.run();
                            this.schedule$java_util_TimerTask$long$long(task, period, period);
                        }
                        else {
                            this.timeouts.splice(this.timeouts.indexOf(task), 1);
                        }
                    }), time.getTime() - java.lang.System.currentTimeMillis()) | 0);
                    this.timeouts.push(task);
                    task.state = java.util.TimerTask.SCHEDULED;
                }
            }
            schedule(task, time, period) {
                if (((task != null && task instanceof java.util.TimerTask) || task === null) && ((time != null && time instanceof util.Date) || time === null) && ((typeof period === 'number') || period === null)) {
                    return this.schedule$java_util_TimerTask$java_util_Date$long(task, time, period);
                }
                else if (((task != null && task instanceof java.util.TimerTask) || task === null) && ((typeof time === 'number') || time === null) && ((typeof period === 'number') || period === null)) {
                    return this.schedule$java_util_TimerTask$long$long(task, time, period);
                }
                else if (((task != null && task instanceof java.util.TimerTask) || task === null) && ((time != null && time instanceof util.Date) || time === null) && period === undefined) {
                    return this.schedule$java_util_TimerTask$java_util_Date(task, time);
                }
                else if (((task != null && task instanceof java.util.TimerTask) || task === null) && ((typeof time === 'number') || time === null) && period === undefined) {
                    return this.schedule$java_util_TimerTask$long(task, time);
                }
                else
                    throw new Error('invalid overload');
            }
            scheduleAtFixedRate$java_util_TimerTask$long$long(task, delay, period) {
                if (delay < 0) {
                    throw new java.lang.IllegalArgumentException("Negative delay.");
                }
                else {
                    this.scheduleAtFixedRate$java_util_TimerTask$java_util_Date$long(task, new util.Date(java.lang.System.currentTimeMillis() + delay), period);
                }
            }
            scheduleAtFixedRate$java_util_TimerTask$java_util_Date$long(task, time, period) {
                if (period <= 0) {
                    throw new java.lang.IllegalArgumentException("Non-positive period.");
                }
                else {
                    task.period = period;
                    task.nextExecutionTime = time.getTime();
                    let start = new Timer.Timer$0(this, task);
                    this.schedule$java_util_TimerTask$java_util_Date(start, time);
                    task.handle = start.handle;
                }
            }
            scheduleAtFixedRate(task, time, period) {
                if (((task != null && task instanceof java.util.TimerTask) || task === null) && ((time != null && time instanceof util.Date) || time === null) && ((typeof period === 'number') || period === null)) {
                    return this.scheduleAtFixedRate$java_util_TimerTask$java_util_Date$long(task, time, period);
                }
                else if (((task != null && task instanceof java.util.TimerTask) || task === null) && ((typeof time === 'number') || time === null) && ((typeof period === 'number') || period === null)) {
                    return this.scheduleAtFixedRate$java_util_TimerTask$long$long(task, time, period);
                }
                else
                    throw new Error('invalid overload');
            }
            cancel() {
                for (let index138 = 0; index138 < this.timeouts.length; index138++) {
                    let task = this.timeouts[index138];
                    {
                        clearTimeout(task.handle);
                    }
                }
                for (let index139 = 0; index139 < this.intervals.length; index139++) {
                    let task = this.intervals[index139];
                    {
                        clearInterval(task.handle);
                    }
                }
                this.intervals = (new Array());
                this.timeouts = (new Array());
            }
            purge() {
                let newTimeouts = this.timeouts.filter((timerTask) => timerTask.handle !== java.util.TimerTask.EXECUTED && timerTask.handle !== java.util.TimerTask.CANCELLED);
                let newIntervals = this.intervals.filter((timerTask) => timerTask.handle !== java.util.TimerTask.EXECUTED && timerTask.handle !== java.util.TimerTask.CANCELLED);
                let purged = this.timeouts.length - newTimeouts.length + this.intervals.length - newIntervals.length;
                this.timeouts = newTimeouts;
                this.intervals = newIntervals;
                return purged;
            }
        }
        Timer.nextSerialNumber = 0;
        util.Timer = Timer;
        Timer["__class"] = "java.util.Timer";
        (function (Timer) {
            class Timer$0 extends java.util.TimerTask {
                constructor(__parent, task) {
                    super();
                    this.task = task;
                    this.__parent = __parent;
                }
                /**
                 *
                 */
                run() {
                    if (this.task.state !== java.util.TimerTask.CANCELLED) {
                        this.task.nextExecutionTime = java.lang.System.currentTimeMillis() + this.task.period;
                        this.task.handle = (window.setInterval((() => {
                            if (this.task.state !== java.util.TimerTask.CANCELLED) {
                                this.task.nextExecutionTime = java.lang.System.currentTimeMillis() + this.task.period;
                                this.task.run();
                            }
                            else {
                                clearInterval(this.task.handle);
                                this.__parent.intervals.splice(this.__parent.intervals.indexOf(this.task), 1);
                            }
                        }), this.task.period) | 0);
                        this.__parent.intervals.push(this.task);
                        this.task.run();
                    }
                }
            }
            Timer.Timer$0 = Timer$0;
            Timer$0["__interfaces"] = ["java.lang.Runnable"];
        })(Timer = util.Timer || (util.Timer = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (javaemul) {
    var internal;
    (function (internal) {
        /**
         * Wraps native <code>byte</code> as an object.
         * @param {number} value
         * @class
         * @extends javaemul.internal.NumberHelper
         */
        class ByteHelper extends javaemul.internal.NumberHelper {
            constructor(s) {
                if (((typeof s === 'string') || s === null)) {
                    let __args = arguments;
                    super();
                    if (this.value === undefined)
                        this.value = 0;
                    if (this.value === undefined)
                        this.value = 0;
                    (() => {
                        this.value = ByteHelper.parseByte(s);
                    })();
                }
                else if (((typeof s === 'number') || s === null)) {
                    let __args = arguments;
                    let value = __args[0];
                    super();
                    if (this.value === undefined)
                        this.value = 0;
                    if (this.value === undefined)
                        this.value = 0;
                    (() => {
                        this.value = value;
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            static MIN_VALUE_$LI$() { if (ByteHelper.MIN_VALUE == null)
                ByteHelper.MIN_VALUE = (128 | 0); return ByteHelper.MIN_VALUE; }
            ;
            static MAX_VALUE_$LI$() { if (ByteHelper.MAX_VALUE == null)
                ByteHelper.MAX_VALUE = (127 | 0); return ByteHelper.MAX_VALUE; }
            ;
            static TYPE_$LI$() { if (ByteHelper.TYPE == null)
                ByteHelper.TYPE = Number; return ByteHelper.TYPE; }
            ;
            static compare(x, y) {
                return x - y;
            }
            static decode(s) {
                return ByteHelper.valueOf$byte((internal.NumberHelper.__decodeAndValidateInt(s, ByteHelper.MIN_VALUE_$LI$(), ByteHelper.MAX_VALUE_$LI$()) | 0));
            }
            /**
             * @skip
             *
             * Here for shared implementation with Arrays.hashCode
             * @param {number} b
             * @return {number}
             */
            static hashCode(b) {
                return b;
            }
            static parseByte(s, radix = 10) {
                return (internal.NumberHelper.__parseAndValidateInt(s, radix, ByteHelper.MIN_VALUE_$LI$(), ByteHelper.MAX_VALUE_$LI$()) | 0);
            }
            static toString(b) {
                return new String(b).toString();
            }
            static valueOf$byte(b) {
                let rebase = b + 128;
                let result = ByteHelper.BoxedValues.boxedValues_$LI$()[rebase];
                if (result == null) {
                    result = ByteHelper.BoxedValues.boxedValues_$LI$()[rebase] = new Number(b);
                }
                return result;
            }
            static valueOf$java_lang_String(s) {
                return ByteHelper.valueOf$java_lang_String$int(s, 10);
            }
            static valueOf$java_lang_String$int(s, radix) {
                return javaemul.internal.ByteHelper.valueOf(ByteHelper.parseByte(s, radix));
            }
            static valueOf(s, radix) {
                if (((typeof s === 'string') || s === null) && ((typeof radix === 'number') || radix === null)) {
                    return javaemul.internal.ByteHelper.valueOf$java_lang_String$int(s, radix);
                }
                else if (((typeof s === 'string') || s === null) && radix === undefined) {
                    return javaemul.internal.ByteHelper.valueOf$java_lang_String(s);
                }
                else if (((typeof s === 'number') || s === null) && radix === undefined) {
                    return javaemul.internal.ByteHelper.valueOf$byte(s);
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             *
             * @return {number}
             */
            byteValue() {
                return this.value;
            }
            compareTo$javaemul_internal_ByteHelper(b) {
                return ByteHelper.compare(this.value, b.value);
            }
            /**
             *
             * @param {javaemul.internal.ByteHelper} b
             * @return {number}
             */
            compareTo(b) {
                if (((b != null && b instanceof javaemul.internal.ByteHelper) || b === null)) {
                    return this.compareTo$javaemul_internal_ByteHelper(b);
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             *
             * @return {number}
             */
            doubleValue() {
                return this.value;
            }
            /**
             *
             * @param {*} o
             * @return {boolean}
             */
            equals(o) {
                return (o != null && o instanceof javaemul.internal.ByteHelper) && (o.value === this.value);
            }
            /**
             *
             * @return {number}
             */
            floatValue() {
                return this.value;
            }
            /**
             *
             * @return {number}
             */
            hashCode() {
                return ByteHelper.hashCode(this.value);
            }
            /**
             *
             * @return {number}
             */
            intValue() {
                return this.value;
            }
            /**
             *
             * @return {number}
             */
            longValue() {
                return this.value;
            }
            /**
             *
             * @return {number}
             */
            shortValue() {
                return this.value;
            }
            /**
             *
             * @return {string}
             */
            toString() {
                return ByteHelper.toString(this.value);
            }
        }
        ByteHelper.SIZE = 8;
        internal.ByteHelper = ByteHelper;
        ByteHelper["__class"] = "javaemul.internal.ByteHelper";
        ByteHelper["__interfaces"] = ["java.lang.Comparable", "java.io.Serializable"];
        (function (ByteHelper) {
            /**
             * Use nested class to avoid clinit on outer.
             * @class
             */
            class BoxedValues {
                constructor() {
                }
                static boxedValues_$LI$() { if (BoxedValues.boxedValues == null)
                    BoxedValues.boxedValues = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(256); return BoxedValues.boxedValues; }
                ;
            }
            ByteHelper.BoxedValues = BoxedValues;
            BoxedValues["__class"] = "javaemul.internal.ByteHelper.BoxedValues";
        })(ByteHelper = internal.ByteHelper || (internal.ByteHelper = {}));
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
(function (javaemul) {
    var internal;
    (function (internal) {
        /**
         * Wraps a primitive <code>double</code> as an object.
         * @param {number} value
         * @class
         * @extends javaemul.internal.NumberHelper
         */
        class DoubleHelper extends javaemul.internal.NumberHelper {
            constructor(s) {
                if (((typeof s === 'string') || s === null)) {
                    let __args = arguments;
                    super();
                }
                else if (((typeof s === 'number') || s === null)) {
                    let __args = arguments;
                    let value = __args[0];
                    super();
                }
                else
                    throw new Error('invalid overload');
            }
            static compare(x, y) {
                if (x < y) {
                    return -1;
                }
                if (x > y) {
                    return 1;
                }
                if (x === y) {
                    return 0;
                }
                if (DoubleHelper.isNaN(x)) {
                    if (DoubleHelper.isNaN(y)) {
                        return 0;
                    }
                    else {
                        return 1;
                    }
                }
                else {
                    return -1;
                }
            }
            static doubleToLongBits(value) {
                if (DoubleHelper.isNaN(value)) {
                    return 9221120237041090560;
                }
                let negative = false;
                if (value === 0.0) {
                    if (1.0 / value === DoubleHelper.NEGATIVE_INFINITY) {
                        return -9223372036854775808;
                    }
                    else {
                        return 0;
                    }
                }
                if (value < 0.0) {
                    negative = true;
                    value = -value;
                }
                if (DoubleHelper.isInfinite(value)) {
                    if (negative) {
                        return -4503599627370496;
                    }
                    else {
                        return 9218868437227405312;
                    }
                }
                let exp = 0;
                if (value < 1.0) {
                    let bit = 512;
                    for (let i = 0; i < 10; i++, bit >>= 1) {
                        {
                            if (value < DoubleHelper.PowersTable.invPowers_$LI$()[i] && exp - bit >= -1023) {
                                value *= DoubleHelper.PowersTable.powers_$LI$()[i];
                                exp -= bit;
                            }
                        }
                        ;
                    }
                    if (value < 1.0 && exp - 1 >= -1023) {
                        value *= 2.0;
                        exp--;
                    }
                }
                else if (value >= 2.0) {
                    let bit = 512;
                    for (let i = 0; i < 10; i++, bit >>= 1) {
                        {
                            if (value >= DoubleHelper.PowersTable.powers_$LI$()[i]) {
                                value *= DoubleHelper.PowersTable.invPowers_$LI$()[i];
                                exp += bit;
                            }
                        }
                        ;
                    }
                }
                if (exp > -1023) {
                    value -= 1.0;
                }
                else {
                    value *= 0.5;
                }
                let ihi = (n => n < 0 ? Math.ceil(n) : Math.floor(n))((value * DoubleHelper.POWER_20));
                value -= ihi * DoubleHelper.POWER_MINUS_20;
                let ilo = (n => n < 0 ? Math.ceil(n) : Math.floor(n))((value * DoubleHelper.POWER_52));
                ihi |= (exp + 1023) << 20;
                if (negative) {
                    ihi |= 2147483648;
                }
                return (ihi << 32) | ilo;
            }
            /**
             * @skip Here for shared implementation with Arrays.hashCode
             * @param {number} d
             * @return {number}
             */
            static hashCode(d) {
                return (d | 0);
            }
            static isInfinite(x) {
                return x === javaemul.internal.JsUtils.getInfinity() || x === -javaemul.internal.JsUtils.getInfinity();
            }
            static isNaN(x) {
                return (isNaN(x));
            }
            static longBitsToDouble(bits) {
                let ihi = (n => n < 0 ? Math.ceil(n) : Math.floor(n))((bits >> 32));
                let ilo = (n => n < 0 ? Math.ceil(n) : Math.floor(n))((bits & 4294967295));
                if (ihi < 0) {
                    ihi += 4294967296;
                }
                if (ilo < 0) {
                    ilo += 4294967296;
                }
                let negative = (ihi & -2147483648) !== 0;
                let exp = (((ihi >> 20) & 2047) | 0);
                ihi &= 1048575;
                if (exp === 0) {
                    let d = (ihi * DoubleHelper.POWER_MINUS_20) + (ilo * DoubleHelper.POWER_MINUS_52);
                    d *= DoubleHelper.POWER_MINUS_1022;
                    return negative ? (d === 0.0 ? -0.0 : -d) : d;
                }
                else if (exp === 2047) {
                    if (ihi === 0 && ilo === 0) {
                        return negative ? DoubleHelper.NEGATIVE_INFINITY : DoubleHelper.POSITIVE_INFINITY;
                    }
                    else {
                        return DoubleHelper.NaN;
                    }
                }
                exp -= 1023;
                let d = 1.0 + (ihi * DoubleHelper.POWER_MINUS_20) + (ilo * DoubleHelper.POWER_MINUS_52);
                if (exp > 0) {
                    let bit = 512;
                    for (let i = 0; i < 10; i++, bit >>= 1) {
                        {
                            if (exp >= bit) {
                                d *= DoubleHelper.PowersTable.powers_$LI$()[i];
                                exp -= bit;
                            }
                        }
                        ;
                    }
                }
                else if (exp < 0) {
                    while ((exp < 0)) {
                        {
                            let bit = 512;
                            for (let i = 0; i < 10; i++, bit >>= 1) {
                                {
                                    if (exp <= -bit) {
                                        d *= DoubleHelper.PowersTable.invPowers_$LI$()[i];
                                        exp += bit;
                                    }
                                }
                                ;
                            }
                        }
                    }
                    ;
                }
                return negative ? -d : d;
            }
            static parseDouble(s) {
                return internal.NumberHelper.__parseAndValidateDouble(s);
            }
            static toString(b) {
                return new String(b).toString();
            }
            static valueOf$double(d) {
                return new Number(d);
            }
            static valueOf$java_lang_String(s) {
                return new Number(s);
            }
            static valueOf(s) {
                if (((typeof s === 'string') || s === null)) {
                    return javaemul.internal.DoubleHelper.valueOf$java_lang_String(s);
                }
                else if (((typeof s === 'number') || s === null)) {
                    return javaemul.internal.DoubleHelper.valueOf$double(s);
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             *
             * @return {number}
             */
            byteValue() {
                return (this.doubleValue() | 0);
            }
            compareTo$javaemul_internal_DoubleHelper(b) {
                return DoubleHelper.compare(this.doubleValue(), b.doubleValue());
            }
            /**
             *
             * @param {javaemul.internal.DoubleHelper} b
             * @return {number}
             */
            compareTo(b) {
                if (((b != null && b instanceof javaemul.internal.DoubleHelper) || b === null)) {
                    return this.compareTo$javaemul_internal_DoubleHelper(b);
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             *
             * @return {number}
             */
            doubleValue() {
                return DoubleHelper.unsafeCast((javaemul.internal.InternalPreconditions.checkNotNull(this)));
            }
            static unsafeCast(instance) {
                return (instance);
            }
            /**
             *
             * @param {*} o
             * @return {boolean}
             */
            equals(o) {
                return javaemul.internal.InternalPreconditions.checkNotNull(this) === o;
            }
            /**
             *
             * @return {number}
             */
            floatValue() {
                return Math.fround(this.doubleValue());
            }
            /**
             * Performance caution: using Double objects as map keys is not recommended.
             * Using double values as keys is generally a bad idea due to difficulty
             * determining exact equality. In addition, there is no efficient JavaScript
             * equivalent of <code>doubleToIntBits</code>. As a result, this method
             * computes a hash code by truncating the whole number portion of the
             * double, which may lead to poor performance for certain value sets if
             * Doubles are used as keys in a {@link java.util.HashMap}.
             * @return {number}
             */
            hashCode() {
                return DoubleHelper.hashCode(this.doubleValue());
            }
            /**
             *
             * @return {number}
             */
            intValue() {
                return (this.doubleValue() | 0);
            }
            isInfinite() {
                return DoubleHelper.isInfinite(this.doubleValue());
            }
            isNaN() {
                return DoubleHelper.isNaN(this.doubleValue());
            }
            /**
             *
             * @return {number}
             */
            longValue() {
                return (n => n < 0 ? Math.ceil(n) : Math.floor(n))(this.doubleValue());
            }
            /**
             *
             * @return {number}
             */
            shortValue() {
                return (this.doubleValue() | 0);
            }
            /**
             *
             * @return {string}
             */
            toString() {
                return DoubleHelper.toString(this.doubleValue());
            }
        }
        DoubleHelper.MAX_VALUE = 1.7976931348623157E308;
        DoubleHelper.MIN_VALUE = 4.9E-324;
        DoubleHelper.MIN_NORMAL = 2.2250738585072014E-308;
        DoubleHelper.MAX_EXPONENT = 1023;
        DoubleHelper.MIN_EXPONENT = -1022;
        DoubleHelper.NaN = 0.0 / 0.0;
        DoubleHelper.NEGATIVE_INFINITY = -1.0 / 0.0;
        DoubleHelper.POSITIVE_INFINITY = 1.0 / 0.0;
        DoubleHelper.SIZE = 64;
        DoubleHelper.POWER_512 = 1.3407807929942597E154;
        DoubleHelper.POWER_MINUS_512 = 7.458340731200207E-155;
        DoubleHelper.POWER_256 = 1.157920892373162E77;
        DoubleHelper.POWER_MINUS_256 = 8.636168555094445E-78;
        DoubleHelper.POWER_128 = 3.4028236692093846E38;
        DoubleHelper.POWER_MINUS_128 = 2.9387358770557188E-39;
        DoubleHelper.POWER_64 = 1.8446744073709552E19;
        DoubleHelper.POWER_MINUS_64 = 5.421010862427522E-20;
        DoubleHelper.POWER_52 = 4.503599627370496E15;
        DoubleHelper.POWER_MINUS_52 = 2.220446049250313E-16;
        DoubleHelper.POWER_32 = 4.294967296E9;
        DoubleHelper.POWER_MINUS_32 = 2.3283064365386963E-10;
        DoubleHelper.POWER_31 = 2.147483648E9;
        DoubleHelper.POWER_20 = 1048576.0;
        DoubleHelper.POWER_MINUS_20 = 9.5367431640625E-7;
        DoubleHelper.POWER_16 = 65536.0;
        DoubleHelper.POWER_MINUS_16 = 1.52587890625E-5;
        DoubleHelper.POWER_8 = 256.0;
        DoubleHelper.POWER_MINUS_8 = 0.00390625;
        DoubleHelper.POWER_4 = 16.0;
        DoubleHelper.POWER_MINUS_4 = 0.0625;
        DoubleHelper.POWER_2 = 4.0;
        DoubleHelper.POWER_MINUS_2 = 0.25;
        DoubleHelper.POWER_1 = 2.0;
        DoubleHelper.POWER_MINUS_1 = 0.5;
        DoubleHelper.POWER_MINUS_1022 = 2.2250738585072014E-308;
        internal.DoubleHelper = DoubleHelper;
        DoubleHelper["__class"] = "javaemul.internal.DoubleHelper";
        DoubleHelper["__interfaces"] = ["java.lang.Comparable", "java.io.Serializable"];
        (function (DoubleHelper) {
            class PowersTable {
                constructor() {
                }
                static powers_$LI$() { if (PowersTable.powers == null)
                    PowersTable.powers = [javaemul.internal.DoubleHelper.POWER_512, javaemul.internal.DoubleHelper.POWER_256, javaemul.internal.DoubleHelper.POWER_128, javaemul.internal.DoubleHelper.POWER_64, javaemul.internal.DoubleHelper.POWER_32, javaemul.internal.DoubleHelper.POWER_16, javaemul.internal.DoubleHelper.POWER_8, javaemul.internal.DoubleHelper.POWER_4, javaemul.internal.DoubleHelper.POWER_2, javaemul.internal.DoubleHelper.POWER_1]; return PowersTable.powers; }
                ;
                static invPowers_$LI$() { if (PowersTable.invPowers == null)
                    PowersTable.invPowers = [javaemul.internal.DoubleHelper.POWER_MINUS_512, javaemul.internal.DoubleHelper.POWER_MINUS_256, javaemul.internal.DoubleHelper.POWER_MINUS_128, javaemul.internal.DoubleHelper.POWER_MINUS_64, javaemul.internal.DoubleHelper.POWER_MINUS_32, javaemul.internal.DoubleHelper.POWER_MINUS_16, javaemul.internal.DoubleHelper.POWER_MINUS_8, javaemul.internal.DoubleHelper.POWER_MINUS_4, javaemul.internal.DoubleHelper.POWER_MINUS_2, javaemul.internal.DoubleHelper.POWER_MINUS_1]; return PowersTable.invPowers; }
                ;
            }
            DoubleHelper.PowersTable = PowersTable;
            PowersTable["__class"] = "javaemul.internal.DoubleHelper.PowersTable";
        })(DoubleHelper = internal.DoubleHelper || (internal.DoubleHelper = {}));
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
(function (javaemul) {
    var internal;
    (function (internal) {
        /**
         * Wraps a primitive <code>float</code> as an object.
         * @param {number} value
         * @class
         * @extends javaemul.internal.NumberHelper
         */
        class FloatHelper extends javaemul.internal.NumberHelper {
            constructor(s) {
                if (((typeof s === 'string') || s === null)) {
                    let __args = arguments;
                    super();
                    if (this.value === undefined)
                        this.value = 0;
                    if (this.value === undefined)
                        this.value = 0;
                    (() => {
                        this.value = FloatHelper.parseFloat(s);
                    })();
                }
                else if (((typeof s === 'number') || s === null)) {
                    let __args = arguments;
                    let value = __args[0];
                    super();
                    if (this.value === undefined)
                        this.value = 0;
                    if (this.value === undefined)
                        this.value = 0;
                    (() => {
                        this.value = value;
                    })();
                }
                else if (((typeof s === 'number') || s === null)) {
                    let __args = arguments;
                    let value = __args[0];
                    super();
                    if (this.value === undefined)
                        this.value = 0;
                    if (this.value === undefined)
                        this.value = 0;
                    (() => {
                        this.value = Math.fround(value);
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            static compare(x, y) {
                return javaemul.internal.DoubleHelper.compare(x, y);
            }
            static floatToIntBits(value) {
                if (FloatHelper.isNaN(value)) {
                    return 2143289344;
                }
                if (value === 0.0) {
                    if (1.0 / value === FloatHelper.NEGATIVE_INFINITY) {
                        return -2147483648;
                    }
                    else {
                        return 0;
                    }
                }
                let negative = false;
                if (value < 0.0) {
                    negative = true;
                    value = -value;
                }
                if (FloatHelper.isInfinite(value)) {
                    if (negative) {
                        return -8388608;
                    }
                    else {
                        return 2139095040;
                    }
                }
                let l = javaemul.internal.DoubleHelper.doubleToLongBits(value);
                let exp = ((((l >> 52) & 2047) - 1023) | 0);
                let mantissa = (((l & 4503599627370495) >> 29) | 0);
                if (exp <= -127) {
                    mantissa = (8388608 | mantissa) >> (-127 - exp + 1);
                    exp = -127;
                }
                let bits = negative ? FloatHelper.POWER_31_INT : 0;
                bits |= (exp + 127) << 23;
                bits |= mantissa;
                return (bits | 0);
            }
            /**
             * @skip Here for shared implementation with Arrays.hashCode.
             * @param {number} f
             * @return {number} hash value of float (currently just truncated to int)
             */
            static hashCode(f) {
                return (f | 0);
            }
            static intBitsToFloat(bits) {
                let negative = (bits & -2147483648) !== 0;
                let exp = (bits >> 23) & 255;
                bits &= 8388607;
                if (exp === 0) {
                    if (bits === 0) {
                        return negative ? -0.0 : 0.0;
                    }
                }
                else if (exp === 255) {
                    if (bits === 0) {
                        return negative ? FloatHelper.NEGATIVE_INFINITY : FloatHelper.POSITIVE_INFINITY;
                    }
                    else {
                        return FloatHelper.NaN;
                    }
                }
                if (exp === 0) {
                    exp = 1;
                    while (((bits & 8388608) === 0)) {
                        {
                            bits <<= 1;
                            exp--;
                        }
                    }
                    ;
                    bits &= 8388607;
                }
                let bits64 = negative ? -9223372036854775808 : 0;
                bits64 |= ((n => n < 0 ? Math.ceil(n) : Math.floor(n))((exp + 896))) << 52;
                bits64 |= ((n => n < 0 ? Math.ceil(n) : Math.floor(n))(bits)) << 29;
                return Math.fround(javaemul.internal.DoubleHelper.longBitsToDouble(bits64));
            }
            static isInfinite(x) {
                return javaemul.internal.DoubleHelper.isInfinite(x);
            }
            static isNaN(x) {
                return javaemul.internal.DoubleHelper.isNaN(x);
            }
            static parseFloat(s) {
                let doubleValue = internal.NumberHelper.__parseAndValidateDouble(s);
                if (doubleValue > FloatHelper.MAX_VALUE) {
                    return FloatHelper.POSITIVE_INFINITY;
                }
                else if (doubleValue < -FloatHelper.MAX_VALUE) {
                    return FloatHelper.NEGATIVE_INFINITY;
                }
                return Math.fround(doubleValue);
            }
            static toString(b) {
                return new String(b).toString();
            }
            static valueOf$float(f) {
                return new Number(f);
            }
            static valueOf$java_lang_String(s) {
                return new Number(s);
            }
            static valueOf(s) {
                if (((typeof s === 'string') || s === null)) {
                    return javaemul.internal.FloatHelper.valueOf$java_lang_String(s);
                }
                else if (((typeof s === 'number') || s === null)) {
                    return javaemul.internal.FloatHelper.valueOf$float(s);
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             *
             * @return {number}
             */
            byteValue() {
                return (this.value | 0);
            }
            compareTo$javaemul_internal_FloatHelper(b) {
                return FloatHelper.compare(this.value, b.value);
            }
            /**
             *
             * @param {javaemul.internal.FloatHelper} b
             * @return {number}
             */
            compareTo(b) {
                if (((b != null && b instanceof javaemul.internal.FloatHelper) || b === null)) {
                    return this.compareTo$javaemul_internal_FloatHelper(b);
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             *
             * @return {number}
             */
            doubleValue() {
                return this.value;
            }
            /**
             *
             * @param {*} o
             * @return {boolean}
             */
            equals(o) {
                return (o != null && o instanceof javaemul.internal.FloatHelper) && (o.value === this.value);
            }
            /**
             *
             * @return {number}
             */
            floatValue() {
                return this.value;
            }
            /**
             * Performance caution: using Float objects as map keys is not recommended.
             * Using floating point values as keys is generally a bad idea due to
             * difficulty determining exact equality. In addition, there is no efficient
             * JavaScript equivalent of <code>floatToIntBits</code>. As a result, this
             * method computes a hash code by truncating the whole number portion of the
             * float, which may lead to poor performance for certain value sets if
             * Floats are used as keys in a {@link java.util.HashMap}.
             * @return {number}
             */
            hashCode() {
                return FloatHelper.hashCode(this.value);
            }
            /**
             *
             * @return {number}
             */
            intValue() {
                return (this.value | 0);
            }
            isInfinite() {
                return FloatHelper.isInfinite(this.value);
            }
            isNaN() {
                return FloatHelper.isNaN(this.value);
            }
            /**
             *
             * @return {number}
             */
            longValue() {
                return (n => n < 0 ? Math.ceil(n) : Math.floor(n))(this.value);
            }
            /**
             *
             * @return {number}
             */
            shortValue() {
                return (this.value | 0);
            }
            /**
             *
             * @return {string}
             */
            toString() {
                return FloatHelper.toString(this.value);
            }
        }
        FloatHelper.MAX_VALUE = 3.4028235E38;
        FloatHelper.MIN_VALUE = 1.4E-45;
        FloatHelper.MAX_EXPONENT = 127;
        FloatHelper.MIN_EXPONENT = -126;
        FloatHelper.MIN_NORMAL = 1.17549435E-38;
        FloatHelper.NaN = Math.fround(0.0 / 0.0);
        FloatHelper.NEGATIVE_INFINITY = Math.fround(-1.0 / 0.0);
        FloatHelper.POSITIVE_INFINITY = Math.fround(1.0 / 0.0);
        FloatHelper.SIZE = 32;
        FloatHelper.POWER_31_INT = 2147483648;
        internal.FloatHelper = FloatHelper;
        FloatHelper["__class"] = "javaemul.internal.FloatHelper";
        FloatHelper["__interfaces"] = ["java.lang.Comparable", "java.io.Serializable"];
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
(function (javaemul) {
    var internal;
    (function (internal) {
        /**
         * Wraps a primitive <code>int</code> as an object.
         * @param {number} value
         * @class
         * @extends javaemul.internal.NumberHelper
         */
        class IntegerHelper extends javaemul.internal.NumberHelper {
            constructor(s) {
                if (((typeof s === 'string') || s === null)) {
                    let __args = arguments;
                    super();
                    if (this.value === undefined)
                        this.value = 0;
                    if (this.value === undefined)
                        this.value = 0;
                    (() => {
                        this.value = IntegerHelper.parseInt(s);
                    })();
                }
                else if (((typeof s === 'number') || s === null)) {
                    let __args = arguments;
                    let value = __args[0];
                    super();
                    if (this.value === undefined)
                        this.value = 0;
                    if (this.value === undefined)
                        this.value = 0;
                    (() => {
                        this.value = value;
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            static bitCount(x) {
                x -= ((x >> 1) & 1431655765);
                x = (((x >> 2) & 858993459) + (x & 858993459));
                x = (((x >> 4) + x) & 252645135);
                x += (x >> 8);
                x += (x >> 16);
                return x & 63;
            }
            static compare(x, y) {
                if (x < y) {
                    return -1;
                }
                else if (x > y) {
                    return 1;
                }
                else {
                    return 0;
                }
            }
            static decode(s) {
                return IntegerHelper.valueOf$int(internal.NumberHelper.__decodeAndValidateInt(s, IntegerHelper.MIN_VALUE, IntegerHelper.MAX_VALUE));
            }
            /**
             * @skip
             *
             * Here for shared implementation with Arrays.hashCode
             * @param {number} i
             * @return {number}
             */
            static hashCode(i) {
                return i;
            }
            static highestOneBit(i) {
                if (i < 0) {
                    return IntegerHelper.MIN_VALUE;
                }
                else if (i === 0) {
                    return 0;
                }
                else {
                    let rtn;
                    for (rtn = 1073741824; (rtn & i) === 0; rtn >>= 1) {
                        {
                        }
                        ;
                    }
                    return rtn;
                }
            }
            static lowestOneBit(i) {
                return i & -i;
            }
            static numberOfLeadingZeros(i) {
                if (i < 0) {
                    return 0;
                }
                else if (i === 0) {
                    return IntegerHelper.SIZE;
                }
                else {
                    let y;
                    let m;
                    let n;
                    y = -(i >> 16);
                    m = (y >> 16) & 16;
                    n = 16 - m;
                    i = i >> m;
                    y = i - 256;
                    m = (y >> 16) & 8;
                    n += m;
                    i <<= m;
                    y = i - 4096;
                    m = (y >> 16) & 4;
                    n += m;
                    i <<= m;
                    y = i - 16384;
                    m = (y >> 16) & 2;
                    n += m;
                    i <<= m;
                    y = i >> 14;
                    m = y & ~(y >> 1);
                    return n + 2 - m;
                }
            }
            static numberOfTrailingZeros(i) {
                if (i === 0) {
                    return IntegerHelper.SIZE;
                }
                else {
                    let rtn = 0;
                    for (let r = 1; (r & i) === 0; r <<= 1) {
                        {
                            rtn++;
                        }
                        ;
                    }
                    return rtn;
                }
            }
            static parseInt(s, radix = 10) {
                return internal.NumberHelper.__parseAndValidateInt(s, radix, IntegerHelper.MIN_VALUE, IntegerHelper.MAX_VALUE);
            }
            static reverse(i) {
                let nibbles = IntegerHelper.ReverseNibbles.reverseNibbles_$LI$();
                return (nibbles[i >>> 28]) | (nibbles[(i >> 24) & 15] << 4) | (nibbles[(i >> 20) & 15] << 8) | (nibbles[(i >> 16) & 15] << 12) | (nibbles[(i >> 12) & 15] << 16) | (nibbles[(i >> 8) & 15] << 20) | (nibbles[(i >> 4) & 15] << 24) | (nibbles[i & 15] << 28);
            }
            static reverseBytes(i) {
                return ((i & 255) << 24) | ((i & 65280) << 8) | ((i & 16711680) >> 8) | ((i & -16777216) >>> 24);
            }
            static rotateLeft(i, distance) {
                while ((distance-- > 0)) {
                    {
                        i = i << 1 | ((i < 0) ? 1 : 0);
                    }
                }
                ;
                return i;
            }
            static rotateRight(i, distance) {
                let ui = i & IntegerHelper.MAX_VALUE;
                let carry = (i < 0) ? 1073741824 : 0;
                while ((distance-- > 0)) {
                    {
                        let nextcarry = ui & 1;
                        ui = carry | (ui >> 1);
                        carry = (nextcarry === 0) ? 0 : 1073741824;
                    }
                }
                ;
                if (carry !== 0) {
                    ui = ui | IntegerHelper.MIN_VALUE;
                }
                return ui;
            }
            static signum(i) {
                if (i === 0) {
                    return 0;
                }
                else if (i < 0) {
                    return -1;
                }
                else {
                    return 1;
                }
            }
            static toBinaryString(value) {
                return IntegerHelper.toUnsignedRadixString(value, 2);
            }
            static toHexString(value) {
                return IntegerHelper.toUnsignedRadixString(value, 16);
            }
            static toOctalString(value) {
                return IntegerHelper.toUnsignedRadixString(value, 8);
            }
            static toString$int(value) {
                return new String(value).toString();
            }
            static toString$int$int(value, radix) {
                if (radix === 10 || radix < javaemul.internal.CharacterHelper.MIN_RADIX || radix > javaemul.internal.CharacterHelper.MAX_RADIX) {
                    return new String(value).toString();
                }
                return IntegerHelper.toRadixString(value, radix);
            }
            static toString(value, radix) {
                if (((typeof value === 'number') || value === null) && ((typeof radix === 'number') || radix === null)) {
                    return javaemul.internal.IntegerHelper.toString$int$int(value, radix);
                }
                else if (((typeof value === 'number') || value === null) && radix === undefined) {
                    return javaemul.internal.IntegerHelper.toString$int(value);
                }
                else
                    throw new Error('invalid overload');
            }
            static valueOf$int(i) {
                if (i > -129 && i < 128) {
                    let rebase = i + 128;
                    let result = IntegerHelper.BoxedValues.boxedValues_$LI$()[rebase];
                    if (result == null) {
                        result = IntegerHelper.BoxedValues.boxedValues_$LI$()[rebase] = new Number(i);
                    }
                    return result;
                }
                return new Number(i);
            }
            static valueOf$java_lang_String(s) {
                return IntegerHelper.valueOf$java_lang_String$int(s, 10);
            }
            static valueOf$java_lang_String$int(s, radix) {
                return IntegerHelper.valueOf$int(IntegerHelper.parseInt(s, radix));
            }
            static valueOf(s, radix) {
                if (((typeof s === 'string') || s === null) && ((typeof radix === 'number') || radix === null)) {
                    return javaemul.internal.IntegerHelper.valueOf$java_lang_String$int(s, radix);
                }
                else if (((typeof s === 'string') || s === null) && radix === undefined) {
                    return javaemul.internal.IntegerHelper.valueOf$java_lang_String(s);
                }
                else if (((typeof s === 'number') || s === null) && radix === undefined) {
                    return javaemul.internal.IntegerHelper.valueOf$int(s);
                }
                else
                    throw new Error('invalid overload');
            }
            static toRadixString(value, radix) {
                return (value.toString(radix));
            }
            static toUnsignedRadixString(value, radix) {
                return ((value >>> 0).toString(radix));
            }
            /**
             *
             * @return {number}
             */
            byteValue() {
                return (this.value | 0);
            }
            compareTo$javaemul_internal_IntegerHelper(b) {
                return IntegerHelper.compare(this.value, b.value);
            }
            /**
             *
             * @param {javaemul.internal.IntegerHelper} b
             * @return {number}
             */
            compareTo(b) {
                if (((b != null && b instanceof javaemul.internal.IntegerHelper) || b === null)) {
                    return this.compareTo$javaemul_internal_IntegerHelper(b);
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             *
             * @return {number}
             */
            doubleValue() {
                return this.value;
            }
            /**
             *
             * @param {*} o
             * @return {boolean}
             */
            equals(o) {
                return (o != null && o instanceof javaemul.internal.IntegerHelper) && (o.value === this.value);
            }
            /**
             *
             * @return {number}
             */
            floatValue() {
                return this.value;
            }
            /**
             *
             * @return {number}
             */
            hashCode() {
                return IntegerHelper.hashCode(this.value);
            }
            /**
             *
             * @return {number}
             */
            intValue() {
                return this.value;
            }
            /**
             *
             * @return {number}
             */
            longValue() {
                return this.value;
            }
            /**
             *
             * @return {number}
             */
            shortValue() {
                return (this.value | 0);
            }
            /**
             *
             * @return {string}
             */
            toString() {
                return IntegerHelper.toString$int(this.value);
            }
            static getInteger(nm) {
                return IntegerHelper.decode(java.lang.System.getProperty$java_lang_String(nm));
            }
        }
        IntegerHelper.MAX_VALUE = 2147483647;
        IntegerHelper.MIN_VALUE = -2147483648;
        IntegerHelper.SIZE = 32;
        internal.IntegerHelper = IntegerHelper;
        IntegerHelper["__class"] = "javaemul.internal.IntegerHelper";
        IntegerHelper["__interfaces"] = ["java.lang.Comparable", "java.io.Serializable"];
        (function (IntegerHelper) {
            /**
             * Use nested class to avoid clinit on outer.
             * @class
             */
            class BoxedValues {
                constructor() {
                }
                static boxedValues_$LI$() { if (BoxedValues.boxedValues == null)
                    BoxedValues.boxedValues = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(256); return BoxedValues.boxedValues; }
                ;
            }
            IntegerHelper.BoxedValues = BoxedValues;
            BoxedValues["__class"] = "javaemul.internal.IntegerHelper.BoxedValues";
            /**
             * Use nested class to avoid clinit on outer.
             * @class
             */
            class ReverseNibbles {
                constructor() {
                }
                static reverseNibbles_$LI$() { if (ReverseNibbles.reverseNibbles == null)
                    ReverseNibbles.reverseNibbles = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]; return ReverseNibbles.reverseNibbles; }
                ;
            }
            IntegerHelper.ReverseNibbles = ReverseNibbles;
            ReverseNibbles["__class"] = "javaemul.internal.IntegerHelper.ReverseNibbles";
        })(IntegerHelper = internal.IntegerHelper || (internal.IntegerHelper = {}));
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
(function (javaemul) {
    var internal;
    (function (internal) {
        /**
         * Wraps a primitive <code>long</code> as an object.
         * @param {number} value
         * @class
         * @extends javaemul.internal.NumberHelper
         */
        class LongHelper extends javaemul.internal.NumberHelper {
            constructor(s) {
                if (((typeof s === 'string') || s === null)) {
                    let __args = arguments;
                    super();
                    if (this.value === undefined)
                        this.value = 0;
                    if (this.value === undefined)
                        this.value = 0;
                    (() => {
                        this.value = LongHelper.parseLong(s);
                    })();
                }
                else if (((typeof s === 'number') || s === null)) {
                    let __args = arguments;
                    let value = __args[0];
                    super();
                    if (this.value === undefined)
                        this.value = 0;
                    if (this.value === undefined)
                        this.value = 0;
                    (() => {
                        this.value = value;
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            static bitCount(i) {
                let high = ((i >> 32) | 0);
                let low = (i | 0);
                return javaemul.internal.IntegerHelper.bitCount(high) + javaemul.internal.IntegerHelper.bitCount(low);
            }
            static compare(x, y) {
                if (x < y) {
                    return -1;
                }
                else if (x > y) {
                    return 1;
                }
                else {
                    return 0;
                }
            }
            static decode(s) {
                let decode = internal.NumberHelper.__decodeNumberString(s);
                return LongHelper.valueOf$java_lang_String$int(decode.payload, decode.radix);
            }
            /**
             * @skip Here for shared implementation with Arrays.hashCode
             * @param {number} l
             * @return {number}
             */
            static hashCode(l) {
                return (l | 0);
            }
            static highestOneBit(i) {
                let high = ((i >> 32) | 0);
                if (high !== 0) {
                    return ((n => n < 0 ? Math.ceil(n) : Math.floor(n))(javaemul.internal.IntegerHelper.highestOneBit(high))) << 32;
                }
                else {
                    return javaemul.internal.IntegerHelper.highestOneBit((i | 0)) & 4294967295;
                }
            }
            static lowestOneBit(i) {
                return i & -i;
            }
            static numberOfLeadingZeros(i) {
                let high = ((i >> 32) | 0);
                if (high !== 0) {
                    return javaemul.internal.IntegerHelper.numberOfLeadingZeros(high);
                }
                else {
                    return javaemul.internal.IntegerHelper.numberOfLeadingZeros((i | 0)) + 32;
                }
            }
            static numberOfTrailingZeros(i) {
                let low = (i | 0);
                if (low !== 0) {
                    return javaemul.internal.IntegerHelper.numberOfTrailingZeros(low);
                }
                else {
                    return javaemul.internal.IntegerHelper.numberOfTrailingZeros(((i >> 32) | 0)) + 32;
                }
            }
            static parseLong(s, radix = 10) {
                return internal.NumberHelper.__parseAndValidateLong(s, radix);
            }
            static reverse(i) {
                let high = ((i >>> 32) | 0);
                let low = (i | 0);
                return ((n => n < 0 ? Math.ceil(n) : Math.floor(n))(javaemul.internal.IntegerHelper.reverse(low)) << 32) | (javaemul.internal.IntegerHelper.reverse(high) & 4294967295);
            }
            static reverseBytes(i) {
                let high = ((i >>> 32) | 0);
                let low = (i | 0);
                return ((n => n < 0 ? Math.ceil(n) : Math.floor(n))(javaemul.internal.IntegerHelper.reverseBytes(low)) << 32) | (javaemul.internal.IntegerHelper.reverseBytes(high) & 4294967295);
            }
            static rotateLeft(i, distance) {
                while ((distance-- > 0)) {
                    {
                        i = i << 1 | ((i < 0) ? 1 : 0);
                    }
                }
                ;
                return i;
            }
            static rotateRight(i, distance) {
                let ui = i & LongHelper.MAX_VALUE;
                let carry = (i < 0) ? 4611686018427387904 : 0;
                while ((distance-- > 0)) {
                    {
                        let nextcarry = ui & 1;
                        ui = carry | (ui >> 1);
                        carry = (nextcarry === 0) ? 0 : 4611686018427387904;
                    }
                }
                ;
                if (carry !== 0) {
                    ui = ui | LongHelper.MIN_VALUE;
                }
                return ui;
            }
            static signum(i) {
                if (i === 0) {
                    return 0;
                }
                else if (i < 0) {
                    return -1;
                }
                else {
                    return 1;
                }
            }
            static toBinaryString(value) {
                return LongHelper.toPowerOfTwoUnsignedString(value, 1);
            }
            static toHexString(value) {
                return LongHelper.toPowerOfTwoUnsignedString(value, 4);
            }
            static toOctalString(value) {
                return LongHelper.toPowerOfTwoUnsignedString(value, 3);
            }
            static toString$long(value) {
                return new String(value).toString();
            }
            static toString$long$int(value, intRadix) {
                if (intRadix === 10 || intRadix < javaemul.internal.CharacterHelper.MIN_RADIX || intRadix > javaemul.internal.CharacterHelper.MAX_RADIX) {
                    return new String(value).toString();
                }
                let intValue = (value | 0);
                if (intValue === value) {
                    return javaemul.internal.IntegerHelper.toString$int$int(intValue, intRadix);
                }
                let negative = value < 0;
                if (!negative) {
                    value = -value;
                }
                let bufLen = intRadix < 8 ? 65 : 23;
                let buf = (s => { let a = []; while (s-- > 0)
                    a.push(null); return a; })(bufLen);
                let cursor = bufLen;
                let radix = intRadix;
                do {
                    {
                        let q = (n => n < 0 ? Math.ceil(n) : Math.floor(n))(value / radix);
                        buf[--cursor] = javaemul.internal.CharacterHelper.forDigit$int(((radix * q - value) | 0));
                        value = q;
                    }
                } while ((value !== 0));
                if (negative) {
                    buf[--cursor] = '-';
                }
                return ((str, index, len) => str.join('').substring(index, index + len))(buf, cursor, bufLen - cursor);
            }
            static toString(value, intRadix) {
                if (((typeof value === 'number') || value === null) && ((typeof intRadix === 'number') || intRadix === null)) {
                    return javaemul.internal.LongHelper.toString$long$int(value, intRadix);
                }
                else if (((typeof value === 'number') || value === null) && intRadix === undefined) {
                    return javaemul.internal.LongHelper.toString$long(value);
                }
                else
                    throw new Error('invalid overload');
            }
            static valueOf$long(i) {
                if (i > -129 && i < 128) {
                    let rebase = (i | 0) + 128;
                    let result = LongHelper.BoxedValues.boxedValues_$LI$()[rebase];
                    if (result == null) {
                        result = LongHelper.BoxedValues.boxedValues_$LI$()[rebase] = new Number(i);
                    }
                    return result;
                }
                return new Number(i);
            }
            static valueOf$java_lang_String(s) {
                return LongHelper.valueOf$java_lang_String$int(s, 10);
            }
            static valueOf$java_lang_String$int(s, radix) {
                return LongHelper.valueOf$long(LongHelper.parseLong(s, radix));
            }
            static valueOf(s, radix) {
                if (((typeof s === 'string') || s === null) && ((typeof radix === 'number') || radix === null)) {
                    return javaemul.internal.LongHelper.valueOf$java_lang_String$int(s, radix);
                }
                else if (((typeof s === 'string') || s === null) && radix === undefined) {
                    return javaemul.internal.LongHelper.valueOf$java_lang_String(s);
                }
                else if (((typeof s === 'number') || s === null) && radix === undefined) {
                    return javaemul.internal.LongHelper.valueOf$long(s);
                }
                else
                    throw new Error('invalid overload');
            }
            static toPowerOfTwoUnsignedString(value, shift) {
                let radix = 1 << shift;
                if (javaemul.internal.IntegerHelper.MIN_VALUE <= value && value <= javaemul.internal.IntegerHelper.MAX_VALUE) {
                    return javaemul.internal.IntegerHelper.toString$int$int((value | 0), radix);
                }
                let mask = radix - 1;
                let bufSize = (64 / shift | 0) + 1;
                let buf = (s => { let a = []; while (s-- > 0)
                    a.push(null); return a; })(bufSize);
                let pos = bufSize;
                do {
                    {
                        buf[--pos] = javaemul.internal.CharacterHelper.forDigit$int(((value | 0)) & mask);
                        value >>>= shift;
                    }
                } while ((value !== 0));
                return ((str, index, len) => str.join('').substring(index, index + len))(buf, pos, bufSize - pos);
            }
            /**
             *
             * @return {number}
             */
            byteValue() {
                return (this.value | 0);
            }
            compareTo$javaemul_internal_LongHelper(b) {
                return LongHelper.compare(this.value, b.value);
            }
            /**
             *
             * @param {javaemul.internal.LongHelper} b
             * @return {number}
             */
            compareTo(b) {
                if (((b != null && b instanceof javaemul.internal.LongHelper) || b === null)) {
                    return this.compareTo$javaemul_internal_LongHelper(b);
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             *
             * @return {number}
             */
            doubleValue() {
                return this.value;
            }
            /**
             *
             * @param {*} o
             * @return {boolean}
             */
            equals(o) {
                return (o != null && o instanceof javaemul.internal.LongHelper) && (o.value === this.value);
            }
            /**
             *
             * @return {number}
             */
            floatValue() {
                return this.value;
            }
            /**
             *
             * @return {number}
             */
            hashCode() {
                return LongHelper.hashCode(this.value);
            }
            /**
             *
             * @return {number}
             */
            intValue() {
                return (this.value | 0);
            }
            /**
             *
             * @return {number}
             */
            longValue() {
                return this.value;
            }
            /**
             *
             * @return {number}
             */
            shortValue() {
                return (this.value | 0);
            }
            /**
             *
             * @return {string}
             */
            toString() {
                return LongHelper.toString$long(this.value);
            }
        }
        LongHelper.MAX_VALUE = 9223372036854775807;
        LongHelper.MIN_VALUE = -9223372036854775808;
        LongHelper.SIZE = 64;
        internal.LongHelper = LongHelper;
        LongHelper["__class"] = "javaemul.internal.LongHelper";
        LongHelper["__interfaces"] = ["java.lang.Comparable", "java.io.Serializable"];
        (function (LongHelper) {
            /**
             * Use nested class to avoid clinit on outer.
             * @class
             */
            class BoxedValues {
                constructor() {
                }
                static boxedValues_$LI$() { if (BoxedValues.boxedValues == null)
                    BoxedValues.boxedValues = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(256); return BoxedValues.boxedValues; }
                ;
            }
            LongHelper.BoxedValues = BoxedValues;
            BoxedValues["__class"] = "javaemul.internal.LongHelper.BoxedValues";
        })(LongHelper = internal.LongHelper || (internal.LongHelper = {}));
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
(function (javaemul) {
    var internal;
    (function (internal) {
        /**
         * Wraps a primitive <code>short</code> as an object.
         * @param {number} value
         * @class
         * @extends javaemul.internal.NumberHelper
         */
        class ShortHelper extends javaemul.internal.NumberHelper {
            constructor(s) {
                if (((typeof s === 'string') || s === null)) {
                    let __args = arguments;
                    super();
                    if (this.value === undefined)
                        this.value = 0;
                    if (this.value === undefined)
                        this.value = 0;
                    (() => {
                        this.value = ShortHelper.parseShort(s);
                    })();
                }
                else if (((typeof s === 'number') || s === null)) {
                    let __args = arguments;
                    let value = __args[0];
                    super();
                    if (this.value === undefined)
                        this.value = 0;
                    if (this.value === undefined)
                        this.value = 0;
                    (() => {
                        this.value = value;
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            static MIN_VALUE_$LI$() { if (ShortHelper.MIN_VALUE == null)
                ShortHelper.MIN_VALUE = (32768 | 0); return ShortHelper.MIN_VALUE; }
            ;
            static MAX_VALUE_$LI$() { if (ShortHelper.MAX_VALUE == null)
                ShortHelper.MAX_VALUE = (32767 | 0); return ShortHelper.MAX_VALUE; }
            ;
            static TYPE_$LI$() { if (ShortHelper.TYPE == null)
                ShortHelper.TYPE = Number; return ShortHelper.TYPE; }
            ;
            static compare(x, y) {
                return x - y;
            }
            static decode(s) {
                return ShortHelper.valueOf$short((internal.NumberHelper.__decodeAndValidateInt(s, ShortHelper.MIN_VALUE_$LI$(), ShortHelper.MAX_VALUE_$LI$()) | 0));
            }
            /**
             * @skip Here for shared implementation with Arrays.hashCode
             * @param {number} s
             * @return {number}
             */
            static hashCode(s) {
                return s;
            }
            static parseShort(s, radix = 10) {
                return (internal.NumberHelper.__parseAndValidateInt(s, radix, ShortHelper.MIN_VALUE_$LI$(), ShortHelper.MAX_VALUE_$LI$()) | 0);
            }
            static reverseBytes(s) {
                return ((((s & 255) << 8) | ((s & 65280) >> 8)) | 0);
            }
            static toString(b) {
                return new String(b).toString();
            }
            static valueOf$short(s) {
                if (s > -129 && s < 128) {
                    let rebase = s + 128;
                    let result = ShortHelper.BoxedValues.boxedValues_$LI$()[rebase];
                    if (result == null) {
                        result = ShortHelper.BoxedValues.boxedValues_$LI$()[rebase] = new Number(s);
                    }
                    return result;
                }
                return new Number(s);
            }
            static valueOf$java_lang_String(s) {
                return ShortHelper.valueOf$java_lang_String$int(s, 10);
            }
            static valueOf$java_lang_String$int(s, radix) {
                return ShortHelper.valueOf$short(ShortHelper.parseShort(s, radix));
            }
            static valueOf(s, radix) {
                if (((typeof s === 'string') || s === null) && ((typeof radix === 'number') || radix === null)) {
                    return javaemul.internal.ShortHelper.valueOf$java_lang_String$int(s, radix);
                }
                else if (((typeof s === 'string') || s === null) && radix === undefined) {
                    return javaemul.internal.ShortHelper.valueOf$java_lang_String(s);
                }
                else if (((typeof s === 'number') || s === null) && radix === undefined) {
                    return javaemul.internal.ShortHelper.valueOf$short(s);
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             *
             * @return {number}
             */
            byteValue() {
                return (this.value | 0);
            }
            compareTo$javaemul_internal_ShortHelper(b) {
                return ShortHelper.compare(this.value, b.value);
            }
            /**
             *
             * @param {javaemul.internal.ShortHelper} b
             * @return {number}
             */
            compareTo(b) {
                if (((b != null && b instanceof javaemul.internal.ShortHelper) || b === null)) {
                    return this.compareTo$javaemul_internal_ShortHelper(b);
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             *
             * @return {number}
             */
            doubleValue() {
                return this.value;
            }
            /**
             *
             * @param {*} o
             * @return {boolean}
             */
            equals(o) {
                return (o != null && o instanceof javaemul.internal.ShortHelper) && (o.value === this.value);
            }
            /**
             *
             * @return {number}
             */
            floatValue() {
                return this.value;
            }
            /**
             *
             * @return {number}
             */
            hashCode() {
                return ShortHelper.hashCode(this.value);
            }
            /**
             *
             * @return {number}
             */
            intValue() {
                return this.value;
            }
            /**
             *
             * @return {number}
             */
            longValue() {
                return this.value;
            }
            /**
             *
             * @return {number}
             */
            shortValue() {
                return this.value;
            }
            /**
             *
             * @return {string}
             */
            toString() {
                return ShortHelper.toString(this.value);
            }
        }
        ShortHelper.SIZE = 16;
        internal.ShortHelper = ShortHelper;
        ShortHelper["__class"] = "javaemul.internal.ShortHelper";
        ShortHelper["__interfaces"] = ["java.lang.Comparable", "java.io.Serializable"];
        (function (ShortHelper) {
            /**
             * Use nested class to avoid clinit on outer.
             * @class
             */
            class BoxedValues {
                constructor() {
                }
                static boxedValues_$LI$() { if (BoxedValues.boxedValues == null)
                    BoxedValues.boxedValues = (s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(256); return BoxedValues.boxedValues; }
                ;
            }
            ShortHelper.BoxedValues = BoxedValues;
            BoxedValues["__class"] = "javaemul.internal.ShortHelper.BoxedValues";
        })(ShortHelper = internal.ShortHelper || (internal.ShortHelper = {}));
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
(function (javaemul) {
    var internal;
    (function (internal) {
        var stream;
        (function (stream) {
            class StreamRowAllFilter extends javaemul.internal.stream.TerminalStreamRow {
                constructor(predicate) {
                    super();
                    if (this.predicate === undefined)
                        this.predicate = null;
                    if (this.predicateValue === undefined)
                        this.predicateValue = false;
                    if (this.attempts === undefined)
                        this.attempts = 0;
                    this.predicate = (predicate);
                }
                getPredicateValue() {
                    return this.attempts === 0 || this.predicateValue;
                }
                item(a) {
                    ++this.attempts;
                    this.predicateValue = (target => (typeof target === 'function') ? target(a) : target.test(a))(this.predicate) && this.predicateValue;
                    return this.predicateValue;
                }
            }
            stream.StreamRowAllFilter = StreamRowAllFilter;
            StreamRowAllFilter["__class"] = "javaemul.internal.stream.StreamRowAllFilter";
            StreamRowAllFilter["__interfaces"] = ["javaemul.internal.stream.StreamRow"];
        })(stream = internal.stream || (internal.stream = {}));
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
(function (javaemul) {
    var internal;
    (function (internal) {
        var stream;
        (function (stream) {
            class StreamRowCount extends javaemul.internal.stream.TerminalStreamRow {
                constructor() {
                    super();
                    if (this.count === undefined)
                        this.count = 0;
                }
                getCount() {
                    return this.count;
                }
                item(a) {
                    ++this.count;
                    return true;
                }
            }
            stream.StreamRowCount = StreamRowCount;
            StreamRowCount["__class"] = "javaemul.internal.stream.StreamRowCount";
            StreamRowCount["__interfaces"] = ["javaemul.internal.stream.StreamRow"];
        })(stream = internal.stream || (internal.stream = {}));
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
(function (javaemul) {
    var internal;
    (function (internal) {
        var stream;
        (function (stream) {
            /**
             * @author Władysław Kargul
             * @param {*} previous
             * @class
             * @extends javaemul.internal.stream.TerminalStreamRow
             */
            class StreamRowEnd extends javaemul.internal.stream.TerminalStreamRow {
                constructor(previous) {
                    super();
                    if (this.previous === undefined)
                        this.previous = null;
                    this.previous = previous;
                }
                chain(next) {
                    if (this.previous != null) {
                        this.previous.chain(next);
                    }
                    this.previous = next;
                    next.chain(this);
                }
                item(a) {
                    return true;
                }
            }
            stream.StreamRowEnd = StreamRowEnd;
            StreamRowEnd["__class"] = "javaemul.internal.stream.StreamRowEnd";
            StreamRowEnd["__interfaces"] = ["javaemul.internal.stream.StreamRow"];
        })(stream = internal.stream || (internal.stream = {}));
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
(function (javaemul) {
    var internal;
    (function (internal) {
        var stream;
        (function (stream) {
            class StreamRowOnceFilter extends javaemul.internal.stream.TerminalStreamRow {
                constructor(predicate) {
                    super();
                    /*private*/ this.firstMatch = java.util.Optional.empty();
                    if (this.predicate === undefined)
                        this.predicate = null;
                    if (this.predicateValue === undefined)
                        this.predicateValue = false;
                    this.predicate = (predicate);
                }
                getFirstMatch() {
                    return this.firstMatch;
                }
                getPredicateValue() {
                    return this.predicateValue;
                }
                item(a) {
                    this.predicateValue = (target => (typeof target === 'function') ? target(a) : target.test(a))(this.predicate);
                    if (this.predicateValue) {
                        this.firstMatch = java.util.Optional.of(a);
                    }
                    return !this.predicateValue;
                }
            }
            stream.StreamRowOnceFilter = StreamRowOnceFilter;
            StreamRowOnceFilter["__class"] = "javaemul.internal.stream.StreamRowOnceFilter";
            StreamRowOnceFilter["__interfaces"] = ["javaemul.internal.stream.StreamRow"];
        })(stream = internal.stream || (internal.stream = {}));
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
(function (javaemul) {
    var internal;
    (function (internal) {
        var stream;
        (function (stream) {
            class StreamRowReduce extends javaemul.internal.stream.TerminalStreamRow {
                constructor(result, operator) {
                    super();
                    if (this.result === undefined)
                        this.result = null;
                    if (this.operator === undefined)
                        this.operator = null;
                    this.result = result;
                    this.operator = (operator);
                }
                getResult() {
                    return this.result;
                }
                item(a) {
                    this.result = java.util.Optional.of(this.result.map((v) => (target => (typeof target === 'function') ? target(v, a) : target.apply(v, a))(this.operator)).orElse(a));
                    return true;
                }
            }
            stream.StreamRowReduce = StreamRowReduce;
            StreamRowReduce["__class"] = "javaemul.internal.stream.StreamRowReduce";
            StreamRowReduce["__interfaces"] = ["javaemul.internal.stream.StreamRow"];
        })(stream = internal.stream || (internal.stream = {}));
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
(function (javaemul) {
    var internal;
    (function (internal) {
        var stream;
        (function (stream) {
            class StreamRowCollector extends javaemul.internal.stream.TransientStreamRow {
                constructor(collection) {
                    super();
                    if (this.collection === undefined)
                        this.collection = null;
                    this.collection = collection;
                }
                item(a) {
                    this.collection.add(a);
                    return true;
                }
                end() {
                    for (let index140 = this.collection.iterator(); index140.hasNext();) {
                        let item = index140.next();
                        {
                            if (!this.next.item(item)) {
                                break;
                            }
                        }
                    }
                    this.next.end();
                }
            }
            stream.StreamRowCollector = StreamRowCollector;
            StreamRowCollector["__class"] = "javaemul.internal.stream.StreamRowCollector";
            StreamRowCollector["__interfaces"] = ["javaemul.internal.stream.StreamRow"];
        })(stream = internal.stream || (internal.stream = {}));
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
(function (javaemul) {
    var internal;
    (function (internal) {
        var stream;
        (function (stream) {
            class StreamRowFilter extends javaemul.internal.stream.TransientStreamRow {
                constructor(predicate) {
                    super();
                    if (this.predicate === undefined)
                        this.predicate = null;
                    this.predicate = (predicate);
                }
                item(a) {
                    if ((target => (typeof target === 'function') ? target(a) : target.test(a))(this.predicate)) {
                        return this.next.item(a);
                    }
                    return true;
                }
                end() {
                    this.next.end();
                }
            }
            stream.StreamRowFilter = StreamRowFilter;
            StreamRowFilter["__class"] = "javaemul.internal.stream.StreamRowFilter";
            StreamRowFilter["__interfaces"] = ["javaemul.internal.stream.StreamRow"];
        })(stream = internal.stream || (internal.stream = {}));
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
(function (javaemul) {
    var internal;
    (function (internal) {
        var stream;
        (function (stream) {
            class StreamRowFilterFlop extends javaemul.internal.stream.TransientStreamRow {
                constructor(predicate) {
                    super();
                    if (this.predicate === undefined)
                        this.predicate = null;
                    this.predicate = (predicate);
                }
                item(a) {
                    let test = (target => (typeof target === 'function') ? target(a) : target.test(a))(this.predicate);
                    if (test) {
                        return this.next.item(a);
                    }
                    return false;
                }
                end() {
                    this.next.end();
                }
            }
            stream.StreamRowFilterFlop = StreamRowFilterFlop;
            StreamRowFilterFlop["__class"] = "javaemul.internal.stream.StreamRowFilterFlop";
            StreamRowFilterFlop["__interfaces"] = ["javaemul.internal.stream.StreamRow"];
        })(stream = internal.stream || (internal.stream = {}));
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
(function (javaemul) {
    var internal;
    (function (internal) {
        var stream;
        (function (stream) {
            class StreamRowFlatMap extends javaemul.internal.stream.TransientStreamRow {
                constructor(flatMap) {
                    super();
                    if (this.flatMap === undefined)
                        this.flatMap = null;
                    this.flatMap = (flatMap);
                }
                item(a) {
                    let subStream = (target => (typeof target === 'function') ? target(a) : target.apply(a))(this.flatMap);
                    try {
                        try {
                            subStream.forEach((o) => {
                                if (!this.next.item(o)) {
                                    throw new javaemul.internal.stream.StopException();
                                }
                            });
                        }
                        catch (e) {
                            return false;
                        }
                        ;
                    }
                    finally {
                        subStream.close();
                    }
                    ;
                    return true;
                }
                end() {
                    this.next.end();
                }
            }
            stream.StreamRowFlatMap = StreamRowFlatMap;
            StreamRowFlatMap["__class"] = "javaemul.internal.stream.StreamRowFlatMap";
            StreamRowFlatMap["__interfaces"] = ["javaemul.internal.stream.StreamRow"];
        })(stream = internal.stream || (internal.stream = {}));
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
(function (javaemul) {
    var internal;
    (function (internal) {
        var stream;
        (function (stream) {
            class StreamRowMap extends javaemul.internal.stream.TransientStreamRow {
                constructor(map) {
                    super();
                    if (this.map === undefined)
                        this.map = null;
                    this.map = (map);
                }
                item(a) {
                    return this.next.item((target => (typeof target === 'function') ? target(a) : target.apply(a))(this.map));
                }
                end() {
                    this.next.end();
                }
            }
            stream.StreamRowMap = StreamRowMap;
            StreamRowMap["__class"] = "javaemul.internal.stream.StreamRowMap";
            StreamRowMap["__interfaces"] = ["javaemul.internal.stream.StreamRow"];
        })(stream = internal.stream || (internal.stream = {}));
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
(function (java) {
    var io;
    (function (io) {
        /**
         * @skip
         * @param {java.io.OutputStream} out
         * @class
         * @extends java.io.FilterOutputStream
         */
        class PrintStream extends java.io.FilterOutputStream {
            constructor(out) {
                super(out);
            }
            print$java_lang_String(s) {
                try {
                    this.write$byte_A(/* getBytes */ (s).split('').map(s => s.charCodeAt(0)));
                }
                catch (e) {
                    console.error(e.message, e);
                }
                ;
            }
            print(s) {
                if (((typeof s === 'string') || s === null)) {
                    return this.print$java_lang_String(s);
                }
                else if (((s != null && s instanceof Array && (s.length == 0 || s[0] == null || (typeof s[0] === 'string'))) || s === null)) {
                    return this.print$char_A(s);
                }
                else if (((typeof s === 'boolean') || s === null)) {
                    return this.print$boolean(s);
                }
                else if (((typeof s === 'string') || s === null)) {
                    return this.print$char(s);
                }
                else if (((typeof s === 'number') || s === null)) {
                    return this.print$int(s);
                }
                else if (((typeof s === 'number') || s === null)) {
                    return this.print$long(s);
                }
                else if (((typeof s === 'number') || s === null)) {
                    return this.print$float(s);
                }
                else if (((typeof s === 'number') || s === null)) {
                    return this.print$double(s);
                }
                else if (((s != null) || s === null)) {
                    return this.print$java_lang_Object(s);
                }
                else
                    throw new Error('invalid overload');
            }
            println$java_lang_String(s) {
                this.print$java_lang_String(s + java.lang.System.lineSeparator());
            }
            println(s) {
                if (((typeof s === 'string') || s === null)) {
                    return this.println$java_lang_String(s);
                }
                else if (((s != null && s instanceof Array && (s.length == 0 || s[0] == null || (typeof s[0] === 'string'))) || s === null)) {
                    return this.println$char_A(s);
                }
                else if (((typeof s === 'boolean') || s === null)) {
                    return this.println$boolean(s);
                }
                else if (((typeof s === 'string') || s === null)) {
                    return this.println$char(s);
                }
                else if (((typeof s === 'number') || s === null)) {
                    return this.println$int(s);
                }
                else if (((typeof s === 'number') || s === null)) {
                    return this.println$long(s);
                }
                else if (((typeof s === 'number') || s === null)) {
                    return this.println$float(s);
                }
                else if (((typeof s === 'number') || s === null)) {
                    return this.println$double(s);
                }
                else if (((s != null) || s === null)) {
                    return this.println$java_lang_Object(s);
                }
                else if (s === undefined) {
                    return this.println$();
                }
                else
                    throw new Error('invalid overload');
            }
            print$boolean(x) {
                this.print$java_lang_String(/* valueOf */ new String(x).toString());
            }
            print$char(x) {
                this.print$java_lang_String(/* valueOf */ new String(x).toString());
            }
            print$char_A(x) {
                this.println$java_lang_String(/* valueOf */ new String(x).toString());
            }
            print$double(x) {
                this.print$java_lang_String(/* valueOf */ new String(x).toString());
            }
            print$float(x) {
                this.print$java_lang_String(/* valueOf */ new String(x).toString());
            }
            print$int(x) {
                this.print$java_lang_String(/* valueOf */ new String(x).toString());
            }
            print$long(x) {
                this.print$java_lang_String(/* valueOf */ new String(x).toString());
            }
            print$java_lang_Object(x) {
                this.print$java_lang_String(/* valueOf */ new String(x).toString());
            }
            println$() {
                this.println$java_lang_String("");
            }
            println$boolean(x) {
                this.println$java_lang_String(/* valueOf */ new String(x).toString());
            }
            println$char(x) {
                this.println$java_lang_String(/* valueOf */ new String(x).toString());
            }
            println$char_A(x) {
                this.println$java_lang_String(/* valueOf */ new String(x).toString());
            }
            println$double(x) {
                this.println$java_lang_String(/* valueOf */ new String(x).toString());
            }
            println$float(x) {
                this.println$java_lang_String(/* valueOf */ new String(x).toString());
            }
            println$int(x) {
                this.println$java_lang_String(/* valueOf */ new String(x).toString());
            }
            println$long(x) {
                this.println$java_lang_String(/* valueOf */ new String(x).toString());
            }
            println$java_lang_Object(x) {
                this.println$java_lang_String(/* valueOf */ new String(x).toString());
            }
        }
        io.PrintStream = PrintStream;
        PrintStream["__class"] = "java.io.PrintStream";
        PrintStream["__interfaces"] = ["java.io.Closeable", "java.lang.AutoCloseable", "java.io.Flushable"];
    })(io = java.io || (java.io = {}));
})(java || (java = {}));
(function (java) {
    var io;
    (function (io) {
        /**
         * A character encoding is not supported - <a
         * href="http://java.sun.com/javase/6/docs/api/java/io/UnsupportedEncodingException.html">[Sun's
         * docs]</a>.
         * @param {string} msg
         * @class
         * @extends java.io.IOException
         */
        class UnsupportedEncodingException extends java.io.IOException {
            constructor(msg) {
                if (((typeof msg === 'string') || msg === null)) {
                    let __args = arguments;
                    super(msg);
                    Object.setPrototypeOf(this, UnsupportedEncodingException.prototype);
                }
                else if (msg === undefined) {
                    let __args = arguments;
                    super();
                    Object.setPrototypeOf(this, UnsupportedEncodingException.prototype);
                }
                else
                    throw new Error('invalid overload');
            }
        }
        io.UnsupportedEncodingException = UnsupportedEncodingException;
        UnsupportedEncodingException["__class"] = "java.io.UnsupportedEncodingException";
        UnsupportedEncodingException["__interfaces"] = ["java.io.Serializable"];
    })(io = java.io || (java.io = {}));
})(java || (java = {}));
(function (java) {
    var io;
    (function (io) {
        /**
         * See <a
         * href="https://docs.oracle.com/javase/8/docs/api/java/io/UncheckedIOException.html">the
         * official Java API doc</a> for details.
         * @param {string} message
         * @param {java.io.IOException} cause
         * @class
         * @extends java.lang.RuntimeException
         */
        class UncheckedIOException extends java.lang.RuntimeException {
            constructor(message, cause) {
                if (((typeof message === 'string') || message === null) && ((cause != null && cause instanceof java.io.IOException) || cause === null)) {
                    let __args = arguments;
                    super(message, (javaemul.internal.InternalPreconditions.checkNotNull(cause)));
                    Object.setPrototypeOf(this, UncheckedIOException.prototype);
                }
                else if (((message != null && message instanceof java.io.IOException) || message === null) && cause === undefined) {
                    let __args = arguments;
                    let cause = __args[0];
                    super((javaemul.internal.InternalPreconditions.checkNotNull(cause)));
                    Object.setPrototypeOf(this, UncheckedIOException.prototype);
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             *
             * @return {java.io.IOException}
             */
            getCause() {
                return null;
            }
        }
        io.UncheckedIOException = UncheckedIOException;
        UncheckedIOException["__class"] = "java.io.UncheckedIOException";
        UncheckedIOException["__interfaces"] = ["java.io.Serializable"];
    })(io = java.io || (java.io = {}));
})(java || (java = {}));
(function (java) {
    var lang;
    (function (lang) {
        var annotation;
        (function (annotation) {
            /**
             * Indicates an attempt to access an element of an annotation that has changed
             * since it was compiled or serialized <a
             * href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/annotation/AnnotationTypeMismatchException.html">[Sun
             * docs]</a>.
             * @class
             * @extends java.lang.RuntimeException
             */
            class AnnotationTypeMismatchException extends java.lang.RuntimeException {
                constructor() {
                    super();
                    Object.setPrototypeOf(this, AnnotationTypeMismatchException.prototype);
                }
            }
            annotation.AnnotationTypeMismatchException = AnnotationTypeMismatchException;
            AnnotationTypeMismatchException["__class"] = "java.lang.annotation.AnnotationTypeMismatchException";
            AnnotationTypeMismatchException["__interfaces"] = ["java.io.Serializable"];
        })(annotation = lang.annotation || (lang.annotation = {}));
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
(function (java) {
    var lang;
    (function (lang) {
        var annotation;
        (function (annotation) {
            /**
             * Indicates an attempt to access an element of an annotation that was added
             * since it was compiled or serialized <a
             * href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/annotation/IncompleteAnnotationException.html">[Sun
             * docs]</a>.
             * @param {java.lang.Class} annotationType
             * @param {string} elementName
             * @class
             * @extends java.lang.RuntimeException
             */
            class IncompleteAnnotationException extends java.lang.RuntimeException {
                constructor(annotationType, elementName) {
                    super("Incomplete annotation: trying to access " + elementName + " on " + annotationType);
                    Object.setPrototypeOf(this, IncompleteAnnotationException.prototype);
                    if (this.__annotationType === undefined)
                        this.__annotationType = null;
                    if (this.__elementName === undefined)
                        this.__elementName = null;
                    this.__annotationType = annotationType;
                    this.__elementName = elementName;
                }
                annotationType() {
                    return this.__annotationType;
                }
                elementName() {
                    return this.__elementName;
                }
            }
            annotation.IncompleteAnnotationException = IncompleteAnnotationException;
            IncompleteAnnotationException["__class"] = "java.lang.annotation.IncompleteAnnotationException";
            IncompleteAnnotationException["__interfaces"] = ["java.io.Serializable"];
        })(annotation = lang.annotation || (lang.annotation = {}));
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
(function (java) {
    var lang;
    (function (lang) {
        /**
         * NOTE: in GWT this is only thrown for division by zero on longs and
         * BigInteger/BigDecimal.
         * <p>
         * See <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/ArithmeticException.html">the
         * official Java API doc</a> for details.
         * @param {string} explanation
         * @class
         * @extends java.lang.RuntimeException
         */
        class ArithmeticException extends java.lang.RuntimeException {
            constructor(explanation) {
                if (((typeof explanation === 'string') || explanation === null)) {
                    let __args = arguments;
                    super(explanation);
                    Object.setPrototypeOf(this, ArithmeticException.prototype);
                }
                else if (explanation === undefined) {
                    let __args = arguments;
                    super();
                    Object.setPrototypeOf(this, ArithmeticException.prototype);
                }
                else
                    throw new Error('invalid overload');
            }
        }
        lang.ArithmeticException = ArithmeticException;
        ArithmeticException["__class"] = "java.lang.ArithmeticException";
        ArithmeticException["__interfaces"] = ["java.io.Serializable"];
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
(function (java) {
    var lang;
    (function (lang) {
        /**
         * See <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/ArrayStoreException.html">the
         * official Java API doc</a> for details.
         * @param {string} message
         * @class
         * @extends java.lang.RuntimeException
         */
        class ArrayStoreException extends java.lang.RuntimeException {
            constructor(message) {
                if (((typeof message === 'string') || message === null)) {
                    let __args = arguments;
                    super(message);
                    Object.setPrototypeOf(this, ArrayStoreException.prototype);
                }
                else if (message === undefined) {
                    let __args = arguments;
                    super();
                    Object.setPrototypeOf(this, ArrayStoreException.prototype);
                }
                else
                    throw new Error('invalid overload');
            }
        }
        lang.ArrayStoreException = ArrayStoreException;
        ArrayStoreException["__class"] = "java.lang.ArrayStoreException";
        ArrayStoreException["__interfaces"] = ["java.io.Serializable"];
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
(function (java) {
    var lang;
    (function (lang) {
        /**
         * Indicates failure to cast one type into another.
         * @param {string} message
         * @class
         * @extends java.lang.RuntimeException
         */
        class ClassCastException extends java.lang.RuntimeException {
            constructor(message) {
                if (((typeof message === 'string') || message === null)) {
                    let __args = arguments;
                    super(message);
                    Object.setPrototypeOf(this, ClassCastException.prototype);
                }
                else if (message === undefined) {
                    let __args = arguments;
                    super();
                    Object.setPrototypeOf(this, ClassCastException.prototype);
                }
                else
                    throw new Error('invalid overload');
            }
        }
        lang.ClassCastException = ClassCastException;
        ClassCastException["__class"] = "java.lang.ClassCastException";
        ClassCastException["__interfaces"] = ["java.io.Serializable"];
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
(function (java) {
    var lang;
    (function (lang) {
        class IllegalAccessException extends java.lang.RuntimeException {
            constructor(message, cause) {
                if (((typeof message === 'string') || message === null) && ((cause != null && cause instanceof Error) || cause === null)) {
                    let __args = arguments;
                    super(message, cause);
                    Object.setPrototypeOf(this, IllegalAccessException.prototype);
                }
                else if (((typeof message === 'string') || message === null) && cause === undefined) {
                    let __args = arguments;
                    let s = __args[0];
                    super(s);
                    Object.setPrototypeOf(this, IllegalAccessException.prototype);
                }
                else if (((message != null && message instanceof Error) || message === null) && cause === undefined) {
                    let __args = arguments;
                    let cause = __args[0];
                    super(cause);
                    Object.setPrototypeOf(this, IllegalAccessException.prototype);
                }
                else if (message === undefined && cause === undefined) {
                    let __args = arguments;
                    super();
                    Object.setPrototypeOf(this, IllegalAccessException.prototype);
                }
                else
                    throw new Error('invalid overload');
            }
        }
        lang.IllegalAccessException = IllegalAccessException;
        IllegalAccessException["__class"] = "java.lang.IllegalAccessException";
        IllegalAccessException["__interfaces"] = ["java.io.Serializable"];
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
(function (java) {
    var lang;
    (function (lang) {
        /**
         * See <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/IllegalArgumentException.html">the
         * official Java API doc</a> for details.
         * @param {string} message
         * @param {java.lang.Throwable} cause
         * @class
         * @extends java.lang.RuntimeException
         */
        class IllegalArgumentException extends java.lang.RuntimeException {
            constructor(message, cause) {
                if (((typeof message === 'string') || message === null) && ((cause != null && cause instanceof Error) || cause === null)) {
                    let __args = arguments;
                    super(message, cause);
                    Object.setPrototypeOf(this, IllegalArgumentException.prototype);
                }
                else if (((typeof message === 'string') || message === null) && cause === undefined) {
                    let __args = arguments;
                    super(message);
                    Object.setPrototypeOf(this, IllegalArgumentException.prototype);
                }
                else if (((message != null && message instanceof Error) || message === null) && cause === undefined) {
                    let __args = arguments;
                    let cause = __args[0];
                    super(cause);
                    Object.setPrototypeOf(this, IllegalArgumentException.prototype);
                }
                else if (message === undefined && cause === undefined) {
                    let __args = arguments;
                    super();
                    Object.setPrototypeOf(this, IllegalArgumentException.prototype);
                }
                else
                    throw new Error('invalid overload');
            }
        }
        lang.IllegalArgumentException = IllegalArgumentException;
        IllegalArgumentException["__class"] = "java.lang.IllegalArgumentException";
        IllegalArgumentException["__interfaces"] = ["java.io.Serializable"];
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
(function (java) {
    var lang;
    (function (lang) {
        /**
         * Indicates that an objet was in an invalid state during an attempted
         * operation.
         * @param {string} message
         * @param {java.lang.Throwable} cause
         * @class
         * @extends java.lang.RuntimeException
         */
        class IllegalStateException extends java.lang.RuntimeException {
            constructor(message, cause) {
                if (((typeof message === 'string') || message === null) && ((cause != null && cause instanceof Error) || cause === null)) {
                    let __args = arguments;
                    super(message, cause);
                    Object.setPrototypeOf(this, IllegalStateException.prototype);
                }
                else if (((typeof message === 'string') || message === null) && cause === undefined) {
                    let __args = arguments;
                    let s = __args[0];
                    super(s);
                    Object.setPrototypeOf(this, IllegalStateException.prototype);
                }
                else if (((message != null && message instanceof Error) || message === null) && cause === undefined) {
                    let __args = arguments;
                    let cause = __args[0];
                    super(cause);
                    Object.setPrototypeOf(this, IllegalStateException.prototype);
                }
                else if (message === undefined && cause === undefined) {
                    let __args = arguments;
                    super();
                    Object.setPrototypeOf(this, IllegalStateException.prototype);
                }
                else
                    throw new Error('invalid overload');
            }
        }
        lang.IllegalStateException = IllegalStateException;
        IllegalStateException["__class"] = "java.lang.IllegalStateException";
        IllegalStateException["__interfaces"] = ["java.io.Serializable"];
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
(function (java) {
    var lang;
    (function (lang) {
        /**
         * See <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/IndexOutOfBoundsException.html">the
         * official Java API doc</a> for details.
         * @param {string} message
         * @class
         * @extends java.lang.RuntimeException
         */
        class IndexOutOfBoundsException extends java.lang.RuntimeException {
            constructor(message) {
                if (((typeof message === 'string') || message === null)) {
                    let __args = arguments;
                    super(message);
                    Object.setPrototypeOf(this, IndexOutOfBoundsException.prototype);
                }
                else if (message === undefined) {
                    let __args = arguments;
                    super();
                    Object.setPrototypeOf(this, IndexOutOfBoundsException.prototype);
                }
                else
                    throw new Error('invalid overload');
            }
        }
        lang.IndexOutOfBoundsException = IndexOutOfBoundsException;
        IndexOutOfBoundsException["__class"] = "java.lang.IndexOutOfBoundsException";
        IndexOutOfBoundsException["__interfaces"] = ["java.io.Serializable"];
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
(function (java) {
    var lang;
    (function (lang) {
        /**
         * See <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/NegativeArraySizeException.html">the
         * official Java API doc</a> for details.
         * @param {string} message
         * @class
         * @extends java.lang.RuntimeException
         */
        class NegativeArraySizeException extends java.lang.RuntimeException {
            constructor(message) {
                if (((typeof message === 'string') || message === null)) {
                    let __args = arguments;
                    super(message);
                    Object.setPrototypeOf(this, NegativeArraySizeException.prototype);
                }
                else if (message === undefined) {
                    let __args = arguments;
                    super();
                    Object.setPrototypeOf(this, NegativeArraySizeException.prototype);
                }
                else
                    throw new Error('invalid overload');
            }
        }
        lang.NegativeArraySizeException = NegativeArraySizeException;
        NegativeArraySizeException["__class"] = "java.lang.NegativeArraySizeException";
        NegativeArraySizeException["__interfaces"] = ["java.io.Serializable"];
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
(function (java) {
    var lang;
    (function (lang) {
        /**
         * See <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/NullPointerException.html">the
         * official Java API doc</a> for details.
         * @param {string} message
         * @class
         * @extends java.lang.RuntimeException
         */
        class NullPointerException extends java.lang.RuntimeException {
            constructor(message) {
                if (((typeof message === 'string') || message === null)) {
                    let __args = arguments;
                    super(message);
                    Object.setPrototypeOf(this, NullPointerException.prototype);
                }
                else if (message === undefined) {
                    let __args = arguments;
                    super();
                    Object.setPrototypeOf(this, NullPointerException.prototype);
                }
                else
                    throw new Error('invalid overload');
            }
            createError(msg) {
                return (new TypeError(msg));
            }
        }
        lang.NullPointerException = NullPointerException;
        NullPointerException["__class"] = "java.lang.NullPointerException";
        NullPointerException["__interfaces"] = ["java.io.Serializable"];
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
(function (java) {
    var lang;
    (function (lang) {
        /**
         * See <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/UnsupportedOperationException.html">the
         * official Java API doc</a> for details.
         * @param {string} message
         * @param {java.lang.Throwable} cause
         * @class
         * @extends java.lang.RuntimeException
         */
        class UnsupportedOperationException extends java.lang.RuntimeException {
            constructor(message, cause) {
                if (((typeof message === 'string') || message === null) && ((cause != null && cause instanceof Error) || cause === null)) {
                    let __args = arguments;
                    super(message, cause);
                    Object.setPrototypeOf(this, UnsupportedOperationException.prototype);
                }
                else if (((typeof message === 'string') || message === null) && cause === undefined) {
                    let __args = arguments;
                    super(message);
                    Object.setPrototypeOf(this, UnsupportedOperationException.prototype);
                }
                else if (((message != null && message instanceof Error) || message === null) && cause === undefined) {
                    let __args = arguments;
                    let cause = __args[0];
                    super(cause);
                    Object.setPrototypeOf(this, UnsupportedOperationException.prototype);
                }
                else if (message === undefined && cause === undefined) {
                    let __args = arguments;
                    super();
                    Object.setPrototypeOf(this, UnsupportedOperationException.prototype);
                }
                else
                    throw new Error('invalid overload');
            }
        }
        lang.UnsupportedOperationException = UnsupportedOperationException;
        UnsupportedOperationException["__class"] = "java.lang.UnsupportedOperationException";
        UnsupportedOperationException["__interfaces"] = ["java.io.Serializable"];
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
(function (java) {
    var nio;
    (function (nio) {
        class BufferOverflowException extends java.lang.RuntimeException {
            constructor() {
                super();
                Object.setPrototypeOf(this, BufferOverflowException.prototype);
            }
        }
        nio.BufferOverflowException = BufferOverflowException;
        BufferOverflowException["__class"] = "java.nio.BufferOverflowException";
        BufferOverflowException["__interfaces"] = ["java.io.Serializable"];
    })(nio = java.nio || (java.nio = {}));
})(java || (java = {}));
(function (java) {
    var nio;
    (function (nio) {
        class BufferUnderflowException extends java.lang.RuntimeException {
            constructor() {
                super();
                Object.setPrototypeOf(this, BufferUnderflowException.prototype);
            }
        }
        nio.BufferUnderflowException = BufferUnderflowException;
        BufferUnderflowException["__class"] = "java.nio.BufferUnderflowException";
        BufferUnderflowException["__interfaces"] = ["java.io.Serializable"];
    })(nio = java.nio || (java.nio = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        /**
         * See <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/ConcurrentModificationException.html">the
         * official Java API doc</a> for details.
         * @param {string} message
         * @class
         * @extends java.lang.RuntimeException
         */
        class ConcurrentModificationException extends java.lang.RuntimeException {
            constructor(message) {
                if (((typeof message === 'string') || message === null)) {
                    let __args = arguments;
                    super(message);
                    Object.setPrototypeOf(this, ConcurrentModificationException.prototype);
                }
                else if (message === undefined) {
                    let __args = arguments;
                    super();
                    Object.setPrototypeOf(this, ConcurrentModificationException.prototype);
                }
                else
                    throw new Error('invalid overload');
            }
        }
        util.ConcurrentModificationException = ConcurrentModificationException;
        ConcurrentModificationException["__class"] = "java.util.ConcurrentModificationException";
        ConcurrentModificationException["__interfaces"] = ["java.io.Serializable"];
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        /**
         * See <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/EmptyStackException.html">the
         * official Java API doc</a> for details.
         * @class
         * @extends java.lang.RuntimeException
         */
        class EmptyStackException extends java.lang.RuntimeException {
            constructor() {
                super();
                Object.setPrototypeOf(this, EmptyStackException.prototype);
            }
        }
        util.EmptyStackException = EmptyStackException;
        EmptyStackException["__class"] = "java.util.EmptyStackException";
        EmptyStackException["__interfaces"] = ["java.io.Serializable"];
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        /**
         * See <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/MissingResourceException.html">the
         * official Java API doc</a> for details.
         * @param {string} s
         * @param {string} className
         * @param {string} key
         * @class
         * @extends java.lang.RuntimeException
         */
        class MissingResourceException extends java.lang.RuntimeException {
            constructor(s, className, key) {
                super(s);
                Object.setPrototypeOf(this, MissingResourceException.prototype);
                if (this.className === undefined)
                    this.className = null;
                if (this.key === undefined)
                    this.key = null;
                this.key = key;
                this.className = className;
            }
            getClassName() {
                return this.className;
            }
            getKey() {
                return this.key;
            }
        }
        util.MissingResourceException = MissingResourceException;
        MissingResourceException["__class"] = "java.util.MissingResourceException";
        MissingResourceException["__interfaces"] = ["java.io.Serializable"];
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        /**
         * See <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/NoSuchElementException.html">the
         * official Java API doc</a> for details.
         * @param {string} s
         * @class
         * @extends java.lang.RuntimeException
         */
        class NoSuchElementException extends java.lang.RuntimeException {
            constructor(s) {
                if (((typeof s === 'string') || s === null)) {
                    let __args = arguments;
                    super(s);
                    Object.setPrototypeOf(this, NoSuchElementException.prototype);
                }
                else if (s === undefined) {
                    let __args = arguments;
                    super();
                    Object.setPrototypeOf(this, NoSuchElementException.prototype);
                }
                else
                    throw new Error('invalid overload');
            }
        }
        util.NoSuchElementException = NoSuchElementException;
        NoSuchElementException["__class"] = "java.util.NoSuchElementException";
        NoSuchElementException["__interfaces"] = ["java.io.Serializable"];
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (javaemul) {
    var internal;
    (function (internal) {
        var stream;
        (function (stream) {
            class StopException extends java.lang.RuntimeException {
                constructor() {
                    super();
                    Object.setPrototypeOf(this, StopException.prototype);
                }
            }
            stream.StopException = StopException;
            StopException["__class"] = "javaemul.internal.stream.StopException";
            StopException["__interfaces"] = ["java.io.Serializable"];
        })(stream = internal.stream || (internal.stream = {}));
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
(function (java) {
    var security;
    (function (security) {
        /**
         * A generic security exception type - <a
         * href="http://java.sun.com/j2se/1.4.2/docs/api/java/security/DigestException.html">[Sun's
         * docs]</a>.
         * @param {string} msg
         * @class
         * @extends java.security.GeneralSecurityException
         */
        class DigestException extends java.security.GeneralSecurityException {
            constructor(msg) {
                if (((typeof msg === 'string') || msg === null)) {
                    let __args = arguments;
                    super(msg);
                    Object.setPrototypeOf(this, DigestException.prototype);
                }
                else if (msg === undefined) {
                    let __args = arguments;
                    super();
                    Object.setPrototypeOf(this, DigestException.prototype);
                }
                else
                    throw new Error('invalid overload');
            }
        }
        security.DigestException = DigestException;
        DigestException["__class"] = "java.security.DigestException";
        DigestException["__interfaces"] = ["java.io.Serializable"];
    })(security = java.security || (java.security = {}));
})(java || (java = {}));
(function (java) {
    var security;
    (function (security) {
        /**
         * A generic security exception type - <a
         * href="http://java.sun.com/j2se/1.4.2/docs/api/java/security/NoSuchAlgorithmException.html">[Sun's
         * docs]</a>.
         * @param {string} msg
         * @class
         * @extends java.security.GeneralSecurityException
         */
        class NoSuchAlgorithmException extends java.security.GeneralSecurityException {
            constructor(msg) {
                if (((typeof msg === 'string') || msg === null)) {
                    let __args = arguments;
                    super(msg);
                    Object.setPrototypeOf(this, NoSuchAlgorithmException.prototype);
                }
                else if (msg === undefined) {
                    let __args = arguments;
                    super();
                    Object.setPrototypeOf(this, NoSuchAlgorithmException.prototype);
                }
                else
                    throw new Error('invalid overload');
            }
        }
        security.NoSuchAlgorithmException = NoSuchAlgorithmException;
        NoSuchAlgorithmException["__class"] = "java.security.NoSuchAlgorithmException";
        NoSuchAlgorithmException["__interfaces"] = ["java.io.Serializable"];
    })(security = java.security || (java.security = {}));
})(java || (java = {}));
(function (java) {
    var nio;
    (function (nio) {
        var charset;
        (function (charset) {
            /**
             * Constant definitions for the standard Charsets.
             * @class
             */
            class StandardCharsets {
                constructor() {
                }
                static ISO_8859_1_$LI$() { if (StandardCharsets.ISO_8859_1 == null)
                    StandardCharsets.ISO_8859_1 = javaemul.internal.EmulatedCharset.ISO_8859_1_$LI$(); return StandardCharsets.ISO_8859_1; }
                ;
                static UTF_8_$LI$() { if (StandardCharsets.UTF_8 == null)
                    StandardCharsets.UTF_8 = javaemul.internal.EmulatedCharset.UTF_8_$LI$(); return StandardCharsets.UTF_8; }
                ;
            }
            charset.StandardCharsets = StandardCharsets;
            StandardCharsets["__class"] = "java.nio.charset.StandardCharsets";
        })(charset = nio.charset || (nio.charset = {}));
    })(nio = java.nio || (java.nio = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        /**
         * Skeletal implementation of the List interface. <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/AbstractSequentialList.html">[Sun
         * docs]</a>
         *
         * @param <E> element type.
         * @extends java.util.AbstractList
         * @class
         */
        class AbstractSequentialList extends java.util.AbstractList {
            constructor() {
                super();
            }
            add$int$java_lang_Object(index, element) {
                let iter = this.listIterator$int(index);
                iter.add(element);
            }
            /**
             *
             * @param {number} index
             * @param {*} element
             */
            add(index, element) {
                if (((typeof index === 'number') || index === null) && ((element != null) || element === null)) {
                    return this.add$int$java_lang_Object(index, element);
                }
                else if (((index != null) || index === null) && element === undefined) {
                    return this.add$java_lang_Object(index);
                }
                else
                    throw new Error('invalid overload');
            }
            addAll$int$java_util_Collection(index, c) {
                javaemul.internal.InternalPreconditions.checkNotNull(c);
                let modified = false;
                let iter = this.listIterator$int(index);
                for (let index141 = c.iterator(); index141.hasNext();) {
                    let e = index141.next();
                    {
                        iter.add(e);
                        modified = true;
                    }
                }
                return modified;
            }
            /**
             *
             * @param {number} index
             * @param {*} c
             * @return {boolean}
             */
            addAll(index, c) {
                if (((typeof index === 'number') || index === null) && ((c != null && (c["__interfaces"] != null && c["__interfaces"].indexOf("java.util.Collection") >= 0 || c.constructor != null && c.constructor["__interfaces"] != null && c.constructor["__interfaces"].indexOf("java.util.Collection") >= 0)) || c === null)) {
                    return this.addAll$int$java_util_Collection(index, c);
                }
                else if (((index != null && (index["__interfaces"] != null && index["__interfaces"].indexOf("java.util.Collection") >= 0 || index.constructor != null && index.constructor["__interfaces"] != null && index.constructor["__interfaces"].indexOf("java.util.Collection") >= 0)) || index === null) && c === undefined) {
                    super.addAll(index);
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             *
             * @param {number} index
             * @return {*}
             */
            get(index) {
                let iter = this.listIterator$int(index);
                try {
                    return iter.next();
                }
                catch (e) {
                    throw new java.lang.IndexOutOfBoundsException("Can\'t get element " + index);
                }
                ;
            }
            /**
             *
             * @return {*}
             */
            iterator() {
                return this.listIterator();
            }
            listIterator$int(index) { throw new Error('cannot invoke abstract overloaded method... check your argument(s) type(s)'); }
            /**
             *
             * @param {number} index
             * @return {*}
             */
            listIterator(index) {
                if (((typeof index === 'number') || index === null)) {
                    return this.listIterator$int(index);
                }
                else if (index === undefined) {
                    return this.listIterator$();
                }
                else
                    throw new Error('invalid overload');
            }
            remove$int(index) {
                let iter = this.listIterator$int(index);
                try {
                    let old = iter.next();
                    iter.remove();
                    return old;
                }
                catch (e) {
                    throw new java.lang.IndexOutOfBoundsException("Can\'t remove element " + index);
                }
                ;
            }
            /**
             *
             * @param {number} index
             * @return {*}
             */
            remove(index) {
                if (((typeof index === 'number') || index === null)) {
                    return this.remove$int(index);
                }
                else if (((index != null) || index === null)) {
                    super.remove(index);
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             *
             * @param {number} index
             * @param {*} element
             * @return {*}
             */
            set(index, element) {
                let iter = this.listIterator$int(index);
                try {
                    let old = iter.next();
                    iter.set(element);
                    return old;
                }
                catch (e) {
                    throw new java.lang.IndexOutOfBoundsException("Can\'t set element " + index);
                }
                ;
            }
        }
        util.AbstractSequentialList = AbstractSequentialList;
        AbstractSequentialList["__class"] = "java.util.AbstractSequentialList";
        AbstractSequentialList["__interfaces"] = ["java.util.List", "java.util.Collection", "java.lang.Iterable"];
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        /**
         * Resizeable array implementation of the List interface. <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/ArrayList.html">[Sun
         * docs]</a>
         *
         * <p>
         * This implementation differs from JDK 1.5 <code>ArrayList</code> in terms of
         * capacity management. There is no speed advantage to pre-allocating array
         * sizes in JavaScript, so this implementation does not include any of the
         * capacity and "growth increment" concepts in the standard ArrayList class.
         * Although <code>ArrayList(int)</code> accepts a value for the initial
         * capacity of the array, this constructor simply delegates to
         * <code>ArrayList()</code>. It is only present for compatibility with JDK
         * 1.5's API.
         * </p>
         *
         * @param <E> the element type.
         * @param {*} c
         * @class
         * @extends java.util.AbstractList
         */
        class ArrayList extends java.util.AbstractList {
            constructor(c) {
                if (((c != null && (c["__interfaces"] != null && c["__interfaces"].indexOf("java.util.Collection") >= 0 || c.constructor != null && c.constructor["__interfaces"] != null && c.constructor["__interfaces"].indexOf("java.util.Collection") >= 0)) || c === null)) {
                    let __args = arguments;
                    super();
                    if (this.array === undefined)
                        this.array = null;
                    if (this.exposeElement === undefined)
                        this.exposeElement = null;
                    if (this.array === undefined)
                        this.array = null;
                    if (this.exposeElement === undefined)
                        this.exposeElement = null;
                    (() => {
                        this.array = [];
                        javaemul.internal.ArrayHelper.insertValuesToArray(this.array, 0, c.toArray());
                    })();
                }
                else if (((typeof c === 'number') || c === null)) {
                    let __args = arguments;
                    let initialCapacity = __args[0];
                    super();
                    if (this.array === undefined)
                        this.array = null;
                    if (this.exposeElement === undefined)
                        this.exposeElement = null;
                    if (this.array === undefined)
                        this.array = null;
                    if (this.exposeElement === undefined)
                        this.exposeElement = null;
                    (() => {
                        javaemul.internal.InternalPreconditions.checkArgument(initialCapacity >= 0, "Initial capacity must not be negative");
                        this.array = [];
                    })();
                }
                else if (c === undefined) {
                    let __args = arguments;
                    super();
                    if (this.array === undefined)
                        this.array = null;
                    if (this.exposeElement === undefined)
                        this.exposeElement = null;
                    if (this.array === undefined)
                        this.array = null;
                    if (this.exposeElement === undefined)
                        this.exposeElement = null;
                    (() => {
                        this.array = [];
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            stream() {
                return (new javaemul.internal.stream.StreamHelper(this));
            }
            forEach(action) {
                javaemul.internal.InternalPreconditions.checkNotNull((action));
                for (let index142 = this.iterator(); index142.hasNext();) {
                    let t = index142.next();
                    {
                        (target => (typeof target === 'function') ? target(t) : target.accept(t))(action);
                    }
                }
            }
            removeIf(filter) {
                javaemul.internal.InternalPreconditions.checkNotNull((filter));
                let removed = false;
                for (let it = this.iterator(); it.hasNext();) {
                    {
                        if ((target => (typeof target === 'function') ? target(it.next()) : target.test(it.next()))(filter)) {
                            it.remove();
                            removed = true;
                        }
                    }
                    ;
                }
                return removed;
            }
            add$java_lang_Object(o) {
                this.array[this.array.length] = o;
                return true;
            }
            add$int$java_lang_Object(index, o) {
                javaemul.internal.InternalPreconditions.checkPositionIndex(index, this.array.length);
                javaemul.internal.ArrayHelper.insertTo$java_lang_Object$int$java_lang_Object(this.array, index, o);
            }
            /**
             *
             * @param {number} index
             * @param {*} o
             */
            add(index, o) {
                if (((typeof index === 'number') || index === null) && ((o != null) || o === null)) {
                    return this.add$int$java_lang_Object(index, o);
                }
                else if (((index != null) || index === null) && o === undefined) {
                    return this.add$java_lang_Object(index);
                }
                else
                    throw new Error('invalid overload');
            }
            addAll$java_util_Collection(c) {
                let cArray = c.toArray();
                let len = cArray.length;
                if (len === 0) {
                    return false;
                }
                javaemul.internal.ArrayHelper.insertValuesToArray(this.array, this.array.length, cArray);
                return true;
            }
            addAll$int$java_util_Collection(index, c) {
                javaemul.internal.InternalPreconditions.checkPositionIndex(index, this.array.length);
                let cArray = c.toArray();
                let len = cArray.length;
                if (len === 0) {
                    return false;
                }
                javaemul.internal.ArrayHelper.insertValuesToArray(this.array, index, cArray);
                return true;
            }
            /**
             *
             * @param {number} index
             * @param {*} c
             * @return {boolean}
             */
            addAll(index, c) {
                if (((typeof index === 'number') || index === null) && ((c != null && (c["__interfaces"] != null && c["__interfaces"].indexOf("java.util.Collection") >= 0 || c.constructor != null && c.constructor["__interfaces"] != null && c.constructor["__interfaces"].indexOf("java.util.Collection") >= 0)) || c === null)) {
                    return this.addAll$int$java_util_Collection(index, c);
                }
                else if (((index != null && (index["__interfaces"] != null && index["__interfaces"].indexOf("java.util.Collection") >= 0 || index.constructor != null && index.constructor["__interfaces"] != null && index.constructor["__interfaces"].indexOf("java.util.Collection") >= 0)) || index === null) && c === undefined) {
                    return this.addAll$java_util_Collection(index);
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             *
             */
            clear() {
                this.array = [];
            }
            clone() {
                return (new ArrayList(this));
            }
            /**
             *
             * @param {*} o
             * @return {boolean}
             */
            contains(o) {
                return (this.indexOf$java_lang_Object(o) !== -1);
            }
            ensureCapacity(ignored) {
            }
            /**
             *
             * @param {number} index
             * @return {*}
             */
            get(index) {
                javaemul.internal.InternalPreconditions.checkElementIndex(index, this.array.length);
                return this.array[index];
            }
            indexOf$java_lang_Object(o) {
                return this.indexOf$java_lang_Object$int(o, 0);
            }
            /**
             *
             * @return {*}
             */
            iterator() {
                return new ArrayList.ArrayList$0(this);
            }
            /**
             *
             * @return {boolean}
             */
            isEmpty() {
                return this.array.length === 0;
            }
            lastIndexOf$java_lang_Object(o) {
                return this.lastIndexOf$java_lang_Object$int(o, this.size() - 1);
            }
            remove$int(index) {
                let previous = this.get(index);
                javaemul.internal.ArrayHelper.removeFrom(this.array, index, 1);
                return previous;
            }
            /**
             *
             * @param {number} index
             * @return {*}
             */
            remove(index) {
                if (((typeof index === 'number') || index === null)) {
                    return this.remove$int(index);
                }
                else if (((index != null) || index === null)) {
                    return this.remove$java_lang_Object(index);
                }
                else
                    throw new Error('invalid overload');
            }
            remove$java_lang_Object(o) {
                let i = this.indexOf$java_lang_Object(o);
                if (i === -1) {
                    return false;
                }
                this.remove$int(i);
                return true;
            }
            /**
             *
             * @param {number} index
             * @param {*} o
             * @return {*}
             */
            set(index, o) {
                let previous = this.get(index);
                this.array[index] = o;
                return previous;
            }
            /**
             *
             * @return {number}
             */
            size() {
                return this.array.length;
            }
            toArray$() {
                return javaemul.internal.ArrayHelper.clone(this.array, 0, this.array.length);
            }
            toArray$java_lang_Object_A(out) {
                let size = this.array.length;
                if (out.length < size) {
                    out = javaemul.internal.ArrayHelper.createFrom(out, size);
                }
                for (let i = 0; i < size; ++i) {
                    {
                        out[i] = (this.array[i]);
                    }
                    ;
                }
                if (out.length > size) {
                    out[size] = null;
                }
                return out;
            }
            /**
             *
             * @param {Array} out
             * @return {Array}
             */
            toArray(out) {
                if (((out != null && out instanceof Array && (out.length == 0 || out[0] == null || (out[0] != null))) || out === null)) {
                    return this.toArray$java_lang_Object_A(out);
                }
                else if (out === undefined) {
                    return this.toArray$();
                }
                else
                    throw new Error('invalid overload');
            }
            trimToSize() {
            }
            /**
             *
             * @param {number} fromIndex
             * @param {number} endIndex
             */
            removeRange(fromIndex, endIndex) {
                javaemul.internal.InternalPreconditions.checkPositionIndexes(fromIndex, endIndex, this.array.length);
                let count = endIndex - fromIndex;
                javaemul.internal.ArrayHelper.removeFrom(this.array, fromIndex, count);
            }
            indexOf$java_lang_Object$int(o, index) {
                for (; index < this.array.length; ++index) {
                    {
                        if (java.util.Objects.equals(o, this.array[index])) {
                            return index;
                        }
                    }
                    ;
                }
                return -1;
            }
            /**
             * Used by Vector.
             * @param {*} o
             * @param {number} index
             * @return {number}
             */
            indexOf(o, index) {
                if (((o != null) || o === null) && ((typeof index === 'number') || index === null)) {
                    return this.indexOf$java_lang_Object$int(o, index);
                }
                else if (((o != null) || o === null) && index === undefined) {
                    return this.indexOf$java_lang_Object(o);
                }
                else
                    throw new Error('invalid overload');
            }
            lastIndexOf$java_lang_Object$int(o, index) {
                for (; index >= 0; --index) {
                    {
                        if (java.util.Objects.equals(o, this.array[index])) {
                            return index;
                        }
                    }
                    ;
                }
                return -1;
            }
            /**
             * Used by Vector.
             * @param {*} o
             * @param {number} index
             * @return {number}
             */
            lastIndexOf(o, index) {
                if (((o != null) || o === null) && ((typeof index === 'number') || index === null)) {
                    return this.lastIndexOf$java_lang_Object$int(o, index);
                }
                else if (((o != null) || o === null) && index === undefined) {
                    return this.lastIndexOf$java_lang_Object(o);
                }
                else
                    throw new Error('invalid overload');
            }
            setSize(newSize) {
                javaemul.internal.ArrayHelper.setLength(this.array, newSize);
            }
        }
        util.ArrayList = ArrayList;
        ArrayList["__class"] = "java.util.ArrayList";
        ArrayList["__interfaces"] = ["java.util.RandomAccess", "java.util.List", "java.lang.Cloneable", "java.util.Collection", "java.lang.Iterable", "java.io.Serializable"];
        (function (ArrayList) {
            class ArrayList$0 {
                constructor(__parent) {
                    this.__parent = __parent;
                    this.i = 0;
                    this.last = -1;
                }
                forEachRemaining(consumer) {
                    javaemul.internal.InternalPreconditions.checkNotNull((consumer));
                    while ((this.hasNext())) {
                        {
                            (target => (typeof target === 'function') ? target(this.next()) : target.accept(this.next()))(consumer);
                        }
                    }
                    ;
                }
                /**
                 *
                 * @return {boolean}
                 */
                hasNext() {
                    return this.i < this.__parent.array.length;
                }
                /**
                 *
                 * @return {*}
                 */
                next() {
                    javaemul.internal.InternalPreconditions.checkElement(this.hasNext());
                    this.last = this.i++;
                    return this.__parent.array[this.last];
                }
                /**
                 *
                 */
                remove() {
                    javaemul.internal.InternalPreconditions.checkState(this.last !== -1);
                    this.__parent.remove$int(this.i = this.last);
                    this.last = -1;
                }
            }
            ArrayList.ArrayList$0 = ArrayList$0;
            ArrayList$0["__interfaces"] = ["java.util.Iterator"];
        })(ArrayList = util.ArrayList || (util.ArrayList = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        /**
         * Utility methods related to native arrays. <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Arrays.html">[Sun
         * docs]</a>
         * @class
         */
        class Arrays {
            static asList(...array) {
                if (array.length === 1 && Array.isArray(array[0])) {
                    array = (array[0]);
                }
                return (new Arrays.ArrayList(array));
            }
            static stream(...array) {
                return Arrays.asList.apply(this, array).stream();
            }
            static binarySearch$byte_A$byte(sortedArray, key) {
                let low = 0;
                let high = sortedArray.length - 1;
                while ((low <= high)) {
                    {
                        let mid = low + ((high - low) >> 1);
                        let midVal = sortedArray[mid];
                        if (midVal < key) {
                            low = mid + 1;
                        }
                        else if (midVal > key) {
                            high = mid - 1;
                        }
                        else {
                            return mid;
                        }
                    }
                }
                ;
                return -low - 1;
            }
            static binarySearch$char_A$char(a, key) {
                let low = 0;
                let high = a.length - 1;
                while ((low <= high)) {
                    {
                        let mid = low + ((high - low) >> 1);
                        let midVal = a[mid];
                        if ((c => c.charCodeAt == null ? c : c.charCodeAt(0))(midVal) < (c => c.charCodeAt == null ? c : c.charCodeAt(0))(key)) {
                            low = mid + 1;
                        }
                        else if ((c => c.charCodeAt == null ? c : c.charCodeAt(0))(midVal) > (c => c.charCodeAt == null ? c : c.charCodeAt(0))(key)) {
                            high = mid - 1;
                        }
                        else {
                            return mid;
                        }
                    }
                }
                ;
                return -low - 1;
            }
            static binarySearch$double_A$double(sortedArray, key) {
                let low = 0;
                let high = sortedArray.length - 1;
                while ((low <= high)) {
                    {
                        let mid = low + ((high - low) >> 1);
                        let midVal = sortedArray[mid];
                        if (midVal < key) {
                            low = mid + 1;
                        }
                        else if (midVal > key) {
                            high = mid - 1;
                        }
                        else {
                            return mid;
                        }
                    }
                }
                ;
                return -low - 1;
            }
            static binarySearch$float_A$float(sortedArray, key) {
                let low = 0;
                let high = sortedArray.length - 1;
                while ((low <= high)) {
                    {
                        let mid = low + ((high - low) >> 1);
                        let midVal = sortedArray[mid];
                        if (midVal < key) {
                            low = mid + 1;
                        }
                        else if (midVal > key) {
                            high = mid - 1;
                        }
                        else {
                            return mid;
                        }
                    }
                }
                ;
                return -low - 1;
            }
            static binarySearch$int_A$int(sortedArray, key) {
                let low = 0;
                let high = sortedArray.length - 1;
                while ((low <= high)) {
                    {
                        let mid = low + ((high - low) >> 1);
                        let midVal = sortedArray[mid];
                        if (midVal < key) {
                            low = mid + 1;
                        }
                        else if (midVal > key) {
                            high = mid - 1;
                        }
                        else {
                            return mid;
                        }
                    }
                }
                ;
                return -low - 1;
            }
            static binarySearch$long_A$long(sortedArray, key) {
                let low = 0;
                let high = sortedArray.length - 1;
                while ((low <= high)) {
                    {
                        let mid = low + ((high - low) >> 1);
                        let midVal = sortedArray[mid];
                        if (midVal < key) {
                            low = mid + 1;
                        }
                        else if (midVal > key) {
                            high = mid - 1;
                        }
                        else {
                            return mid;
                        }
                    }
                }
                ;
                return -low - 1;
            }
            static binarySearch$java_lang_Object_A$java_lang_Object(sortedArray, key) {
                return Arrays.binarySearch(sortedArray, key, java.util.Comparators.natural());
            }
            static binarySearch$short_A$short(sortedArray, key) {
                let low = 0;
                let high = sortedArray.length - 1;
                while ((low <= high)) {
                    {
                        let mid = low + ((high - low) >> 1);
                        let midVal = sortedArray[mid];
                        if (midVal < key) {
                            low = mid + 1;
                        }
                        else if (midVal > key) {
                            high = mid - 1;
                        }
                        else {
                            return mid;
                        }
                    }
                }
                ;
                return -low - 1;
            }
            static binarySearch$java_lang_Object_A$java_lang_Object$java_util_Comparator(sortedArray, key, comparator) {
                if (comparator == null) {
                    comparator = java.util.Comparators.natural();
                }
                let low = 0;
                let high = sortedArray.length - 1;
                while ((low <= high)) {
                    {
                        let mid = low + ((high - low) >> 1);
                        let midVal = sortedArray[mid];
                        let compareResult = comparator.compare(midVal, key);
                        if (compareResult < 0) {
                            low = mid + 1;
                        }
                        else if (compareResult > 0) {
                            high = mid - 1;
                        }
                        else {
                            return mid;
                        }
                    }
                }
                ;
                return -low - 1;
            }
            /**
             * Perform a binary search on a sorted object array, using a user-specified
             * comparison function.
             *
             * @param {Array} sortedArray object array to search
             * @param {*} key value to search for
             * @param {*} comparator comparision function, <code>null</code> indicates
             * <i>natural ordering</i> should be used.
             * @return {number} the index of an element with a matching value, or a negative number
             * which is the index of the next larger value (or just past the end
             * of the array if the searched value is larger than all elements in
             * the array) minus 1 (to ensure error returns are negative)
             * @throws ClassCastException if <code>key</code> and
             * <code>sortedArray</code>'s elements cannot be compared by
             * <code>comparator</code>.
             */
            static binarySearch(sortedArray, key, comparator) {
                if (((sortedArray != null && sortedArray instanceof Array && (sortedArray.length == 0 || sortedArray[0] == null || (sortedArray[0] != null))) || sortedArray === null) && ((key != null) || key === null) && ((comparator != null && (comparator["__interfaces"] != null && comparator["__interfaces"].indexOf("java.util.Comparator") >= 0 || comparator.constructor != null && comparator.constructor["__interfaces"] != null && comparator.constructor["__interfaces"].indexOf("java.util.Comparator") >= 0)) || comparator === null)) {
                    return java.util.Arrays.binarySearch$java_lang_Object_A$java_lang_Object$java_util_Comparator(sortedArray, key, comparator);
                }
                else if (((sortedArray != null && sortedArray instanceof Array && (sortedArray.length == 0 || sortedArray[0] == null || (typeof sortedArray[0] === 'number'))) || sortedArray === null) && ((typeof key === 'number') || key === null) && comparator === undefined) {
                    return java.util.Arrays.binarySearch$byte_A$byte(sortedArray, key);
                }
                else if (((sortedArray != null && sortedArray instanceof Array && (sortedArray.length == 0 || sortedArray[0] == null || (typeof sortedArray[0] === 'string'))) || sortedArray === null) && ((typeof key === 'string') || key === null) && comparator === undefined) {
                    return java.util.Arrays.binarySearch$char_A$char(sortedArray, key);
                }
                else if (((sortedArray != null && sortedArray instanceof Array && (sortedArray.length == 0 || sortedArray[0] == null || (typeof sortedArray[0] === 'number'))) || sortedArray === null) && ((typeof key === 'number') || key === null) && comparator === undefined) {
                    return java.util.Arrays.binarySearch$short_A$short(sortedArray, key);
                }
                else if (((sortedArray != null && sortedArray instanceof Array && (sortedArray.length == 0 || sortedArray[0] == null || (typeof sortedArray[0] === 'number'))) || sortedArray === null) && ((typeof key === 'number') || key === null) && comparator === undefined) {
                    return java.util.Arrays.binarySearch$int_A$int(sortedArray, key);
                }
                else if (((sortedArray != null && sortedArray instanceof Array && (sortedArray.length == 0 || sortedArray[0] == null || (typeof sortedArray[0] === 'number'))) || sortedArray === null) && ((typeof key === 'number') || key === null) && comparator === undefined) {
                    return java.util.Arrays.binarySearch$long_A$long(sortedArray, key);
                }
                else if (((sortedArray != null && sortedArray instanceof Array && (sortedArray.length == 0 || sortedArray[0] == null || (typeof sortedArray[0] === 'number'))) || sortedArray === null) && ((typeof key === 'number') || key === null) && comparator === undefined) {
                    return java.util.Arrays.binarySearch$float_A$float(sortedArray, key);
                }
                else if (((sortedArray != null && sortedArray instanceof Array && (sortedArray.length == 0 || sortedArray[0] == null || (typeof sortedArray[0] === 'number'))) || sortedArray === null) && ((typeof key === 'number') || key === null) && comparator === undefined) {
                    return java.util.Arrays.binarySearch$double_A$double(sortedArray, key);
                }
                else if (((sortedArray != null && sortedArray instanceof Array && (sortedArray.length == 0 || sortedArray[0] == null || (sortedArray[0] != null))) || sortedArray === null) && ((key != null) || key === null) && comparator === undefined) {
                    return java.util.Arrays.binarySearch$java_lang_Object_A$java_lang_Object(sortedArray, key);
                }
                else
                    throw new Error('invalid overload');
            }
            static copyOf$boolean_A$int(original, newLength) {
                javaemul.internal.InternalPreconditions.checkArraySize(newLength);
                return Arrays.copyOfRange$boolean_A$int$int(original, 0, newLength);
            }
            static copyOf(original, newLength) {
                if (((original != null && original instanceof Array && (original.length == 0 || original[0] == null || (typeof original[0] === 'boolean'))) || original === null) && ((typeof newLength === 'number') || newLength === null)) {
                    return java.util.Arrays.copyOf$boolean_A$int(original, newLength);
                }
                else if (((original != null && original instanceof Array && (original.length == 0 || original[0] == null || (typeof original[0] === 'number'))) || original === null) && ((typeof newLength === 'number') || newLength === null)) {
                    return java.util.Arrays.copyOf$byte_A$int(original, newLength);
                }
                else if (((original != null && original instanceof Array && (original.length == 0 || original[0] == null || (typeof original[0] === 'string'))) || original === null) && ((typeof newLength === 'number') || newLength === null)) {
                    return java.util.Arrays.copyOf$char_A$int(original, newLength);
                }
                else if (((original != null && original instanceof Array && (original.length == 0 || original[0] == null || (typeof original[0] === 'number'))) || original === null) && ((typeof newLength === 'number') || newLength === null)) {
                    return java.util.Arrays.copyOf$double_A$int(original, newLength);
                }
                else if (((original != null && original instanceof Array && (original.length == 0 || original[0] == null || (typeof original[0] === 'number'))) || original === null) && ((typeof newLength === 'number') || newLength === null)) {
                    return java.util.Arrays.copyOf$float_A$int(original, newLength);
                }
                else if (((original != null && original instanceof Array && (original.length == 0 || original[0] == null || (typeof original[0] === 'number'))) || original === null) && ((typeof newLength === 'number') || newLength === null)) {
                    return java.util.Arrays.copyOf$int_A$int(original, newLength);
                }
                else if (((original != null && original instanceof Array && (original.length == 0 || original[0] == null || (typeof original[0] === 'number'))) || original === null) && ((typeof newLength === 'number') || newLength === null)) {
                    return java.util.Arrays.copyOf$long_A$int(original, newLength);
                }
                else if (((original != null && original instanceof Array && (original.length == 0 || original[0] == null || (typeof original[0] === 'number'))) || original === null) && ((typeof newLength === 'number') || newLength === null)) {
                    return java.util.Arrays.copyOf$short_A$int(original, newLength);
                }
                else if (((original != null && original instanceof Array && (original.length == 0 || original[0] == null || (original[0] != null))) || original === null) && ((typeof newLength === 'number') || newLength === null)) {
                    return java.util.Arrays.copyOf$java_lang_Object_A$int(original, newLength);
                }
                else
                    throw new Error('invalid overload');
            }
            static copyOf$byte_A$int(original, newLength) {
                javaemul.internal.InternalPreconditions.checkArraySize(newLength);
                return Arrays.copyOfRange$byte_A$int$int(original, 0, newLength);
            }
            static copyOf$char_A$int(original, newLength) {
                javaemul.internal.InternalPreconditions.checkArraySize(newLength);
                return Arrays.copyOfRange$char_A$int$int(original, 0, newLength);
            }
            static copyOf$double_A$int(original, newLength) {
                javaemul.internal.InternalPreconditions.checkArraySize(newLength);
                return Arrays.copyOfRange$double_A$int$int(original, 0, newLength);
            }
            static copyOf$float_A$int(original, newLength) {
                javaemul.internal.InternalPreconditions.checkArraySize(newLength);
                return Arrays.copyOfRange$float_A$int$int(original, 0, newLength);
            }
            static copyOf$int_A$int(original, newLength) {
                javaemul.internal.InternalPreconditions.checkArraySize(newLength);
                return Arrays.copyOfRange$int_A$int$int(original, 0, newLength);
            }
            static copyOf$long_A$int(original, newLength) {
                javaemul.internal.InternalPreconditions.checkArraySize(newLength);
                return Arrays.copyOfRange$long_A$int$int(original, 0, newLength);
            }
            static copyOf$short_A$int(original, newLength) {
                javaemul.internal.InternalPreconditions.checkArraySize(newLength);
                return Arrays.copyOfRange$short_A$int$int(original, 0, newLength);
            }
            static copyOf$java_lang_Object_A$int(original, newLength) {
                javaemul.internal.InternalPreconditions.checkArraySize(newLength);
                javaemul.internal.InternalPreconditions.checkNotNull(original, "original");
                let clone = javaemul.internal.ArrayHelper.clone(original, 0, newLength);
                javaemul.internal.ArrayHelper.setLength(clone, newLength);
                return clone;
            }
            static copyOfRange$boolean_A$int$int(original, from, to) {
                let len = Arrays.getCopyLength(original, from, to);
                let copy = (s => { let a = []; while (s-- > 0)
                    a.push(false); return a; })(to - from);
                javaemul.internal.ArrayHelper.copy$java_lang_Object$int$java_lang_Object$int$int(original, from, copy, 0, len);
                return copy;
            }
            static copyOfRange(original, from, to) {
                if (((original != null && original instanceof Array && (original.length == 0 || original[0] == null || (typeof original[0] === 'boolean'))) || original === null) && ((typeof from === 'number') || from === null) && ((typeof to === 'number') || to === null)) {
                    return java.util.Arrays.copyOfRange$boolean_A$int$int(original, from, to);
                }
                else if (((original != null && original instanceof Array && (original.length == 0 || original[0] == null || (typeof original[0] === 'number'))) || original === null) && ((typeof from === 'number') || from === null) && ((typeof to === 'number') || to === null)) {
                    return java.util.Arrays.copyOfRange$byte_A$int$int(original, from, to);
                }
                else if (((original != null && original instanceof Array && (original.length == 0 || original[0] == null || (typeof original[0] === 'string'))) || original === null) && ((typeof from === 'number') || from === null) && ((typeof to === 'number') || to === null)) {
                    return java.util.Arrays.copyOfRange$char_A$int$int(original, from, to);
                }
                else if (((original != null && original instanceof Array && (original.length == 0 || original[0] == null || (typeof original[0] === 'number'))) || original === null) && ((typeof from === 'number') || from === null) && ((typeof to === 'number') || to === null)) {
                    return java.util.Arrays.copyOfRange$double_A$int$int(original, from, to);
                }
                else if (((original != null && original instanceof Array && (original.length == 0 || original[0] == null || (typeof original[0] === 'number'))) || original === null) && ((typeof from === 'number') || from === null) && ((typeof to === 'number') || to === null)) {
                    return java.util.Arrays.copyOfRange$float_A$int$int(original, from, to);
                }
                else if (((original != null && original instanceof Array && (original.length == 0 || original[0] == null || (typeof original[0] === 'number'))) || original === null) && ((typeof from === 'number') || from === null) && ((typeof to === 'number') || to === null)) {
                    return java.util.Arrays.copyOfRange$int_A$int$int(original, from, to);
                }
                else if (((original != null && original instanceof Array && (original.length == 0 || original[0] == null || (typeof original[0] === 'number'))) || original === null) && ((typeof from === 'number') || from === null) && ((typeof to === 'number') || to === null)) {
                    return java.util.Arrays.copyOfRange$long_A$int$int(original, from, to);
                }
                else if (((original != null && original instanceof Array && (original.length == 0 || original[0] == null || (typeof original[0] === 'number'))) || original === null) && ((typeof from === 'number') || from === null) && ((typeof to === 'number') || to === null)) {
                    return java.util.Arrays.copyOfRange$short_A$int$int(original, from, to);
                }
                else if (((original != null && original instanceof Array && (original.length == 0 || original[0] == null || (original[0] != null))) || original === null) && ((typeof from === 'number') || from === null) && ((typeof to === 'number') || to === null)) {
                    return java.util.Arrays.copyOfRange$java_lang_Object_A$int$int(original, from, to);
                }
                else
                    throw new Error('invalid overload');
            }
            static copyOfRange$byte_A$int$int(original, from, to) {
                let len = Arrays.getCopyLength(original, from, to);
                let copy = (s => { let a = []; while (s-- > 0)
                    a.push(0); return a; })(to - from);
                javaemul.internal.ArrayHelper.copy$java_lang_Object$int$java_lang_Object$int$int(original, from, copy, 0, len);
                return copy;
            }
            static copyOfRange$char_A$int$int(original, from, to) {
                let len = Arrays.getCopyLength(original, from, to);
                let copy = (s => { let a = []; while (s-- > 0)
                    a.push(null); return a; })(to - from);
                javaemul.internal.ArrayHelper.copy$java_lang_Object$int$java_lang_Object$int$int(original, from, copy, 0, len);
                return copy;
            }
            static copyOfRange$double_A$int$int(original, from, to) {
                let len = Arrays.getCopyLength(original, from, to);
                let copy = (s => { let a = []; while (s-- > 0)
                    a.push(0); return a; })(to - from);
                javaemul.internal.ArrayHelper.copy$java_lang_Object$int$java_lang_Object$int$int(original, from, copy, 0, len);
                return copy;
            }
            static copyOfRange$float_A$int$int(original, from, to) {
                let len = Arrays.getCopyLength(original, from, to);
                let copy = (s => { let a = []; while (s-- > 0)
                    a.push(0); return a; })(to - from);
                javaemul.internal.ArrayHelper.copy$java_lang_Object$int$java_lang_Object$int$int(original, from, copy, 0, len);
                return copy;
            }
            static copyOfRange$int_A$int$int(original, from, to) {
                let len = Arrays.getCopyLength(original, from, to);
                let copy = (s => { let a = []; while (s-- > 0)
                    a.push(0); return a; })(to - from);
                javaemul.internal.ArrayHelper.copy$java_lang_Object$int$java_lang_Object$int$int(original, from, copy, 0, len);
                return copy;
            }
            static copyOfRange$long_A$int$int(original, from, to) {
                let len = Arrays.getCopyLength(original, from, to);
                let copy = (s => { let a = []; while (s-- > 0)
                    a.push(0); return a; })(to - from);
                javaemul.internal.ArrayHelper.copy$java_lang_Object$int$java_lang_Object$int$int(original, from, copy, 0, len);
                return copy;
            }
            static copyOfRange$short_A$int$int(original, from, to) {
                let len = Arrays.getCopyLength(original, from, to);
                let copy = (s => { let a = []; while (s-- > 0)
                    a.push(0); return a; })(to - from);
                javaemul.internal.ArrayHelper.copy$java_lang_Object$int$java_lang_Object$int$int(original, from, copy, 0, len);
                return copy;
            }
            static copyOfRange$java_lang_Object_A$int$int(original, from, to) {
                let len = Arrays.getCopyLength(original, from, to);
                let copy = javaemul.internal.ArrayHelper.createFrom(original, to - from);
                javaemul.internal.ArrayHelper.copy$java_lang_Object$int$java_lang_Object$int$int(original, from, copy, 0, len);
                return copy;
            }
            static deepEquals(a1, a2) {
                if (a1 === a2) {
                    return true;
                }
                if (a1 == null || a2 == null) {
                    return false;
                }
                if (a1.length !== a2.length) {
                    return false;
                }
                for (let i = 0, n = a1.length; i < n; ++i) {
                    {
                        if (!java.util.Objects.deepEquals(a1[i], a2[i])) {
                            return false;
                        }
                    }
                    ;
                }
                return true;
            }
            static deepHashCode(a) {
                if (a == null) {
                    return 0;
                }
                let hashCode = 1;
                for (let index143 = 0; index143 < a.length; index143++) {
                    let obj = a[index143];
                    {
                        let hash;
                        if (obj != null && obj instanceof Array && (obj.length == 0 || obj[0] == null || obj[0] != null)) {
                            hash = Arrays.deepHashCode(obj);
                        }
                        else if (obj != null && obj instanceof Array && (obj.length == 0 || obj[0] == null || typeof obj[0] === 'boolean')) {
                            hash = Arrays.hashCode$boolean_A(obj);
                        }
                        else if (obj != null && obj instanceof Array && (obj.length == 0 || obj[0] == null || typeof obj[0] === 'number')) {
                            hash = Arrays.hashCode$byte_A(obj);
                        }
                        else if (obj != null && obj instanceof Array && (obj.length == 0 || obj[0] == null || typeof obj[0] === 'string')) {
                            hash = Arrays.hashCode$char_A(obj);
                        }
                        else if (obj != null && obj instanceof Array && (obj.length == 0 || obj[0] == null || typeof obj[0] === 'number')) {
                            hash = Arrays.hashCode$short_A(obj);
                        }
                        else if (obj != null && obj instanceof Array && (obj.length == 0 || obj[0] == null || typeof obj[0] === 'number')) {
                            hash = Arrays.hashCode$int_A(obj);
                        }
                        else if (obj != null && obj instanceof Array && (obj.length == 0 || obj[0] == null || typeof obj[0] === 'number')) {
                            hash = Arrays.hashCode$long_A(obj);
                        }
                        else if (obj != null && obj instanceof Array && (obj.length == 0 || obj[0] == null || typeof obj[0] === 'number')) {
                            hash = Arrays.hashCode$float_A(obj);
                        }
                        else if (obj != null && obj instanceof Array && (obj.length == 0 || obj[0] == null || typeof obj[0] === 'number')) {
                            hash = Arrays.hashCode$double_A(obj);
                        }
                        else {
                            hash = java.util.Objects.hashCode(obj);
                        }
                        hashCode = 31 * hashCode + hash;
                        hashCode = javaemul.internal.Coercions.ensureInt(hashCode);
                    }
                }
                return hashCode;
            }
            static deepToString$java_lang_Object_A(a) {
                return Arrays.deepToString$java_lang_Object_A$java_util_Set(a, (new java.util.HashSet()));
            }
            static equals$boolean_A$boolean_A(array1, array2) {
                if (array1 === array2) {
                    return true;
                }
                if (array1 == null || array2 == null) {
                    return false;
                }
                if (array1.length !== array2.length) {
                    return false;
                }
                for (let i = 0; i < array1.length; ++i) {
                    {
                        if (array1[i] !== array2[i]) {
                            return false;
                        }
                    }
                    ;
                }
                return true;
            }
            static equals(array1, array2) {
                if (((array1 != null && array1 instanceof Array && (array1.length == 0 || array1[0] == null || (typeof array1[0] === 'boolean'))) || array1 === null) && ((array2 != null && array2 instanceof Array && (array2.length == 0 || array2[0] == null || (typeof array2[0] === 'boolean'))) || array2 === null)) {
                    return java.util.Arrays.equals$boolean_A$boolean_A(array1, array2);
                }
                else if (((array1 != null && array1 instanceof Array && (array1.length == 0 || array1[0] == null || (typeof array1[0] === 'number'))) || array1 === null) && ((array2 != null && array2 instanceof Array && (array2.length == 0 || array2[0] == null || (typeof array2[0] === 'number'))) || array2 === null)) {
                    return java.util.Arrays.equals$byte_A$byte_A(array1, array2);
                }
                else if (((array1 != null && array1 instanceof Array && (array1.length == 0 || array1[0] == null || (typeof array1[0] === 'string'))) || array1 === null) && ((array2 != null && array2 instanceof Array && (array2.length == 0 || array2[0] == null || (typeof array2[0] === 'string'))) || array2 === null)) {
                    return java.util.Arrays.equals$char_A$char_A(array1, array2);
                }
                else if (((array1 != null && array1 instanceof Array && (array1.length == 0 || array1[0] == null || (typeof array1[0] === 'number'))) || array1 === null) && ((array2 != null && array2 instanceof Array && (array2.length == 0 || array2[0] == null || (typeof array2[0] === 'number'))) || array2 === null)) {
                    return java.util.Arrays.equals$double_A$double_A(array1, array2);
                }
                else if (((array1 != null && array1 instanceof Array && (array1.length == 0 || array1[0] == null || (typeof array1[0] === 'number'))) || array1 === null) && ((array2 != null && array2 instanceof Array && (array2.length == 0 || array2[0] == null || (typeof array2[0] === 'number'))) || array2 === null)) {
                    return java.util.Arrays.equals$float_A$float_A(array1, array2);
                }
                else if (((array1 != null && array1 instanceof Array && (array1.length == 0 || array1[0] == null || (typeof array1[0] === 'number'))) || array1 === null) && ((array2 != null && array2 instanceof Array && (array2.length == 0 || array2[0] == null || (typeof array2[0] === 'number'))) || array2 === null)) {
                    return java.util.Arrays.equals$int_A$int_A(array1, array2);
                }
                else if (((array1 != null && array1 instanceof Array && (array1.length == 0 || array1[0] == null || (typeof array1[0] === 'number'))) || array1 === null) && ((array2 != null && array2 instanceof Array && (array2.length == 0 || array2[0] == null || (typeof array2[0] === 'number'))) || array2 === null)) {
                    return java.util.Arrays.equals$long_A$long_A(array1, array2);
                }
                else if (((array1 != null && array1 instanceof Array && (array1.length == 0 || array1[0] == null || (array1[0] != null))) || array1 === null) && ((array2 != null && array2 instanceof Array && (array2.length == 0 || array2[0] == null || (array2[0] != null))) || array2 === null)) {
                    return java.util.Arrays.equals$java_lang_Object_A$java_lang_Object_A(array1, array2);
                }
                else if (((array1 != null && array1 instanceof Array && (array1.length == 0 || array1[0] == null || (typeof array1[0] === 'number'))) || array1 === null) && ((array2 != null && array2 instanceof Array && (array2.length == 0 || array2[0] == null || (typeof array2[0] === 'number'))) || array2 === null)) {
                    return java.util.Arrays.equals$short_A$short_A(array1, array2);
                }
                else
                    throw new Error('invalid overload');
            }
            static equals$byte_A$byte_A(array1, array2) {
                if (array1 === array2) {
                    return true;
                }
                if (array1 == null || array2 == null) {
                    return false;
                }
                if (array1.length !== array2.length) {
                    return false;
                }
                for (let i = 0; i < array1.length; ++i) {
                    {
                        if (array1[i] !== array2[i]) {
                            return false;
                        }
                    }
                    ;
                }
                return true;
            }
            static equals$char_A$char_A(array1, array2) {
                if (array1 === array2) {
                    return true;
                }
                if (array1 == null || array2 == null) {
                    return false;
                }
                if (array1.length !== array2.length) {
                    return false;
                }
                for (let i = 0; i < array1.length; ++i) {
                    {
                        if ((c => c.charCodeAt == null ? c : c.charCodeAt(0))(array1[i]) != (c => c.charCodeAt == null ? c : c.charCodeAt(0))(array2[i])) {
                            return false;
                        }
                    }
                    ;
                }
                return true;
            }
            static equals$double_A$double_A(array1, array2) {
                if (array1 === array2) {
                    return true;
                }
                if (array1 == null || array2 == null) {
                    return false;
                }
                if (array1.length !== array2.length) {
                    return false;
                }
                for (let i = 0; i < array1.length; ++i) {
                    {
                        if (array1[i] !== array2[i]) {
                            return false;
                        }
                    }
                    ;
                }
                return true;
            }
            static equals$float_A$float_A(array1, array2) {
                if (array1 === array2) {
                    return true;
                }
                if (array1 == null || array2 == null) {
                    return false;
                }
                if (array1.length !== array2.length) {
                    return false;
                }
                for (let i = 0; i < array1.length; ++i) {
                    {
                        if (array1[i] !== array2[i]) {
                            return false;
                        }
                    }
                    ;
                }
                return true;
            }
            static equals$int_A$int_A(array1, array2) {
                if (array1 === array2) {
                    return true;
                }
                if (array1 == null || array2 == null) {
                    return false;
                }
                if (array1.length !== array2.length) {
                    return false;
                }
                for (let i = 0; i < array1.length; ++i) {
                    {
                        if (array1[i] !== array2[i]) {
                            return false;
                        }
                    }
                    ;
                }
                return true;
            }
            static equals$long_A$long_A(array1, array2) {
                if (array1 === array2) {
                    return true;
                }
                if (array1 == null || array2 == null) {
                    return false;
                }
                if (array1.length !== array2.length) {
                    return false;
                }
                for (let i = 0; i < array1.length; ++i) {
                    {
                        if (array1[i] !== array2[i]) {
                            return false;
                        }
                    }
                    ;
                }
                return true;
            }
            static equals$java_lang_Object_A$java_lang_Object_A(array1, array2) {
                if (array1 === array2) {
                    return true;
                }
                if (array1 == null || array2 == null) {
                    return false;
                }
                if (array1.length !== array2.length) {
                    return false;
                }
                for (let i = 0; i < array1.length; ++i) {
                    {
                        let val1 = array1[i];
                        let val2 = array2[i];
                        if (!java.util.Objects.equals(val1, val2)) {
                            return false;
                        }
                    }
                    ;
                }
                return true;
            }
            static equals$short_A$short_A(array1, array2) {
                if (array1 === array2) {
                    return true;
                }
                if (array1 == null || array2 == null) {
                    return false;
                }
                if (array1.length !== array2.length) {
                    return false;
                }
                for (let i = 0; i < array1.length; ++i) {
                    {
                        if (array1[i] !== array2[i]) {
                            return false;
                        }
                    }
                    ;
                }
                return true;
            }
            static fill$boolean_A$boolean(a, val) {
                Arrays.fill$boolean_A$int$int$boolean(a, 0, a.length, val);
            }
            static fill$boolean_A$int$int$boolean(a, fromIndex, toIndex, val) {
                for (let i = fromIndex; i < toIndex; ++i) {
                    {
                        a[i] = val;
                    }
                    ;
                }
            }
            static fill(a, fromIndex, toIndex, val) {
                if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (typeof a[0] === 'boolean'))) || a === null) && ((typeof fromIndex === 'number') || fromIndex === null) && ((typeof toIndex === 'number') || toIndex === null) && ((typeof val === 'boolean') || val === null)) {
                    return java.util.Arrays.fill$boolean_A$int$int$boolean(a, fromIndex, toIndex, val);
                }
                else if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (typeof a[0] === 'number'))) || a === null) && ((typeof fromIndex === 'number') || fromIndex === null) && ((typeof toIndex === 'number') || toIndex === null) && ((typeof val === 'number') || val === null)) {
                    return java.util.Arrays.fill$byte_A$int$int$byte(a, fromIndex, toIndex, val);
                }
                else if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (typeof a[0] === 'string'))) || a === null) && ((typeof fromIndex === 'number') || fromIndex === null) && ((typeof toIndex === 'number') || toIndex === null) && ((typeof val === 'string') || val === null)) {
                    return java.util.Arrays.fill$char_A$int$int$char(a, fromIndex, toIndex, val);
                }
                else if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (typeof a[0] === 'number'))) || a === null) && ((typeof fromIndex === 'number') || fromIndex === null) && ((typeof toIndex === 'number') || toIndex === null) && ((typeof val === 'number') || val === null)) {
                    return java.util.Arrays.fill$short_A$int$int$short(a, fromIndex, toIndex, val);
                }
                else if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (typeof a[0] === 'number'))) || a === null) && ((typeof fromIndex === 'number') || fromIndex === null) && ((typeof toIndex === 'number') || toIndex === null) && ((typeof val === 'number') || val === null)) {
                    return java.util.Arrays.fill$int_A$int$int$int(a, fromIndex, toIndex, val);
                }
                else if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (typeof a[0] === 'number'))) || a === null) && ((typeof fromIndex === 'number') || fromIndex === null) && ((typeof toIndex === 'number') || toIndex === null) && ((typeof val === 'number') || val === null)) {
                    return java.util.Arrays.fill$long_A$int$int$long(a, fromIndex, toIndex, val);
                }
                else if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (typeof a[0] === 'number'))) || a === null) && ((typeof fromIndex === 'number') || fromIndex === null) && ((typeof toIndex === 'number') || toIndex === null) && ((typeof val === 'number') || val === null)) {
                    return java.util.Arrays.fill$float_A$int$int$float(a, fromIndex, toIndex, val);
                }
                else if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (typeof a[0] === 'number'))) || a === null) && ((typeof fromIndex === 'number') || fromIndex === null) && ((typeof toIndex === 'number') || toIndex === null) && ((typeof val === 'number') || val === null)) {
                    return java.util.Arrays.fill$double_A$int$int$double(a, fromIndex, toIndex, val);
                }
                else if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (a[0] != null))) || a === null) && ((typeof fromIndex === 'number') || fromIndex === null) && ((typeof toIndex === 'number') || toIndex === null) && ((val != null) || val === null)) {
                    return java.util.Arrays.fill$java_lang_Object_A$int$int$java_lang_Object(a, fromIndex, toIndex, val);
                }
                else if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (typeof a[0] === 'boolean'))) || a === null) && ((typeof fromIndex === 'boolean') || fromIndex === null) && toIndex === undefined && val === undefined) {
                    return java.util.Arrays.fill$boolean_A$boolean(a, fromIndex);
                }
                else if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (typeof a[0] === 'number'))) || a === null) && ((typeof fromIndex === 'number') || fromIndex === null) && toIndex === undefined && val === undefined) {
                    return java.util.Arrays.fill$byte_A$byte(a, fromIndex);
                }
                else if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (typeof a[0] === 'string'))) || a === null) && ((typeof fromIndex === 'string') || fromIndex === null) && toIndex === undefined && val === undefined) {
                    return java.util.Arrays.fill$char_A$char(a, fromIndex);
                }
                else if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (typeof a[0] === 'number'))) || a === null) && ((typeof fromIndex === 'number') || fromIndex === null) && toIndex === undefined && val === undefined) {
                    return java.util.Arrays.fill$short_A$short(a, fromIndex);
                }
                else if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (typeof a[0] === 'number'))) || a === null) && ((typeof fromIndex === 'number') || fromIndex === null) && toIndex === undefined && val === undefined) {
                    return java.util.Arrays.fill$int_A$int(a, fromIndex);
                }
                else if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (typeof a[0] === 'number'))) || a === null) && ((typeof fromIndex === 'number') || fromIndex === null) && toIndex === undefined && val === undefined) {
                    return java.util.Arrays.fill$long_A$long(a, fromIndex);
                }
                else if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (typeof a[0] === 'number'))) || a === null) && ((typeof fromIndex === 'number') || fromIndex === null) && toIndex === undefined && val === undefined) {
                    return java.util.Arrays.fill$float_A$float(a, fromIndex);
                }
                else if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (typeof a[0] === 'number'))) || a === null) && ((typeof fromIndex === 'number') || fromIndex === null) && toIndex === undefined && val === undefined) {
                    return java.util.Arrays.fill$double_A$double(a, fromIndex);
                }
                else if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (a[0] != null))) || a === null) && ((fromIndex != null) || fromIndex === null) && toIndex === undefined && val === undefined) {
                    return java.util.Arrays.fill$java_lang_Object_A$java_lang_Object(a, fromIndex);
                }
                else
                    throw new Error('invalid overload');
            }
            static fill$byte_A$byte(a, val) {
                Arrays.fill$byte_A$int$int$byte(a, 0, a.length, val);
            }
            static fill$byte_A$int$int$byte(a, fromIndex, toIndex, val) {
                for (let i = fromIndex; i < toIndex; ++i) {
                    {
                        a[i] = val;
                    }
                    ;
                }
            }
            static fill$char_A$char(a, val) {
                Arrays.fill$char_A$int$int$char(a, 0, a.length, val);
            }
            static fill$char_A$int$int$char(a, fromIndex, toIndex, val) {
                for (let i = fromIndex; i < toIndex; ++i) {
                    {
                        a[i] = val;
                    }
                    ;
                }
            }
            static fill$double_A$double(a, val) {
                Arrays.fill$double_A$int$int$double(a, 0, a.length, val);
            }
            static fill$double_A$int$int$double(a, fromIndex, toIndex, val) {
                for (let i = fromIndex; i < toIndex; ++i) {
                    {
                        a[i] = val;
                    }
                    ;
                }
            }
            static fill$float_A$float(a, val) {
                Arrays.fill$float_A$int$int$float(a, 0, a.length, val);
            }
            static fill$float_A$int$int$float(a, fromIndex, toIndex, val) {
                for (let i = fromIndex; i < toIndex; ++i) {
                    {
                        a[i] = val;
                    }
                    ;
                }
            }
            static fill$int_A$int(a, val) {
                Arrays.fill$int_A$int$int$int(a, 0, a.length, val);
            }
            static fill$int_A$int$int$int(a, fromIndex, toIndex, val) {
                for (let i = fromIndex; i < toIndex; ++i) {
                    {
                        a[i] = val;
                    }
                    ;
                }
            }
            static fill$long_A$int$int$long(a, fromIndex, toIndex, val) {
                for (let i = fromIndex; i < toIndex; ++i) {
                    {
                        a[i] = val;
                    }
                    ;
                }
            }
            static fill$long_A$long(a, val) {
                Arrays.fill$long_A$int$int$long(a, 0, a.length, val);
            }
            static fill$java_lang_Object_A$int$int$java_lang_Object(a, fromIndex, toIndex, val) {
                for (let i = fromIndex; i < toIndex; ++i) {
                    {
                        a[i] = val;
                    }
                    ;
                }
            }
            static fill$java_lang_Object_A$java_lang_Object(a, val) {
                Arrays.fill$java_lang_Object_A$int$int$java_lang_Object(a, 0, a.length, val);
            }
            static fill$short_A$int$int$short(a, fromIndex, toIndex, val) {
                for (let i = fromIndex; i < toIndex; ++i) {
                    {
                        a[i] = val;
                    }
                    ;
                }
            }
            static fill$short_A$short(a, val) {
                Arrays.fill$short_A$int$int$short(a, 0, a.length, val);
            }
            static hashCode$boolean_A(a) {
                if (a == null) {
                    return 0;
                }
                let hashCode = 1;
                for (let index144 = 0; index144 < a.length; index144++) {
                    let e = a[index144];
                    {
                        hashCode = 31 * hashCode + javaemul.internal.BooleanHelper.hashCode(e);
                        hashCode = javaemul.internal.Coercions.ensureInt(hashCode);
                    }
                }
                return hashCode;
            }
            static hashCode(a) {
                if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (typeof a[0] === 'boolean'))) || a === null)) {
                    return java.util.Arrays.hashCode$boolean_A(a);
                }
                else if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (typeof a[0] === 'number'))) || a === null)) {
                    return java.util.Arrays.hashCode$byte_A(a);
                }
                else if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (typeof a[0] === 'string'))) || a === null)) {
                    return java.util.Arrays.hashCode$char_A(a);
                }
                else if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (typeof a[0] === 'number'))) || a === null)) {
                    return java.util.Arrays.hashCode$double_A(a);
                }
                else if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (typeof a[0] === 'number'))) || a === null)) {
                    return java.util.Arrays.hashCode$float_A(a);
                }
                else if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (typeof a[0] === 'number'))) || a === null)) {
                    return java.util.Arrays.hashCode$int_A(a);
                }
                else if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (typeof a[0] === 'number'))) || a === null)) {
                    return java.util.Arrays.hashCode$long_A(a);
                }
                else if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (a[0] != null))) || a === null)) {
                    return java.util.Arrays.hashCode$java_lang_Object_A(a);
                }
                else if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (typeof a[0] === 'number'))) || a === null)) {
                    return java.util.Arrays.hashCode$short_A(a);
                }
                else
                    throw new Error('invalid overload');
            }
            static hashCode$byte_A(a) {
                if (a == null) {
                    return 0;
                }
                let hashCode = 1;
                for (let index145 = 0; index145 < a.length; index145++) {
                    let e = a[index145];
                    {
                        hashCode = 31 * hashCode + javaemul.internal.ByteHelper.hashCode(e);
                        hashCode = javaemul.internal.Coercions.ensureInt(hashCode);
                    }
                }
                return hashCode;
            }
            static hashCode$char_A(a) {
                if (a == null) {
                    return 0;
                }
                let hashCode = 1;
                for (let index146 = 0; index146 < a.length; index146++) {
                    let e = a[index146];
                    {
                        hashCode = 31 * hashCode + javaemul.internal.CharacterHelper.hashCode(e);
                        hashCode = javaemul.internal.Coercions.ensureInt(hashCode);
                    }
                }
                return hashCode;
            }
            static hashCode$double_A(a) {
                if (a == null) {
                    return 0;
                }
                let hashCode = 1;
                for (let index147 = 0; index147 < a.length; index147++) {
                    let e = a[index147];
                    {
                        hashCode = 31 * hashCode + javaemul.internal.DoubleHelper.hashCode(e);
                        hashCode = javaemul.internal.Coercions.ensureInt(hashCode);
                    }
                }
                return hashCode;
            }
            static hashCode$float_A(a) {
                if (a == null) {
                    return 0;
                }
                let hashCode = 1;
                for (let index148 = 0; index148 < a.length; index148++) {
                    let e = a[index148];
                    {
                        hashCode = 31 * hashCode + javaemul.internal.FloatHelper.hashCode(e);
                        hashCode = javaemul.internal.Coercions.ensureInt(hashCode);
                    }
                }
                return hashCode;
            }
            static hashCode$int_A(a) {
                if (a == null) {
                    return 0;
                }
                let hashCode = 1;
                for (let index149 = 0; index149 < a.length; index149++) {
                    let e = a[index149];
                    {
                        hashCode = 31 * hashCode + javaemul.internal.IntegerHelper.hashCode(e);
                        hashCode = javaemul.internal.Coercions.ensureInt(hashCode);
                    }
                }
                return hashCode;
            }
            static hashCode$long_A(a) {
                if (a == null) {
                    return 0;
                }
                let hashCode = 1;
                for (let index150 = 0; index150 < a.length; index150++) {
                    let e = a[index150];
                    {
                        hashCode = 31 * hashCode + javaemul.internal.LongHelper.hashCode(e);
                        hashCode = javaemul.internal.Coercions.ensureInt(hashCode);
                    }
                }
                return hashCode;
            }
            static hashCode$java_lang_Object_A(a) {
                if (a == null) {
                    return 0;
                }
                let hashCode = 1;
                for (let index151 = 0; index151 < a.length; index151++) {
                    let e = a[index151];
                    {
                        hashCode = 31 * hashCode + java.util.Objects.hashCode(e);
                        hashCode = javaemul.internal.Coercions.ensureInt(hashCode);
                    }
                }
                return hashCode;
            }
            static hashCode$short_A(a) {
                if (a == null) {
                    return 0;
                }
                let hashCode = 1;
                for (let index152 = 0; index152 < a.length; index152++) {
                    let e = a[index152];
                    {
                        hashCode = 31 * hashCode + javaemul.internal.ShortHelper.hashCode(e);
                        hashCode = javaemul.internal.Coercions.ensureInt(hashCode);
                    }
                }
                return hashCode;
            }
            static sort$byte_A(array) {
                Arrays.nativeNumberSort$java_lang_Object(array);
            }
            static sort$byte_A$int$int(array, fromIndex, toIndex) {
                javaemul.internal.InternalPreconditions.checkPositionIndexes(fromIndex, toIndex, array.length);
                Arrays.nativeNumberSort$java_lang_Object$int$int(array, fromIndex, toIndex);
            }
            static sort$char_A(array) {
                Arrays.nativeNumberSort$java_lang_Object(array);
            }
            static sort$char_A$int$int(array, fromIndex, toIndex) {
                javaemul.internal.InternalPreconditions.checkPositionIndexes(fromIndex, toIndex, array.length);
                Arrays.nativeNumberSort$java_lang_Object$int$int(array, fromIndex, toIndex);
            }
            static sort$double_A(array) {
                Arrays.nativeNumberSort$java_lang_Object(array);
            }
            static sort$double_A$int$int(array, fromIndex, toIndex) {
                javaemul.internal.InternalPreconditions.checkPositionIndexes(fromIndex, toIndex, array.length);
                Arrays.nativeNumberSort$java_lang_Object$int$int(array, fromIndex, toIndex);
            }
            static sort$float_A(array) {
                Arrays.nativeNumberSort$java_lang_Object(array);
            }
            static sort$float_A$int$int(array, fromIndex, toIndex) {
                javaemul.internal.InternalPreconditions.checkPositionIndexes(fromIndex, toIndex, array.length);
                Arrays.nativeNumberSort$java_lang_Object$int$int(array, fromIndex, toIndex);
            }
            static sort$int_A(array) {
                Arrays.nativeNumberSort$java_lang_Object(array);
            }
            static sort$int_A$int$int(array, fromIndex, toIndex) {
                javaemul.internal.InternalPreconditions.checkPositionIndexes(fromIndex, toIndex, array.length);
                Arrays.nativeNumberSort$java_lang_Object$int$int(array, fromIndex, toIndex);
            }
            static sort$long_A(array) {
                Arrays.nativeLongSort$java_lang_Object$java_lang_Object(array, javaemul.internal.LongCompareHolder.getLongComparator());
            }
            static sort$long_A$int$int(array, fromIndex, toIndex) {
                javaemul.internal.InternalPreconditions.checkPositionIndexes(fromIndex, toIndex, array.length);
                Arrays.nativeLongSort$java_lang_Object$int$int(array, fromIndex, toIndex);
            }
            static sort$java_lang_Object_A(array) {
                Arrays.mergeSort$java_lang_Object_A$int$int$java_util_Comparator(array, 0, array.length, java.util.Comparators.natural());
            }
            static sort$java_lang_Object_A$int$int(x, fromIndex, toIndex) {
                Arrays.mergeSort$java_lang_Object_A$int$int$java_util_Comparator(x, fromIndex, toIndex, java.util.Comparators.natural());
            }
            static sort$short_A(array) {
                Arrays.nativeNumberSort$java_lang_Object(array);
            }
            static sort$short_A$int$int(array, fromIndex, toIndex) {
                javaemul.internal.InternalPreconditions.checkPositionIndexes(fromIndex, toIndex, array.length);
                Arrays.nativeNumberSort$java_lang_Object$int$int(array, fromIndex, toIndex);
            }
            static sort$java_lang_Object_A$java_util_Comparator(x, c) {
                Arrays.mergeSort$java_lang_Object_A$int$int$java_util_Comparator(x, 0, x.length, c);
            }
            static sort$java_lang_Object_A$int$int$java_util_Comparator(x, fromIndex, toIndex, c) {
                javaemul.internal.InternalPreconditions.checkPositionIndexes(fromIndex, toIndex, x.length);
                Arrays.mergeSort$java_lang_Object_A$int$int$java_util_Comparator(x, fromIndex, toIndex, c);
            }
            static sort(x, fromIndex, toIndex, c) {
                if (((x != null && x instanceof Array && (x.length == 0 || x[0] == null || (x[0] != null))) || x === null) && ((typeof fromIndex === 'number') || fromIndex === null) && ((typeof toIndex === 'number') || toIndex === null) && ((c != null && (c["__interfaces"] != null && c["__interfaces"].indexOf("java.util.Comparator") >= 0 || c.constructor != null && c.constructor["__interfaces"] != null && c.constructor["__interfaces"].indexOf("java.util.Comparator") >= 0)) || c === null)) {
                    return java.util.Arrays.sort$java_lang_Object_A$int$int$java_util_Comparator(x, fromIndex, toIndex, c);
                }
                else if (((x != null && x instanceof Array && (x.length == 0 || x[0] == null || (typeof x[0] === 'number'))) || x === null) && ((typeof fromIndex === 'number') || fromIndex === null) && ((typeof toIndex === 'number') || toIndex === null) && c === undefined) {
                    return java.util.Arrays.sort$byte_A$int$int(x, fromIndex, toIndex);
                }
                else if (((x != null && x instanceof Array && (x.length == 0 || x[0] == null || (typeof x[0] === 'string'))) || x === null) && ((typeof fromIndex === 'number') || fromIndex === null) && ((typeof toIndex === 'number') || toIndex === null) && c === undefined) {
                    return java.util.Arrays.sort$char_A$int$int(x, fromIndex, toIndex);
                }
                else if (((x != null && x instanceof Array && (x.length == 0 || x[0] == null || (typeof x[0] === 'number'))) || x === null) && ((typeof fromIndex === 'number') || fromIndex === null) && ((typeof toIndex === 'number') || toIndex === null) && c === undefined) {
                    return java.util.Arrays.sort$double_A$int$int(x, fromIndex, toIndex);
                }
                else if (((x != null && x instanceof Array && (x.length == 0 || x[0] == null || (typeof x[0] === 'number'))) || x === null) && ((typeof fromIndex === 'number') || fromIndex === null) && ((typeof toIndex === 'number') || toIndex === null) && c === undefined) {
                    return java.util.Arrays.sort$float_A$int$int(x, fromIndex, toIndex);
                }
                else if (((x != null && x instanceof Array && (x.length == 0 || x[0] == null || (typeof x[0] === 'number'))) || x === null) && ((typeof fromIndex === 'number') || fromIndex === null) && ((typeof toIndex === 'number') || toIndex === null) && c === undefined) {
                    return java.util.Arrays.sort$int_A$int$int(x, fromIndex, toIndex);
                }
                else if (((x != null && x instanceof Array && (x.length == 0 || x[0] == null || (typeof x[0] === 'number'))) || x === null) && ((typeof fromIndex === 'number') || fromIndex === null) && ((typeof toIndex === 'number') || toIndex === null) && c === undefined) {
                    return java.util.Arrays.sort$long_A$int$int(x, fromIndex, toIndex);
                }
                else if (((x != null && x instanceof Array && (x.length == 0 || x[0] == null || (x[0] != null))) || x === null) && ((typeof fromIndex === 'number') || fromIndex === null) && ((typeof toIndex === 'number') || toIndex === null) && c === undefined) {
                    return java.util.Arrays.sort$java_lang_Object_A$int$int(x, fromIndex, toIndex);
                }
                else if (((x != null && x instanceof Array && (x.length == 0 || x[0] == null || (typeof x[0] === 'number'))) || x === null) && ((typeof fromIndex === 'number') || fromIndex === null) && ((typeof toIndex === 'number') || toIndex === null) && c === undefined) {
                    return java.util.Arrays.sort$short_A$int$int(x, fromIndex, toIndex);
                }
                else if (((x != null && x instanceof Array && (x.length == 0 || x[0] == null || (x[0] != null))) || x === null) && ((fromIndex != null && (fromIndex["__interfaces"] != null && fromIndex["__interfaces"].indexOf("java.util.Comparator") >= 0 || fromIndex.constructor != null && fromIndex.constructor["__interfaces"] != null && fromIndex.constructor["__interfaces"].indexOf("java.util.Comparator") >= 0)) || fromIndex === null) && toIndex === undefined && c === undefined) {
                    return java.util.Arrays.sort$java_lang_Object_A$java_util_Comparator(x, fromIndex);
                }
                else if (((x != null && x instanceof Array && (x.length == 0 || x[0] == null || (typeof x[0] === 'number'))) || x === null) && fromIndex === undefined && toIndex === undefined && c === undefined) {
                    return java.util.Arrays.sort$byte_A(x);
                }
                else if (((x != null && x instanceof Array && (x.length == 0 || x[0] == null || (typeof x[0] === 'string'))) || x === null) && fromIndex === undefined && toIndex === undefined && c === undefined) {
                    return java.util.Arrays.sort$char_A(x);
                }
                else if (((x != null && x instanceof Array && (x.length == 0 || x[0] == null || (typeof x[0] === 'number'))) || x === null) && fromIndex === undefined && toIndex === undefined && c === undefined) {
                    return java.util.Arrays.sort$double_A(x);
                }
                else if (((x != null && x instanceof Array && (x.length == 0 || x[0] == null || (typeof x[0] === 'number'))) || x === null) && fromIndex === undefined && toIndex === undefined && c === undefined) {
                    return java.util.Arrays.sort$float_A(x);
                }
                else if (((x != null && x instanceof Array && (x.length == 0 || x[0] == null || (typeof x[0] === 'number'))) || x === null) && fromIndex === undefined && toIndex === undefined && c === undefined) {
                    return java.util.Arrays.sort$int_A(x);
                }
                else if (((x != null && x instanceof Array && (x.length == 0 || x[0] == null || (typeof x[0] === 'number'))) || x === null) && fromIndex === undefined && toIndex === undefined && c === undefined) {
                    return java.util.Arrays.sort$long_A(x);
                }
                else if (((x != null && x instanceof Array && (x.length == 0 || x[0] == null || (x[0] != null))) || x === null) && fromIndex === undefined && toIndex === undefined && c === undefined) {
                    return java.util.Arrays.sort$java_lang_Object_A(x);
                }
                else if (((x != null && x instanceof Array && (x.length == 0 || x[0] == null || (typeof x[0] === 'number'))) || x === null) && fromIndex === undefined && toIndex === undefined && c === undefined) {
                    return java.util.Arrays.sort$short_A(x);
                }
                else
                    throw new Error('invalid overload');
            }
            static toString$boolean_A(a) {
                if (a == null) {
                    return "null";
                }
                let joiner = new java.util.StringJoiner(", ", "[", "]");
                for (let index153 = 0; index153 < a.length; index153++) {
                    let element = a[index153];
                    {
                        joiner.add(/* valueOf */ new String(element).toString());
                    }
                }
                return joiner.toString();
            }
            static toString(a) {
                if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (typeof a[0] === 'boolean'))) || a === null)) {
                    return java.util.Arrays.toString$boolean_A(a);
                }
                else if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (typeof a[0] === 'number'))) || a === null)) {
                    return java.util.Arrays.toString$byte_A(a);
                }
                else if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (typeof a[0] === 'string'))) || a === null)) {
                    return java.util.Arrays.toString$char_A(a);
                }
                else if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (typeof a[0] === 'number'))) || a === null)) {
                    return java.util.Arrays.toString$double_A(a);
                }
                else if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (typeof a[0] === 'number'))) || a === null)) {
                    return java.util.Arrays.toString$float_A(a);
                }
                else if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (typeof a[0] === 'number'))) || a === null)) {
                    return java.util.Arrays.toString$int_A(a);
                }
                else if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (typeof a[0] === 'number'))) || a === null)) {
                    return java.util.Arrays.toString$long_A(a);
                }
                else if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (a[0] != null))) || a === null)) {
                    return java.util.Arrays.toString$java_lang_Object_A(a);
                }
                else if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (typeof a[0] === 'number'))) || a === null)) {
                    return java.util.Arrays.toString$short_A(a);
                }
                else
                    throw new Error('invalid overload');
            }
            static toString$byte_A(a) {
                if (a == null) {
                    return "null";
                }
                let joiner = new java.util.StringJoiner(", ", "[", "]");
                for (let index154 = 0; index154 < a.length; index154++) {
                    let element = a[index154];
                    {
                        joiner.add(/* valueOf */ new String(element).toString());
                    }
                }
                return joiner.toString();
            }
            static toString$char_A(a) {
                if (a == null) {
                    return "null";
                }
                let joiner = new java.util.StringJoiner(", ", "[", "]");
                for (let index155 = 0; index155 < a.length; index155++) {
                    let element = a[index155];
                    {
                        joiner.add(/* valueOf */ new String(element).toString());
                    }
                }
                return joiner.toString();
            }
            static toString$double_A(a) {
                if (a == null) {
                    return "null";
                }
                let joiner = new java.util.StringJoiner(", ", "[", "]");
                for (let index156 = 0; index156 < a.length; index156++) {
                    let element = a[index156];
                    {
                        joiner.add(/* valueOf */ new String(element).toString());
                    }
                }
                return joiner.toString();
            }
            static toString$float_A(a) {
                if (a == null) {
                    return "null";
                }
                let joiner = new java.util.StringJoiner(", ", "[", "]");
                for (let index157 = 0; index157 < a.length; index157++) {
                    let element = a[index157];
                    {
                        joiner.add(/* valueOf */ new String(element).toString());
                    }
                }
                return joiner.toString();
            }
            static toString$int_A(a) {
                if (a == null) {
                    return "null";
                }
                let joiner = new java.util.StringJoiner(", ", "[", "]");
                for (let index158 = 0; index158 < a.length; index158++) {
                    let element = a[index158];
                    {
                        joiner.add(/* valueOf */ new String(element).toString());
                    }
                }
                return joiner.toString();
            }
            static toString$long_A(a) {
                if (a == null) {
                    return "null";
                }
                let joiner = new java.util.StringJoiner(", ", "[", "]");
                for (let index159 = 0; index159 < a.length; index159++) {
                    let element = a[index159];
                    {
                        joiner.add(/* valueOf */ new String(element).toString());
                    }
                }
                return joiner.toString();
            }
            static toString$java_lang_Object_A(x) {
                if (x == null) {
                    return "null";
                }
                return Arrays.asList.apply(null, x).toString();
            }
            static toString$short_A(a) {
                if (a == null) {
                    return "null";
                }
                let joiner = new java.util.StringJoiner(", ", "[", "]");
                for (let index160 = 0; index160 < a.length; index160++) {
                    let element = a[index160];
                    {
                        joiner.add(/* valueOf */ new String(element).toString());
                    }
                }
                return joiner.toString();
            }
            static deepToString$java_lang_Object_A$java_util_Set(a, arraysIveSeen) {
                if (a == null) {
                    return "null";
                }
                if (!arraysIveSeen.add(a)) {
                    return "[...]";
                }
                let joiner = new java.util.StringJoiner(", ", "[", "]");
                for (let index161 = 0; index161 < a.length; index161++) {
                    let obj = a[index161];
                    {
                        if (obj != null && obj.constructor.isArray()) {
                            if (obj != null && obj instanceof Array && (obj.length == 0 || obj[0] == null || obj[0] != null)) {
                                if (arraysIveSeen.contains(obj)) {
                                    joiner.add("[...]");
                                }
                                else {
                                    let objArray = obj;
                                    let tempSet = (new java.util.HashSet(arraysIveSeen));
                                    joiner.add(Arrays.deepToString$java_lang_Object_A$java_util_Set(objArray, tempSet));
                                }
                            }
                            else if (obj != null && obj instanceof Array && (obj.length == 0 || obj[0] == null || typeof obj[0] === 'boolean')) {
                                joiner.add(Arrays.toString$boolean_A(obj));
                            }
                            else if (obj != null && obj instanceof Array && (obj.length == 0 || obj[0] == null || typeof obj[0] === 'number')) {
                                joiner.add(Arrays.toString$byte_A(obj));
                            }
                            else if (obj != null && obj instanceof Array && (obj.length == 0 || obj[0] == null || typeof obj[0] === 'string')) {
                                joiner.add(Arrays.toString$char_A(obj));
                            }
                            else if (obj != null && obj instanceof Array && (obj.length == 0 || obj[0] == null || typeof obj[0] === 'number')) {
                                joiner.add(Arrays.toString$short_A(obj));
                            }
                            else if (obj != null && obj instanceof Array && (obj.length == 0 || obj[0] == null || typeof obj[0] === 'number')) {
                                joiner.add(Arrays.toString$int_A(obj));
                            }
                            else if (obj != null && obj instanceof Array && (obj.length == 0 || obj[0] == null || typeof obj[0] === 'number')) {
                                joiner.add(Arrays.toString$long_A(obj));
                            }
                            else if (obj != null && obj instanceof Array && (obj.length == 0 || obj[0] == null || typeof obj[0] === 'number')) {
                                joiner.add(Arrays.toString$float_A(obj));
                            }
                            else if (obj != null && obj instanceof Array && (obj.length == 0 || obj[0] == null || typeof obj[0] === 'number')) {
                                joiner.add(Arrays.toString$double_A(obj));
                            }
                            else {
                            }
                        }
                        else {
                            joiner.add(/* valueOf */ new String(obj).toString());
                        }
                    }
                }
                return joiner.toString();
            }
            /**
             * Recursive helper function for {@link Arrays#deepToString(Object[])}.
             * @param {Array} a
             * @param {*} arraysIveSeen
             * @return {string}
             * @private
             */
            static deepToString(a, arraysIveSeen) {
                if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (a[0] != null))) || a === null) && ((arraysIveSeen != null && (arraysIveSeen["__interfaces"] != null && arraysIveSeen["__interfaces"].indexOf("java.util.Set") >= 0 || arraysIveSeen.constructor != null && arraysIveSeen.constructor["__interfaces"] != null && arraysIveSeen.constructor["__interfaces"].indexOf("java.util.Set") >= 0)) || arraysIveSeen === null)) {
                    return java.util.Arrays.deepToString$java_lang_Object_A$java_util_Set(a, arraysIveSeen);
                }
                else if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (a[0] != null))) || a === null) && arraysIveSeen === undefined) {
                    return java.util.Arrays.deepToString$java_lang_Object_A(a);
                }
                else
                    throw new Error('invalid overload');
            }
            static getCopyLength(array, from, to) {
                javaemul.internal.InternalPreconditions.checkArgument(from <= to, "%s > %s", from, to);
                let len = javaemul.internal.ArrayHelper.getLength(array);
                to = Math.min(to, len);
                javaemul.internal.InternalPreconditions.checkCriticalPositionIndexes(from, to, len);
                return to - from;
            }
            /**
             * Sort a small subsection of an array by insertion sort.
             *
             * @param {Array} array array to sort
             * @param {number} low lower bound of range to sort
             * @param {number} high upper bound of range to sort
             * @param {*} comp comparator to use
             * @private
             */
            static insertionSort(array, low, high, comp) {
                for (let i = low + 1; i < high; ++i) {
                    {
                        for (let j = i; j > low && comp.compare(array[j - 1], array[j]) > 0; --j) {
                            {
                                let t = array[j];
                                array[j] = array[j - 1];
                                array[j - 1] = t;
                            }
                            ;
                        }
                    }
                    ;
                }
            }
            /**
             * Merge the two sorted subarrays (srcLow,srcMid] and (srcMid,srcHigh] into
             * dest.
             *
             * @param {Array} src source array for merge
             * @param {number} srcLow lower bound of bottom sorted half
             * @param {number} srcMid upper bound of bottom sorted half & lower bound of top sorted
             * half
             * @param {number} srcHigh upper bound of top sorted half
             * @param {Array} dest destination array for merge
             * @param {number} destLow lower bound of destination
             * @param {number} destHigh upper bound of destination
             * @param {*} comp comparator to use
             * @private
             */
            static merge(src, srcLow, srcMid, srcHigh, dest, destLow, destHigh, comp) {
                let topIdx = srcMid;
                while ((destLow < destHigh)) {
                    {
                        if (topIdx >= srcHigh || (srcLow < srcMid && comp.compare(src[srcLow], src[topIdx]) <= 0)) {
                            dest[destLow++] = src[srcLow++];
                        }
                        else {
                            dest[destLow++] = src[topIdx++];
                        }
                    }
                }
                ;
            }
            static mergeSort$java_lang_Object_A$int$int$java_util_Comparator(x, fromIndex, toIndex, comp) {
                if (comp == null) {
                    comp = java.util.Comparators.natural();
                }
                let temp = Arrays.copyOfRange$java_lang_Object_A$int$int(x, fromIndex, toIndex);
                Arrays.mergeSort$java_lang_Object_A$java_lang_Object_A$int$int$int$java_util_Comparator(temp, x, fromIndex, toIndex, -fromIndex, comp);
            }
            static mergeSort$java_lang_Object_A$java_lang_Object_A$int$int$int$java_util_Comparator(temp, array, low, high, ofs, comp) {
                let length = high - low;
                if (length < 7) {
                    Arrays.insertionSort(array, low, high, comp);
                    return;
                }
                let tempLow = low + ofs;
                let tempHigh = high + ofs;
                let tempMid = tempLow + ((tempHigh - tempLow) >> 1);
                Arrays.mergeSort$java_lang_Object_A$java_lang_Object_A$int$int$int$java_util_Comparator(array, temp, tempLow, tempMid, -ofs, comp);
                Arrays.mergeSort$java_lang_Object_A$java_lang_Object_A$int$int$int$java_util_Comparator(array, temp, tempMid, tempHigh, -ofs, comp);
                if (comp.compare(temp[tempMid - 1], temp[tempMid]) <= 0) {
                    while ((low < high)) {
                        {
                            array[low++] = temp[tempLow++];
                        }
                    }
                    ;
                    return;
                }
                Arrays.merge(temp, tempLow, tempMid, tempHigh, array, low, high, comp);
            }
            /**
             * Recursive helper function for
             * {@link Arrays#mergeSort(Object[], int, int, Comparator)}.
             *
             * @param {Array} temp temporary space, as large as the range of elements being
             * sorted. On entry, temp should contain a copy of the sort range
             * from array.
             * @param {Array} array array to sort
             * @param {number} low lower bound of range to sort
             * @param {number} high upper bound of range to sort
             * @param {number} ofs offset to convert an array index into a temp index
             * @param {*} comp comparison function
             * @private
             */
            static mergeSort(temp, array, low, high, ofs, comp) {
                if (((temp != null && temp instanceof Array && (temp.length == 0 || temp[0] == null || (temp[0] != null))) || temp === null) && ((array != null && array instanceof Array && (array.length == 0 || array[0] == null || (array[0] != null))) || array === null) && ((typeof low === 'number') || low === null) && ((typeof high === 'number') || high === null) && ((typeof ofs === 'number') || ofs === null) && ((comp != null && (comp["__interfaces"] != null && comp["__interfaces"].indexOf("java.util.Comparator") >= 0 || comp.constructor != null && comp.constructor["__interfaces"] != null && comp.constructor["__interfaces"].indexOf("java.util.Comparator") >= 0)) || comp === null)) {
                    return java.util.Arrays.mergeSort$java_lang_Object_A$java_lang_Object_A$int$int$int$java_util_Comparator(temp, array, low, high, ofs, comp);
                }
                else if (((temp != null && temp instanceof Array && (temp.length == 0 || temp[0] == null || (temp[0] != null))) || temp === null) && ((typeof array === 'number') || array === null) && ((typeof low === 'number') || low === null) && ((high != null && (high["__interfaces"] != null && high["__interfaces"].indexOf("java.util.Comparator") >= 0 || high.constructor != null && high.constructor["__interfaces"] != null && high.constructor["__interfaces"].indexOf("java.util.Comparator") >= 0)) || high === null) && ofs === undefined && comp === undefined) {
                    return java.util.Arrays.mergeSort$java_lang_Object_A$int$int$java_util_Comparator(temp, array, low, high);
                }
                else
                    throw new Error('invalid overload');
            }
            static nativeLongSort$java_lang_Object$java_lang_Object(array, compareFunction) {
                array.sort(compareFunction);
            }
            static nativeLongSort$java_lang_Object$int$int(array, fromIndex, toIndex) {
                let temp = javaemul.internal.ArrayHelper.unsafeClone(array, fromIndex, toIndex);
                Arrays.nativeLongSort$java_lang_Object$java_lang_Object(temp, javaemul.internal.LongCompareHolder.getLongComparator());
                javaemul.internal.ArrayHelper.copy$java_lang_Object$int$java_lang_Object$int$int(temp, 0, array, fromIndex, toIndex - fromIndex);
            }
            /**
             * Sort a subset of an array of number primitives.
             * @param {*} array
             * @param {number} fromIndex
             * @param {number} toIndex
             * @private
             */
            static nativeLongSort(array, fromIndex, toIndex) {
                if (((array != null) || array === null) && ((typeof fromIndex === 'number') || fromIndex === null) && ((typeof toIndex === 'number') || toIndex === null)) {
                    return java.util.Arrays.nativeLongSort$java_lang_Object$int$int(array, fromIndex, toIndex);
                }
                else if (((array != null) || array === null) && ((fromIndex != null) || fromIndex === null) && toIndex === undefined) {
                    return java.util.Arrays.nativeLongSort$java_lang_Object$java_lang_Object(array, fromIndex);
                }
                else
                    throw new Error('invalid overload');
            }
            static nativeNumberSort$java_lang_Object(array) {
                array.sort(function (a, b) { return a - b; });
            }
            static nativeNumberSort$java_lang_Object$int$int(array, fromIndex, toIndex) {
                let temp = javaemul.internal.ArrayHelper.unsafeClone(array, fromIndex, toIndex);
                Arrays.nativeNumberSort$java_lang_Object(temp);
                javaemul.internal.ArrayHelper.copy$java_lang_Object$int$java_lang_Object$int$int(temp, 0, array, fromIndex, toIndex - fromIndex);
            }
            /**
             * Sort a subset of an array of number primitives.
             * @param {*} array
             * @param {number} fromIndex
             * @param {number} toIndex
             * @private
             */
            static nativeNumberSort(array, fromIndex, toIndex) {
                if (((array != null) || array === null) && ((typeof fromIndex === 'number') || fromIndex === null) && ((typeof toIndex === 'number') || toIndex === null)) {
                    return java.util.Arrays.nativeNumberSort$java_lang_Object$int$int(array, fromIndex, toIndex);
                }
                else if (((array != null) || array === null) && fromIndex === undefined && toIndex === undefined) {
                    return java.util.Arrays.nativeNumberSort$java_lang_Object(array);
                }
                else
                    throw new Error('invalid overload');
            }
        }
        util.Arrays = Arrays;
        Arrays["__class"] = "java.util.Arrays";
        (function (Arrays) {
            class ArrayList extends java.util.AbstractList {
                constructor(array) {
                    super();
                    if (this.array === undefined)
                        this.array = null;
                    this.array = array;
                }
                /**
                 *
                 * @param {*} o
                 * @return {boolean}
                 */
                contains(o) {
                    return (this.indexOf(o) !== -1);
                }
                /**
                 *
                 * @param {number} index
                 * @return {*}
                 */
                get(index) {
                    javaemul.internal.InternalPreconditions.checkElementIndex(index, this.size());
                    return this.array[index];
                }
                /**
                 *
                 * @param {number} index
                 * @param {*} value
                 * @return {*}
                 */
                set(index, value) {
                    let was = this.get(index);
                    this.array[index] = value;
                    return was;
                }
                /**
                 *
                 * @return {number}
                 */
                size() {
                    return this.array.length;
                }
                toArray$() {
                    return this.toArray$java_lang_Object_A((s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(this.array.length));
                }
                toArray$java_lang_Object_A(out) {
                    let size = this.size();
                    if (out.length < size) {
                        out = javaemul.internal.ArrayHelper.createFrom(out, size);
                    }
                    for (let i = 0; i < size; ++i) {
                        {
                            out[i] = (this.array[i]);
                        }
                        ;
                    }
                    if (out.length > size) {
                        out[size] = null;
                    }
                    return out;
                }
                /**
                 *
                 * @param {Array} out
                 * @return {Array}
                 */
                toArray(out) {
                    if (((out != null && out instanceof Array && (out.length == 0 || out[0] == null || (out[0] != null))) || out === null)) {
                        return this.toArray$java_lang_Object_A(out);
                    }
                    else if (out === undefined) {
                        return this.toArray$();
                    }
                    else
                        throw new Error('invalid overload');
                }
            }
            Arrays.ArrayList = ArrayList;
            ArrayList["__class"] = "java.util.Arrays.ArrayList";
            ArrayList["__interfaces"] = ["java.util.RandomAccess", "java.util.List", "java.util.Collection", "java.lang.Iterable", "java.io.Serializable"];
        })(Arrays = util.Arrays || (util.Arrays = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        /**
         * Capacity increment is ignored.
         * @param {number} initialCapacity
         * @param {number} ignoredCapacityIncrement
         * @class
         * @extends java.util.AbstractList
         */
        class Vector extends java.util.AbstractList {
            constructor(initialCapacity, ignoredCapacityIncrement) {
                if (((typeof initialCapacity === 'number') || initialCapacity === null) && ((typeof ignoredCapacityIncrement === 'number') || ignoredCapacityIncrement === null)) {
                    let __args = arguments;
                    {
                        let __args = arguments;
                        super();
                        if (this.arrayList === undefined)
                            this.arrayList = null;
                        if (this.exposeElement === undefined)
                            this.exposeElement = null;
                        if (this.arrayList === undefined)
                            this.arrayList = null;
                        if (this.exposeElement === undefined)
                            this.exposeElement = null;
                        (() => {
                            this.arrayList = (new java.util.ArrayList(initialCapacity));
                        })();
                    }
                }
                else if (((initialCapacity != null && (initialCapacity["__interfaces"] != null && initialCapacity["__interfaces"].indexOf("java.util.Collection") >= 0 || initialCapacity.constructor != null && initialCapacity.constructor["__interfaces"] != null && initialCapacity.constructor["__interfaces"].indexOf("java.util.Collection") >= 0)) || initialCapacity === null) && ignoredCapacityIncrement === undefined) {
                    let __args = arguments;
                    let c = __args[0];
                    super();
                    if (this.arrayList === undefined)
                        this.arrayList = null;
                    if (this.exposeElement === undefined)
                        this.exposeElement = null;
                    if (this.arrayList === undefined)
                        this.arrayList = null;
                    if (this.exposeElement === undefined)
                        this.exposeElement = null;
                    (() => {
                        this.arrayList = (new java.util.ArrayList());
                        this.addAll$java_util_Collection(c);
                    })();
                }
                else if (((typeof initialCapacity === 'number') || initialCapacity === null) && ignoredCapacityIncrement === undefined) {
                    let __args = arguments;
                    super();
                    if (this.arrayList === undefined)
                        this.arrayList = null;
                    if (this.exposeElement === undefined)
                        this.exposeElement = null;
                    if (this.arrayList === undefined)
                        this.arrayList = null;
                    if (this.exposeElement === undefined)
                        this.exposeElement = null;
                    (() => {
                        this.arrayList = (new java.util.ArrayList(initialCapacity));
                    })();
                }
                else if (initialCapacity === undefined && ignoredCapacityIncrement === undefined) {
                    let __args = arguments;
                    super();
                    if (this.arrayList === undefined)
                        this.arrayList = null;
                    if (this.exposeElement === undefined)
                        this.exposeElement = null;
                    if (this.arrayList === undefined)
                        this.arrayList = null;
                    if (this.exposeElement === undefined)
                        this.exposeElement = null;
                    (() => {
                        this.arrayList = (new java.util.ArrayList());
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            stream() {
                return (new javaemul.internal.stream.StreamHelper(this));
            }
            forEach(action) {
                javaemul.internal.InternalPreconditions.checkNotNull((action));
                for (let index162 = this.iterator(); index162.hasNext();) {
                    let t = index162.next();
                    {
                        (target => (typeof target === 'function') ? target(t) : target.accept(t))(action);
                    }
                }
            }
            removeIf(filter) {
                javaemul.internal.InternalPreconditions.checkNotNull((filter));
                let removed = false;
                for (let it = this.iterator(); it.hasNext();) {
                    {
                        if ((target => (typeof target === 'function') ? target(it.next()) : target.test(it.next()))(filter)) {
                            it.remove();
                            removed = true;
                        }
                    }
                    ;
                }
                return removed;
            }
            add$java_lang_Object(o) {
                return this.arrayList.add(o);
            }
            add$int$java_lang_Object(index, o) {
                Vector.checkArrayElementIndex(index, this.size() + 1);
                this.arrayList.add(index, o);
            }
            /**
             *
             * @param {number} index
             * @param {*} o
             */
            add(index, o) {
                if (((typeof index === 'number') || index === null) && ((o != null) || o === null)) {
                    return this.add$int$java_lang_Object(index, o);
                }
                else if (((index != null) || index === null) && o === undefined) {
                    return this.add$java_lang_Object(index);
                }
                else
                    throw new Error('invalid overload');
            }
            addAll$java_util_Collection(c) {
                return this.arrayList.addAll$java_util_Collection(c);
            }
            addAll$int$java_util_Collection(index, c) {
                return this.arrayList.addAll$int$java_util_Collection(index, c);
            }
            /**
             *
             * @param {number} index
             * @param {*} c
             * @return {boolean}
             */
            addAll(index, c) {
                if (((typeof index === 'number') || index === null) && ((c != null && (c["__interfaces"] != null && c["__interfaces"].indexOf("java.util.Collection") >= 0 || c.constructor != null && c.constructor["__interfaces"] != null && c.constructor["__interfaces"].indexOf("java.util.Collection") >= 0)) || c === null)) {
                    return this.addAll$int$java_util_Collection(index, c);
                }
                else if (((index != null && (index["__interfaces"] != null && index["__interfaces"].indexOf("java.util.Collection") >= 0 || index.constructor != null && index.constructor["__interfaces"] != null && index.constructor["__interfaces"].indexOf("java.util.Collection") >= 0)) || index === null) && c === undefined) {
                    return this.addAll$java_util_Collection(index);
                }
                else
                    throw new Error('invalid overload');
            }
            addElement(o) {
                this.add(o);
            }
            capacity() {
                return this.arrayList.size();
            }
            /**
             *
             */
            clear() {
                this.arrayList.clear();
            }
            clone() {
                return (new Vector(this));
            }
            /**
             *
             * @param {*} elem
             * @return {boolean}
             */
            contains(elem) {
                return this.arrayList.contains(elem);
            }
            /**
             *
             * @param {*} c
             * @return {boolean}
             */
            containsAll(c) {
                return this.arrayList.containsAll(c);
            }
            copyInto(objs) {
                let i = -1;
                let n = this.size();
                while ((++i < n)) {
                    {
                        objs[i] = this.get(i);
                    }
                }
                ;
            }
            elementAt(index) {
                return this.get(index);
            }
            elements() {
                return java.util.Collections.enumeration(this.arrayList);
            }
            ensureCapacity(capacity) {
                this.arrayList.ensureCapacity(capacity);
            }
            firstElement() {
                javaemul.internal.InternalPreconditions.checkElement(!this.isEmpty());
                return this.get(0);
            }
            /**
             *
             * @param {number} index
             * @return {*}
             */
            get(index) {
                Vector.checkArrayElementIndex(index, this.size());
                return this.arrayList.get(index);
            }
            indexOf$java_lang_Object(elem) {
                return this.arrayList.indexOf$java_lang_Object(elem);
            }
            indexOf$java_lang_Object$int(elem, index) {
                Vector.checkArrayIndexOutOfBounds(index >= 0, index);
                return this.arrayList.indexOf$java_lang_Object$int(elem, index);
            }
            indexOf(elem, index) {
                if (((elem != null) || elem === null) && ((typeof index === 'number') || index === null)) {
                    return this.indexOf$java_lang_Object$int(elem, index);
                }
                else if (((elem != null) || elem === null) && index === undefined) {
                    return this.indexOf$java_lang_Object(elem);
                }
                else
                    throw new Error('invalid overload');
            }
            insertElementAt(o, index) {
                this.add(index, o);
            }
            /**
             *
             * @return {boolean}
             */
            isEmpty() {
                return (this.arrayList.size() === 0);
            }
            /**
             *
             * @return {*}
             */
            iterator() {
                return this.arrayList.iterator();
            }
            lastElement() {
                javaemul.internal.InternalPreconditions.checkElement(!this.isEmpty());
                return this.get(this.size() - 1);
            }
            lastIndexOf$java_lang_Object(o) {
                return this.arrayList.lastIndexOf$java_lang_Object(o);
            }
            lastIndexOf$java_lang_Object$int(o, index) {
                Vector.checkArrayIndexOutOfBounds(index < this.size(), index);
                return this.arrayList.lastIndexOf$java_lang_Object$int(o, index);
            }
            lastIndexOf(o, index) {
                if (((o != null) || o === null) && ((typeof index === 'number') || index === null)) {
                    return this.lastIndexOf$java_lang_Object$int(o, index);
                }
                else if (((o != null) || o === null) && index === undefined) {
                    return this.lastIndexOf$java_lang_Object(o);
                }
                else
                    throw new Error('invalid overload');
            }
            remove$int(index) {
                Vector.checkArrayElementIndex(index, this.size());
                return this.arrayList.remove$int(index);
            }
            /**
             *
             * @param {number} index
             * @return {*}
             */
            remove(index) {
                if (((typeof index === 'number') || index === null)) {
                    return this.remove$int(index);
                }
                else if (((index != null) || index === null)) {
                    super.remove(index);
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             *
             * @param {*} c
             * @return {boolean}
             */
            removeAll(c) {
                return this.arrayList.removeAll(c);
            }
            removeAllElements() {
                this.clear();
            }
            removeElement(o) {
                return this.remove(o);
            }
            removeElementAt(index) {
                this.remove$int(index);
            }
            /**
             *
             * @param {number} index
             * @param {*} elem
             * @return {*}
             */
            set(index, elem) {
                Vector.checkArrayElementIndex(index, this.size());
                return this.arrayList.set(index, elem);
            }
            setElementAt(o, index) {
                this.set(index, o);
            }
            setSize(size) {
                Vector.checkArrayIndexOutOfBounds(size >= 0, size);
                this.arrayList.setSize(size);
            }
            /**
             *
             * @return {number}
             */
            size() {
                return this.arrayList.size();
            }
            /**
             *
             * @param {number} fromIndex
             * @param {number} toIndex
             * @return {*}
             */
            subList(fromIndex, toIndex) {
                return this.arrayList.subList(fromIndex, toIndex);
            }
            toArray$() {
                return this.arrayList.toArray();
            }
            toArray$java_lang_Object_A(a) {
                return this.arrayList.toArray$java_lang_Object_A(a);
            }
            /**
             *
             * @param {Array} a
             * @return {Array}
             */
            toArray(a) {
                if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (a[0] != null))) || a === null)) {
                    return this.toArray$java_lang_Object_A(a);
                }
                else if (a === undefined) {
                    return this.toArray$();
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             *
             * @return {string}
             */
            toString() {
                return this.arrayList.toString();
            }
            trimToSize() {
                this.arrayList.trimToSize();
            }
            /**
             *
             * @param {number} fromIndex
             * @param {number} endIndex
             */
            removeRange(fromIndex, endIndex) {
                this.arrayList.removeRange(fromIndex, endIndex);
            }
            /*private*/ static checkArrayElementIndex(index, size) {
                if (index < 0 || index >= size) {
                    throw new java.lang.ArrayIndexOutOfBoundsException();
                }
            }
            /*private*/ static checkArrayIndexOutOfBounds(expression, index) {
                if (!expression) {
                    throw new java.lang.ArrayIndexOutOfBoundsException(/* valueOf */ new String(index).toString());
                }
            }
        }
        util.Vector = Vector;
        Vector["__class"] = "java.util.Vector";
        Vector["__interfaces"] = ["java.util.RandomAccess", "java.util.List", "java.lang.Cloneable", "java.util.Collection", "java.lang.Iterable", "java.io.Serializable"];
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        /**
         * An unbounded priority queue based on a priority heap. <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/PriorityQueue.html">[Sun
         * docs]</a>
         *
         * @param <E> element type.
         * @param {number} initialCapacity
         * @param {*} cmp
         * @class
         * @extends java.util.AbstractQueue
         */
        class PriorityQueue extends java.util.AbstractQueue {
            constructor(initialCapacity, cmp) {
                if (((typeof initialCapacity === 'number') || initialCapacity === null) && ((cmp != null && (cmp["__interfaces"] != null && cmp["__interfaces"].indexOf("java.util.Comparator") >= 0 || cmp.constructor != null && cmp.constructor["__interfaces"] != null && cmp.constructor["__interfaces"].indexOf("java.util.Comparator") >= 0)) || cmp === null)) {
                    let __args = arguments;
                    super();
                    if (this.cmp === undefined)
                        this.cmp = null;
                    if (this.heap === undefined)
                        this.heap = null;
                    if (this.cmp === undefined)
                        this.cmp = null;
                    if (this.heap === undefined)
                        this.heap = null;
                    (() => {
                        this.heap = (new java.util.ArrayList(initialCapacity));
                        if (cmp == null) {
                            cmp = java.util.Comparators.natural();
                        }
                        this.cmp = cmp;
                    })();
                }
                else if (((initialCapacity != null && (initialCapacity["__interfaces"] != null && initialCapacity["__interfaces"].indexOf("java.util.Comparator") >= 0 || initialCapacity.constructor != null && initialCapacity.constructor["__interfaces"] != null && initialCapacity.constructor["__interfaces"].indexOf("java.util.Comparator") >= 0)) || initialCapacity === null) && cmp === undefined) {
                    let __args = arguments;
                    let cp = __args[0];
                    {
                        let __args = arguments;
                        let initialCapacity = PriorityQueue.INITIAL_CAPACITY;
                        let cmp = cp;
                        super();
                        if (this.cmp === undefined)
                            this.cmp = null;
                        if (this.heap === undefined)
                            this.heap = null;
                        if (this.cmp === undefined)
                            this.cmp = null;
                        if (this.heap === undefined)
                            this.heap = null;
                        (() => {
                            this.heap = (new java.util.ArrayList(initialCapacity));
                            if (cmp == null) {
                                cmp = java.util.Comparators.natural();
                            }
                            this.cmp = cmp;
                        })();
                    }
                }
                else if (((initialCapacity != null && initialCapacity instanceof java.util.PriorityQueue) || initialCapacity === null) && cmp === undefined) {
                    let __args = arguments;
                    let c = __args[0];
                    {
                        let __args = arguments;
                        let initialCapacity = c.size();
                        let cmp = c.comparator();
                        super();
                        if (this.cmp === undefined)
                            this.cmp = null;
                        if (this.heap === undefined)
                            this.heap = null;
                        if (this.cmp === undefined)
                            this.cmp = null;
                        if (this.heap === undefined)
                            this.heap = null;
                        (() => {
                            this.heap = (new java.util.ArrayList(initialCapacity));
                            if (cmp == null) {
                                cmp = java.util.Comparators.natural();
                            }
                            this.cmp = cmp;
                        })();
                    }
                    (() => {
                        this.addAll(c);
                    })();
                }
                else if (((initialCapacity != null && (initialCapacity["__interfaces"] != null && initialCapacity["__interfaces"].indexOf("java.util.SortedSet") >= 0 || initialCapacity.constructor != null && initialCapacity.constructor["__interfaces"] != null && initialCapacity.constructor["__interfaces"].indexOf("java.util.SortedSet") >= 0)) || initialCapacity === null) && cmp === undefined) {
                    let __args = arguments;
                    let c = __args[0];
                    {
                        let __args = arguments;
                        let initialCapacity = c.size();
                        let cmp = c.comparator();
                        super();
                        if (this.cmp === undefined)
                            this.cmp = null;
                        if (this.heap === undefined)
                            this.heap = null;
                        if (this.cmp === undefined)
                            this.cmp = null;
                        if (this.heap === undefined)
                            this.heap = null;
                        (() => {
                            this.heap = (new java.util.ArrayList(initialCapacity));
                            if (cmp == null) {
                                cmp = java.util.Comparators.natural();
                            }
                            this.cmp = cmp;
                        })();
                    }
                    (() => {
                        this.addAll(c);
                    })();
                }
                else if (((initialCapacity != null && (initialCapacity["__interfaces"] != null && initialCapacity["__interfaces"].indexOf("java.util.Collection") >= 0 || initialCapacity.constructor != null && initialCapacity.constructor["__interfaces"] != null && initialCapacity.constructor["__interfaces"].indexOf("java.util.Collection") >= 0)) || initialCapacity === null) && cmp === undefined) {
                    let __args = arguments;
                    let c = __args[0];
                    {
                        let __args = arguments;
                        let initialCapacity = c.size();
                        {
                            let __args = arguments;
                            let cmp = null;
                            super();
                            if (this.cmp === undefined)
                                this.cmp = null;
                            if (this.heap === undefined)
                                this.heap = null;
                            if (this.cmp === undefined)
                                this.cmp = null;
                            if (this.heap === undefined)
                                this.heap = null;
                            (() => {
                                this.heap = (new java.util.ArrayList(initialCapacity));
                                if (cmp == null) {
                                    cmp = java.util.Comparators.natural();
                                }
                                this.cmp = cmp;
                            })();
                        }
                    }
                    (() => {
                        this.addAll(c);
                    })();
                }
                else if (((typeof initialCapacity === 'number') || initialCapacity === null) && cmp === undefined) {
                    let __args = arguments;
                    {
                        let __args = arguments;
                        let cmp = null;
                        super();
                        if (this.cmp === undefined)
                            this.cmp = null;
                        if (this.heap === undefined)
                            this.heap = null;
                        if (this.cmp === undefined)
                            this.cmp = null;
                        if (this.heap === undefined)
                            this.heap = null;
                        (() => {
                            this.heap = (new java.util.ArrayList(initialCapacity));
                            if (cmp == null) {
                                cmp = java.util.Comparators.natural();
                            }
                            this.cmp = cmp;
                        })();
                    }
                }
                else if (initialCapacity === undefined && cmp === undefined) {
                    let __args = arguments;
                    {
                        let __args = arguments;
                        let initialCapacity = PriorityQueue.INITIAL_CAPACITY;
                        {
                            let __args = arguments;
                            let cmp = null;
                            super();
                            if (this.cmp === undefined)
                                this.cmp = null;
                            if (this.heap === undefined)
                                this.heap = null;
                            if (this.cmp === undefined)
                                this.cmp = null;
                            if (this.heap === undefined)
                                this.heap = null;
                            (() => {
                                this.heap = (new java.util.ArrayList(initialCapacity));
                                if (cmp == null) {
                                    cmp = java.util.Comparators.natural();
                                }
                                this.cmp = cmp;
                            })();
                        }
                    }
                }
                else
                    throw new Error('invalid overload');
            }
            /*private*/ static getLeftChild(node) {
                return 2 * node + 1;
            }
            /*private*/ static getParent(node) {
                return ((node - 1) / 2 | 0);
            }
            /*private*/ static getRightChild(node) {
                return 2 * node + 2;
            }
            /*private*/ static isLeaf(node, size) {
                return node * 2 + 1 >= size;
            }
            /**
             *
             * @param {*} c
             * @return {boolean}
             */
            addAll(c) {
                if (this.heap.addAll$java_util_Collection(c)) {
                    this.makeHeap(0);
                    return true;
                }
                return false;
            }
            /**
             *
             */
            clear() {
                this.heap.clear();
            }
            comparator() {
                return this.cmp === java.util.Comparators.natural() ? null : this.cmp;
            }
            /**
             *
             * @param {*} o
             * @return {boolean}
             */
            contains(o) {
                return this.heap.contains(o);
            }
            /**
             *
             * @param {*} c
             * @return {boolean}
             */
            containsAll(c) {
                return this.heap.containsAll(c);
            }
            /**
             *
             * @return {boolean}
             */
            isEmpty() {
                return this.heap.isEmpty();
            }
            /**
             *
             * @return {*}
             */
            iterator() {
                return java.util.Collections.unmodifiableList(this.heap).iterator();
            }
            /**
             *
             * @param {*} e
             * @return {boolean}
             */
            offer(e) {
                let node = this.heap.size();
                this.heap.add(e);
                while ((node > 0)) {
                    {
                        let childNode = node;
                        node = PriorityQueue.getParent(node);
                        if (this.cmp.compare(this.heap.get(node), e) <= 0) {
                            this.heap.set(childNode, e);
                            return true;
                        }
                        this.heap.set(childNode, this.heap.get(node));
                    }
                }
                ;
                this.heap.set(node, e);
                return true;
            }
            /**
             *
             * @return {*}
             */
            peek() {
                if (this.heap.size() === 0) {
                    return null;
                }
                return this.heap.get(0);
            }
            /**
             *
             * @return {*}
             */
            poll() {
                if (this.heap.size() === 0) {
                    return null;
                }
                let value = this.heap.get(0);
                this.removeAtIndex(0);
                return value;
            }
            remove$java_lang_Object(o) {
                let index = this.heap.indexOf$java_lang_Object(o);
                if (index < 0) {
                    return false;
                }
                this.removeAtIndex(index);
                return true;
            }
            /**
             *
             * @param {*} o
             * @return {boolean}
             */
            remove(o) {
                if (((o != null) || o === null)) {
                    return this.remove$java_lang_Object(o);
                }
                else if (o === undefined) {
                    return this.remove$();
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             *
             * @param {*} c
             * @return {boolean}
             */
            removeAll(c) {
                if (this.heap.removeAll(c)) {
                    this.makeHeap(0);
                    return true;
                }
                return false;
            }
            /**
             *
             * @param {*} c
             * @return {boolean}
             */
            retainAll(c) {
                if (this.heap.retainAll(c)) {
                    this.makeHeap(0);
                    return true;
                }
                return false;
            }
            /**
             *
             * @return {number}
             */
            size() {
                return this.heap.size();
            }
            toArray$() {
                return this.heap.toArray();
            }
            toArray$java_lang_Object_A(a) {
                return this.heap.toArray$java_lang_Object_A(a);
            }
            /**
             *
             * @param {Array} a
             * @return {Array}
             */
            toArray(a) {
                if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (a[0] != null))) || a === null)) {
                    return this.toArray$java_lang_Object_A(a);
                }
                else if (a === undefined) {
                    return this.toArray$();
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             *
             * @return {string}
             */
            toString() {
                return this.heap.toString();
            }
            /**
             * Make the subtree rooted at <code>node</code> a valid heap. O(n) time
             *
             * @param {number} node
             */
            makeHeap(node) {
                if (this.isLeaf(node)) {
                    return;
                }
                this.makeHeap(PriorityQueue.getLeftChild(node));
                let rightChild = PriorityQueue.getRightChild(node);
                if (rightChild < this.heap.size()) {
                    this.makeHeap(rightChild);
                }
                this.mergeHeaps(node);
            }
            /**
             * Merge two subheaps into a single heap. O(log n) time
             *
             * PRECONDITION: both children of <code>node</code> are heaps
             *
             * @param {number} node the parent of the two subtrees to merge
             */
            mergeHeaps(node) {
                let heapSize = this.heap.size();
                let value = this.heap.get(node);
                while ((!PriorityQueue.isLeaf(node, heapSize))) {
                    {
                        let smallestChild = this.getSmallestChild(node, heapSize);
                        if (this.cmp.compare(value, this.heap.get(smallestChild)) < 0) {
                            break;
                        }
                        this.heap.set(node, this.heap.get(smallestChild));
                        node = smallestChild;
                    }
                }
                ;
                this.heap.set(node, value);
            }
            /*private*/ getSmallestChild(node, heapSize) {
                let smallestChild;
                let leftChild = PriorityQueue.getLeftChild(node);
                let rightChild = leftChild + 1;
                smallestChild = leftChild;
                if ((rightChild < heapSize) && (this.cmp.compare(this.heap.get(rightChild), this.heap.get(leftChild)) < 0)) {
                    smallestChild = rightChild;
                }
                return smallestChild;
            }
            /*private*/ isLeaf(node) {
                return PriorityQueue.isLeaf(node, this.heap.size());
            }
            /*private*/ removeAtIndex(index) {
                let lastValue = this.heap.remove$int(this.heap.size() - 1);
                if (index < this.heap.size()) {
                    this.heap.set(index, lastValue);
                    this.mergeHeaps(index);
                }
            }
        }
        PriorityQueue.INITIAL_CAPACITY = 11;
        util.PriorityQueue = PriorityQueue;
        PriorityQueue["__class"] = "java.util.PriorityQueue";
        PriorityQueue["__interfaces"] = ["java.util.Collection", "java.util.Queue", "java.lang.Iterable"];
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        /**
         * Skeletal implementation of the Map interface.
         * <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/AbstractMap.html">
         * [Sun docs]</a>
         *
         * @param <K>
         * the key type.
         * @param <V>
         * the value type.
         * @class
         */
        class AbstractMap {
            constructor() {
            }
            merge(key, value, map) {
                let old = this.get(key);
                let next = (old == null) ? value : (target => (typeof target === 'function') ? target(old, value) : target.apply(old, value))(map);
                if (next == null) {
                    this.remove(key);
                }
                else {
                    this.put(key, next);
                }
                return next;
            }
            computeIfAbsent(key, mappingFunction) {
                let result;
                if ((result = this.get(key)) == null) {
                    result = (target => (typeof target === 'function') ? target(key) : target.apply(key))(mappingFunction);
                    if (result != null)
                        this.put(key, result);
                }
                return result;
            }
            /**
             *
             */
            clear() {
                this.entrySet().clear();
            }
            /**
             *
             * @param {*} key
             * @return {boolean}
             */
            containsKey(key) {
                return this.implFindEntry(key, false) != null;
            }
            /**
             *
             * @param {*} value
             * @return {boolean}
             */
            containsValue(value) {
                for (let index163 = this.entrySet().iterator(); index163.hasNext();) {
                    let entry = index163.next();
                    {
                        let v = entry.getValue();
                        if (java.util.Objects.equals(value, v)) {
                            return true;
                        }
                    }
                }
                return false;
            }
            containsEntry(entry) {
                let key = entry.getKey();
                let value = entry.getValue();
                let ourValue = this.get(key);
                if (!java.util.Objects.equals(value, ourValue)) {
                    return false;
                }
                if (ourValue == null && !this.containsKey(key)) {
                    return false;
                }
                return true;
            }
            /**
             *
             * @param {*} obj
             * @return {boolean}
             */
            equals(obj) {
                if (obj === this) {
                    return true;
                }
                if (!(obj != null && (obj["__interfaces"] != null && obj["__interfaces"].indexOf("java.util.Map") >= 0 || obj.constructor != null && obj.constructor["__interfaces"] != null && obj.constructor["__interfaces"].indexOf("java.util.Map") >= 0))) {
                    return false;
                }
                let otherMap = obj;
                if (this.size() !== otherMap.size()) {
                    return false;
                }
                for (let index164 = otherMap.entrySet().iterator(); index164.hasNext();) {
                    let entry = index164.next();
                    {
                        if (!this.containsEntry(entry)) {
                            return false;
                        }
                    }
                }
                return true;
            }
            /**
             *
             * @param {*} key
             * @return {*}
             */
            get(key) {
                return (AbstractMap.getEntryValueOrNull(this.implFindEntry(key, false)));
            }
            /**
             *
             * @return {number}
             */
            hashCode() {
                return java.util.Collections.hashCode$java_lang_Iterable(this.entrySet());
            }
            /**
             *
             * @return {boolean}
             */
            isEmpty() {
                return this.size() === 0;
            }
            /**
             *
             * @return {*}
             */
            keySet() {
                return new AbstractMap.AbstractMap$0(this);
            }
            /**
             *
             * @param {*} key
             * @param {*} value
             * @return {*}
             */
            put(key, value) {
                throw new java.lang.UnsupportedOperationException("Put not supported on this map");
            }
            /**
             *
             * @param {*} map
             */
            putAll(map) {
                javaemul.internal.InternalPreconditions.checkNotNull(map);
                for (let index165 = map.entrySet().iterator(); index165.hasNext();) {
                    let e = index165.next();
                    {
                        this.put(e.getKey(), e.getValue());
                    }
                }
            }
            /**
             *
             * @param {*} key
             * @return {*}
             */
            remove(key) {
                return (AbstractMap.getEntryValueOrNull(this.implFindEntry(key, true)));
            }
            /**
             *
             * @return {number}
             */
            size() {
                return this.entrySet().size();
            }
            toString$() {
                let joiner = new java.util.StringJoiner(", ", "{", "}");
                for (let index166 = this.entrySet().iterator(); index166.hasNext();) {
                    let entry = index166.next();
                    {
                        joiner.add(this.toString$java_util_Map_Entry(entry));
                    }
                }
                return joiner.toString();
            }
            toString$java_util_Map_Entry(entry) {
                return this.toString$java_lang_Object(entry.getKey()) + "=" + this.toString$java_lang_Object(entry.getValue());
            }
            toString(entry) {
                if (((entry != null && (entry["__interfaces"] != null && entry["__interfaces"].indexOf("java.util.Map.Entry") >= 0 || entry.constructor != null && entry.constructor["__interfaces"] != null && entry.constructor["__interfaces"].indexOf("java.util.Map.Entry") >= 0)) || entry === null)) {
                    return this.toString$java_util_Map_Entry(entry);
                }
                else if (((entry != null) || entry === null)) {
                    return this.toString$java_lang_Object(entry);
                }
                else if (entry === undefined) {
                    return this.toString$();
                }
                else
                    throw new Error('invalid overload');
            }
            toString$java_lang_Object(o) {
                return o === this ? "(this Map)" : new String(o).toString();
            }
            /**
             *
             * @return {*}
             */
            values() {
                return new AbstractMap.AbstractMap$1(this);
            }
            static getEntryKeyOrNull(entry) {
                return entry == null ? null : entry.getKey();
            }
            static getEntryValueOrNull(entry) {
                return entry == null ? null : entry.getValue();
            }
            implFindEntry(key, remove) {
                for (let iter = this.entrySet().iterator(); iter.hasNext();) {
                    {
                        let entry = iter.next();
                        let k = entry.getKey();
                        if (java.util.Objects.equals(key, k)) {
                            if (remove) {
                                entry = (new AbstractMap.SimpleEntry(entry.getKey(), entry.getValue()));
                                iter.remove();
                            }
                            return entry;
                        }
                    }
                    ;
                }
                return null;
            }
        }
        util.AbstractMap = AbstractMap;
        AbstractMap["__class"] = "java.util.AbstractMap";
        AbstractMap["__interfaces"] = ["java.util.Map"];
        (function (AbstractMap) {
            /**
             * Basic {@link Map.Entry} implementation used by {@link SimpleEntry} and
             * {@link SimpleImmutableEntry}.
             * @class
             */
            class AbstractEntry {
                constructor(key, value) {
                    if (this.key === undefined)
                        this.key = null;
                    if (this.value === undefined)
                        this.value = null;
                    this.key = key;
                    this.value = value;
                }
                /**
                 *
                 * @return {*}
                 */
                getKey() {
                    return this.key;
                }
                /**
                 *
                 * @return {*}
                 */
                getValue() {
                    return this.value;
                }
                /**
                 *
                 * @param {*} value
                 * @return {*}
                 */
                setValue(value) {
                    let oldValue = this.value;
                    this.value = value;
                    return oldValue;
                }
                /**
                 *
                 * @param {*} other
                 * @return {boolean}
                 */
                equals(other) {
                    if (!(other != null && (other["__interfaces"] != null && other["__interfaces"].indexOf("java.util.Map.Entry") >= 0 || other.constructor != null && other.constructor["__interfaces"] != null && other.constructor["__interfaces"].indexOf("java.util.Map.Entry") >= 0))) {
                        return false;
                    }
                    let entry = other;
                    return java.util.Objects.equals(this.key, entry.getKey()) && java.util.Objects.equals(this.value, entry.getValue());
                }
                /**
                 * Calculate the hash code using Sun's specified algorithm.
                 * @return {number}
                 */
                hashCode() {
                    return java.util.Objects.hashCode(this.key) ^ java.util.Objects.hashCode(this.value);
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    return this.key + "=" + this.value;
                }
            }
            AbstractMap.AbstractEntry = AbstractEntry;
            AbstractEntry["__class"] = "java.util.AbstractMap.AbstractEntry";
            AbstractEntry["__interfaces"] = ["java.util.Map.Entry"];
            /**
             * A mutable {@link Map.Entry} shared by several {@link Map}
             * implementations.
             * @param {*} key
             * @param {*} value
             * @class
             * @extends java.util.AbstractMap.AbstractEntry
             */
            class SimpleEntry extends AbstractMap.AbstractEntry {
                constructor(key, value) {
                    if (((key != null) || key === null) && ((value != null) || value === null)) {
                        let __args = arguments;
                        super(key, value);
                    }
                    else if (((key != null && (key["__interfaces"] != null && key["__interfaces"].indexOf("java.util.Map.Entry") >= 0 || key.constructor != null && key.constructor["__interfaces"] != null && key.constructor["__interfaces"].indexOf("java.util.Map.Entry") >= 0)) || key === null) && value === undefined) {
                        let __args = arguments;
                        let entry = __args[0];
                        super(entry.getKey(), entry.getValue());
                    }
                    else
                        throw new Error('invalid overload');
                }
            }
            AbstractMap.SimpleEntry = SimpleEntry;
            SimpleEntry["__class"] = "java.util.AbstractMap.SimpleEntry";
            SimpleEntry["__interfaces"] = ["java.util.Map.Entry"];
            /**
             * An immutable {@link Map.Entry} shared by several {@link Map}
             * implementations.
             * @param {*} key
             * @param {*} value
             * @class
             * @extends java.util.AbstractMap.AbstractEntry
             */
            class SimpleImmutableEntry extends AbstractMap.AbstractEntry {
                constructor(key, value) {
                    if (((key != null) || key === null) && ((value != null) || value === null)) {
                        let __args = arguments;
                        super(key, value);
                    }
                    else if (((key != null && (key["__interfaces"] != null && key["__interfaces"].indexOf("java.util.Map.Entry") >= 0 || key.constructor != null && key.constructor["__interfaces"] != null && key.constructor["__interfaces"].indexOf("java.util.Map.Entry") >= 0)) || key === null) && value === undefined) {
                        let __args = arguments;
                        let entry = __args[0];
                        super(entry.getKey(), entry.getValue());
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 *
                 * @param {*} value
                 * @return {*}
                 */
                setValue(value) {
                    throw new java.lang.UnsupportedOperationException();
                }
            }
            AbstractMap.SimpleImmutableEntry = SimpleImmutableEntry;
            SimpleImmutableEntry["__class"] = "java.util.AbstractMap.SimpleImmutableEntry";
            SimpleImmutableEntry["__interfaces"] = ["java.util.Map.Entry"];
            class AbstractMap$0 extends java.util.AbstractSet {
                constructor(__parent) {
                    super();
                    this.__parent = __parent;
                }
                /**
                 *
                 */
                clear() {
                    this.clear();
                }
                /**
                 *
                 * @param {*} key
                 * @return {boolean}
                 */
                contains(key) {
                    return this.__parent.containsKey(key);
                }
                /**
                 *
                 * @return {*}
                 */
                iterator() {
                    let outerIter = this.__parent.entrySet().iterator();
                    return new AbstractMap$0.AbstractMap$0$0(this, outerIter);
                }
                /**
                 *
                 * @param {*} key
                 * @return {boolean}
                 */
                remove(key) {
                    if (this.__parent.containsKey(key)) {
                        this.remove(key);
                        return true;
                    }
                    return false;
                }
                /**
                 *
                 * @return {number}
                 */
                size() {
                    return this.size();
                }
            }
            AbstractMap.AbstractMap$0 = AbstractMap$0;
            AbstractMap$0["__interfaces"] = ["java.util.Collection", "java.util.Set", "java.lang.Iterable"];
            (function (AbstractMap$0) {
                class AbstractMap$0$0 {
                    constructor(__parent, outerIter) {
                        this.outerIter = outerIter;
                        this.__parent = __parent;
                    }
                    forEachRemaining(consumer) {
                        javaemul.internal.InternalPreconditions.checkNotNull((consumer));
                        while ((this.hasNext())) {
                            {
                                (target => (typeof target === 'function') ? target(this.next()) : target.accept(this.next()))(consumer);
                            }
                        }
                        ;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    hasNext() {
                        return this.outerIter.hasNext();
                    }
                    /**
                     *
                     * @return {*}
                     */
                    next() {
                        let entry = this.outerIter.next();
                        return entry.getKey();
                    }
                    /**
                     *
                     */
                    remove() {
                        this.outerIter.remove();
                    }
                }
                AbstractMap$0.AbstractMap$0$0 = AbstractMap$0$0;
                AbstractMap$0$0["__interfaces"] = ["java.util.Iterator"];
            })(AbstractMap$0 = AbstractMap.AbstractMap$0 || (AbstractMap.AbstractMap$0 = {}));
            class AbstractMap$1 extends java.util.AbstractCollection {
                constructor(__parent) {
                    super();
                    this.__parent = __parent;
                }
                /**
                 *
                 */
                clear() {
                    this.clear();
                }
                /**
                 *
                 * @param {*} value
                 * @return {boolean}
                 */
                contains(value) {
                    return this.__parent.containsValue(value);
                }
                /**
                 *
                 * @return {*}
                 */
                iterator() {
                    let outerIter = this.__parent.entrySet().iterator();
                    return new AbstractMap$1.AbstractMap$1$0(this, outerIter);
                }
                /**
                 *
                 * @return {number}
                 */
                size() {
                    return this.size();
                }
            }
            AbstractMap.AbstractMap$1 = AbstractMap$1;
            AbstractMap$1["__interfaces"] = ["java.util.Collection", "java.lang.Iterable"];
            (function (AbstractMap$1) {
                class AbstractMap$1$0 {
                    constructor(__parent, outerIter) {
                        this.outerIter = outerIter;
                        this.__parent = __parent;
                    }
                    forEachRemaining(consumer) {
                        javaemul.internal.InternalPreconditions.checkNotNull((consumer));
                        while ((this.hasNext())) {
                            {
                                (target => (typeof target === 'function') ? target(this.next()) : target.accept(this.next()))(consumer);
                            }
                        }
                        ;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    hasNext() {
                        return this.outerIter.hasNext();
                    }
                    /**
                     *
                     * @return {*}
                     */
                    next() {
                        let entry = this.outerIter.next();
                        return entry.getValue();
                    }
                    /**
                     *
                     */
                    remove() {
                        this.outerIter.remove();
                    }
                }
                AbstractMap$1.AbstractMap$1$0 = AbstractMap$1$0;
                AbstractMap$1$0["__interfaces"] = ["java.util.Iterator"];
            })(AbstractMap$1 = AbstractMap.AbstractMap$1 || (AbstractMap.AbstractMap$1 = {}));
        })(AbstractMap = util.AbstractMap || (util.AbstractMap = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        /**
         * A {@link java.util.Set} of {@link Enum}s. <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/EnumSet.html">[Sun
         * docs]</a>
         *
         * @param <E> enumeration type
         * @extends java.util.AbstractSet
         * @class
         */
        class EnumSet extends java.util.AbstractSet {
            constructor() {
                super();
            }
            static allOf(elementType) {
                let all = elementType.getEnumConstants();
                let set = javaemul.internal.ArrayHelper.clone(all, 0, all.length);
                return (new EnumSet.EnumSetImpl(all, set, all.length));
            }
            static complementOf(other) {
                let s = other;
                let all = s.all;
                let oldSet = s.set;
                let newSet = javaemul.internal.ArrayHelper.createFrom(oldSet, oldSet.length);
                for (let i = 0, c = oldSet.length; i < c; ++i) {
                    {
                        if (oldSet[i] == null) {
                            newSet[i] = all[i];
                        }
                    }
                    ;
                }
                return (new EnumSet.EnumSetImpl(all, newSet, all.length - s.__size));
            }
            static copyOf$java_util_Collection(c) {
                if (c != null && c instanceof java.util.EnumSet) {
                    return EnumSet.copyOf$java_util_Collection(c);
                }
                javaemul.internal.InternalPreconditions.checkArgument(!c.isEmpty(), "Collection is empty");
                let iterator = c.iterator();
                let first = iterator.next();
                let set = EnumSet.of(first);
                while ((iterator.hasNext())) {
                    {
                        let e = iterator.next();
                        set.add(e);
                    }
                }
                ;
                return set;
            }
            static copyOf$java_util_EnumSet(s) {
                return ((o) => { if (o.clone != undefined) {
                    return o.clone();
                }
                else {
                    let clone = Object.create(o);
                    for (let p in o) {
                        if (o.hasOwnProperty(p))
                            clone[p] = o[p];
                    }
                    return clone;
                } })(s);
            }
            static copyOf(s) {
                if (((s != null && s instanceof java.util.EnumSet) || s === null)) {
                    return java.util.EnumSet.copyOf$java_util_EnumSet(s);
                }
                else if (((s != null && (s["__interfaces"] != null && s["__interfaces"].indexOf("java.util.Collection") >= 0 || s.constructor != null && s.constructor["__interfaces"] != null && s.constructor["__interfaces"].indexOf("java.util.Collection") >= 0)) || s === null)) {
                    return java.util.EnumSet.copyOf$java_util_Collection(s);
                }
                else
                    throw new Error('invalid overload');
            }
            static noneOf(elementType) {
                let all = elementType.getEnumConstants();
                return (new EnumSet.EnumSetImpl(all, javaemul.internal.ArrayHelper.createFrom(all, all.length), 0));
            }
            static of$java_lang_Enum(first) {
                let set = EnumSet.noneOf(first.getDeclaringClass());
                set.add(first);
                return set;
            }
            static of$java_lang_Enum$java_lang_Enum_A(first, ...rest) {
                let set = EnumSet.of(first);
                java.util.Collections.addAll(set, ...rest);
                return set;
            }
            static of(first, ...rest) {
                if (((first != null) || first === null) && ((rest != null && rest instanceof Array && (rest.length == 0 || rest[0] == null || (rest[0] != null))) || rest === null)) {
                    return java.util.EnumSet.of$java_lang_Enum$java_lang_Enum_A(first, rest);
                }
                else if (((first != null) || first === null) && rest === undefined) {
                    return java.util.EnumSet.of$java_lang_Enum(first);
                }
                else
                    throw new Error('invalid overload');
            }
            static range(from, to) {
                javaemul.internal.InternalPreconditions.checkArgument(from.compareTo(to) <= 0, "%s > %s", from, to);
                let all = from.getDeclaringClass().getEnumConstants();
                let set = javaemul.internal.ArrayHelper.createFrom(all, all.length);
                let start = from.ordinal();
                let end = to.ordinal() + 1;
                for (let i = start; i < end; ++i) {
                    {
                        set[i] = all[i];
                    }
                    ;
                }
                return (new EnumSet.EnumSetImpl(all, set, end - start));
            }
        }
        util.EnumSet = EnumSet;
        EnumSet["__class"] = "java.util.EnumSet";
        EnumSet["__interfaces"] = ["java.util.Collection", "java.util.Set", "java.lang.Iterable"];
        (function (EnumSet) {
            /**
             * Constructs a set taking ownership of the specified set. The size must
             * accurately reflect the number of non-null items in set.
             * @param {Array} all
             * @param {Array} set
             * @param {number} size
             * @class
             * @extends java.util.EnumSet
             */
            class EnumSetImpl extends java.util.EnumSet {
                constructor(all, set, size) {
                    super();
                    if (this.all === undefined)
                        this.all = null;
                    if (this.set === undefined)
                        this.set = null;
                    if (this.__size === undefined)
                        this.__size = 0;
                    this.all = all;
                    this.set = set;
                    this.__size = size;
                }
                add$java_lang_Enum(e) {
                    javaemul.internal.InternalPreconditions.checkNotNull(e);
                    let ordinal = e.ordinal();
                    if (this.set[ordinal] == null) {
                        this.set[ordinal] = e;
                        ++this.__size;
                        return true;
                    }
                    return false;
                }
                /**
                 *
                 * @param {java.lang.Enum} e
                 * @return {boolean}
                 */
                add(e) {
                    if (((e != null) || e === null)) {
                        return this.add$java_lang_Enum(e);
                    }
                    else if (((e != null) || e === null)) {
                        super.add(e);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 *
                 * @return {java.util.EnumSet}
                 */
                clone() {
                    let clonedSet = javaemul.internal.ArrayHelper.clone(this.set, 0, this.set.length);
                    return (new EnumSet.EnumSetImpl(this.all, clonedSet, this.__size));
                }
                /**
                 *
                 * @param {*} o
                 * @return {boolean}
                 */
                contains(o) {
                    return (o != null && o instanceof java.lang.Enum) && this.containsEnum(o);
                }
                containsEnum(e) {
                    return e != null && this.set[e.ordinal()] === e;
                }
                /**
                 *
                 * @return {*}
                 */
                iterator() {
                    return new EnumSetImpl.IteratorImpl(this);
                }
                /**
                 *
                 * @param {*} o
                 * @return {boolean}
                 */
                remove(o) {
                    return (o != null && o instanceof java.lang.Enum) && this.removeEnum(o);
                }
                removeEnum(e) {
                    if (e != null && this.set[e.ordinal()] === e) {
                        this.set[e.ordinal()] = null;
                        --this.__size;
                        return true;
                    }
                    return false;
                }
                /**
                 *
                 * @return {number}
                 */
                size() {
                    return this.__size;
                }
                /**
                 *
                 * @return {number}
                 */
                capacity() {
                    return this.all.length;
                }
            }
            EnumSet.EnumSetImpl = EnumSetImpl;
            EnumSetImpl["__class"] = "java.util.EnumSet.EnumSetImpl";
            EnumSetImpl["__interfaces"] = ["java.util.Collection", "java.util.Set", "java.lang.Iterable"];
            (function (EnumSetImpl) {
                class IteratorImpl {
                    constructor(__parent) {
                        this.__parent = __parent;
                        this.i = -1;
                        this.last = -1;
                        this.findNext();
                    }
                    forEachRemaining(consumer) {
                        javaemul.internal.InternalPreconditions.checkNotNull((consumer));
                        while ((this.hasNext())) {
                            {
                                (target => (typeof target === 'function') ? target(this.next()) : target.accept(this.next()))(consumer);
                            }
                        }
                        ;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    hasNext() {
                        return this.i < this.__parent.capacity();
                    }
                    /**
                     *
                     * @return {java.lang.Enum}
                     */
                    next() {
                        javaemul.internal.InternalPreconditions.checkElement(this.hasNext());
                        this.last = this.i;
                        this.findNext();
                        return this.__parent.set[this.last];
                    }
                    /**
                     *
                     */
                    remove() {
                        javaemul.internal.InternalPreconditions.checkState(this.last !== -1);
                        this.__parent.set[this.last] = null;
                        --this.__parent.__size;
                        this.last = -1;
                    }
                    findNext() {
                        ++this.i;
                        for (let c = this.__parent.capacity(); this.i < c; ++this.i) {
                            {
                                if (this.__parent.set[this.i] != null) {
                                    return;
                                }
                            }
                            ;
                        }
                    }
                }
                EnumSetImpl.IteratorImpl = IteratorImpl;
                IteratorImpl["__class"] = "java.util.EnumSet.EnumSetImpl.IteratorImpl";
                IteratorImpl["__interfaces"] = ["java.util.Iterator"];
            })(EnumSetImpl = EnumSet.EnumSetImpl || (EnumSet.EnumSetImpl = {}));
        })(EnumSet = util.EnumSet || (util.EnumSet = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        /**
         * Implements a set in terms of a hash table. <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/HashSet.html">[Sun
         * docs]</a>
         *
         * @param <E> element type.
         * @param {number} initialCapacity
         * @param {number} loadFactor
         * @class
         * @extends java.util.AbstractSet
         */
        class HashSet extends java.util.AbstractSet {
            constructor(initialCapacity, loadFactor) {
                if (((typeof initialCapacity === 'number') || initialCapacity === null) && ((typeof loadFactor === 'number') || loadFactor === null)) {
                    let __args = arguments;
                    super();
                    if (this.map === undefined)
                        this.map = null;
                    if (this.exposeElement === undefined)
                        this.exposeElement = null;
                    if (this.map === undefined)
                        this.map = null;
                    if (this.exposeElement === undefined)
                        this.exposeElement = null;
                    (() => {
                        this.map = (new java.util.HashMap(initialCapacity, loadFactor));
                    })();
                }
                else if (((initialCapacity != null && (initialCapacity["__interfaces"] != null && initialCapacity["__interfaces"].indexOf("java.util.Collection") >= 0 || initialCapacity.constructor != null && initialCapacity.constructor["__interfaces"] != null && initialCapacity.constructor["__interfaces"].indexOf("java.util.Collection") >= 0)) || initialCapacity === null) && loadFactor === undefined) {
                    let __args = arguments;
                    let c = __args[0];
                    super();
                    if (this.map === undefined)
                        this.map = null;
                    if (this.exposeElement === undefined)
                        this.exposeElement = null;
                    if (this.map === undefined)
                        this.map = null;
                    if (this.exposeElement === undefined)
                        this.exposeElement = null;
                    (() => {
                        this.map = (new java.util.HashMap(c.size()));
                        this.addAll(c);
                    })();
                }
                else if (((initialCapacity != null && initialCapacity instanceof java.util.HashMap) || initialCapacity === null) && loadFactor === undefined) {
                    let __args = arguments;
                    let map = __args[0];
                    super();
                    if (this.map === undefined)
                        this.map = null;
                    if (this.exposeElement === undefined)
                        this.exposeElement = null;
                    if (this.map === undefined)
                        this.map = null;
                    if (this.exposeElement === undefined)
                        this.exposeElement = null;
                    (() => {
                        this.map = map;
                    })();
                }
                else if (((typeof initialCapacity === 'number') || initialCapacity === null) && loadFactor === undefined) {
                    let __args = arguments;
                    super();
                    if (this.map === undefined)
                        this.map = null;
                    if (this.exposeElement === undefined)
                        this.exposeElement = null;
                    if (this.map === undefined)
                        this.map = null;
                    if (this.exposeElement === undefined)
                        this.exposeElement = null;
                    (() => {
                        this.map = (new java.util.HashMap(initialCapacity));
                    })();
                }
                else if (initialCapacity === undefined && loadFactor === undefined) {
                    let __args = arguments;
                    super();
                    if (this.map === undefined)
                        this.map = null;
                    if (this.exposeElement === undefined)
                        this.exposeElement = null;
                    if (this.map === undefined)
                        this.map = null;
                    if (this.exposeElement === undefined)
                        this.exposeElement = null;
                    (() => {
                        this.map = (new java.util.HashMap());
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            stream() {
                return (new javaemul.internal.stream.StreamHelper(this));
            }
            forEach(action) {
                javaemul.internal.InternalPreconditions.checkNotNull((action));
                for (let index167 = this.iterator(); index167.hasNext();) {
                    let t = index167.next();
                    {
                        (target => (typeof target === 'function') ? target(t) : target.accept(t))(action);
                    }
                }
            }
            removeIf(filter) {
                javaemul.internal.InternalPreconditions.checkNotNull((filter));
                let removed = false;
                for (let it = this.iterator(); it.hasNext();) {
                    {
                        if ((target => (typeof target === 'function') ? target(it.next()) : target.test(it.next()))(filter)) {
                            it.remove();
                            removed = true;
                        }
                    }
                    ;
                }
                return removed;
            }
            /**
             *
             * @param {*} o
             * @return {boolean}
             */
            add(o) {
                let old = this.map.put(o, this);
                return (old == null);
            }
            /**
             *
             */
            clear() {
                this.map.clear();
            }
            clone() {
                return (new HashSet(this));
            }
            /**
             *
             * @param {*} o
             * @return {boolean}
             */
            contains(o) {
                return this.map.containsKey(o);
            }
            /**
             *
             * @return {boolean}
             */
            isEmpty() {
                return this.map.isEmpty();
            }
            /**
             *
             * @return {*}
             */
            iterator() {
                return this.map.keySet().iterator();
            }
            /**
             *
             * @param {*} o
             * @return {boolean}
             */
            remove(o) {
                return (this.map.remove(o) != null);
            }
            /**
             *
             * @return {number}
             */
            size() {
                return this.map.size();
            }
            /**
             *
             * @return {string}
             */
            toString() {
                return this.map.keySet().toString();
            }
        }
        util.HashSet = HashSet;
        HashSet["__class"] = "java.util.HashSet";
        HashSet["__interfaces"] = ["java.lang.Cloneable", "java.util.Collection", "java.util.Set", "java.lang.Iterable", "java.io.Serializable"];
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        /**
         * Implements a set using a TreeMap. <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/TreeSet.html">[Sun
         * docs]</a>
         *
         * @param <E> element type.
         * @param {*} c
         * @class
         * @extends java.util.AbstractSet
         */
        class TreeSet extends java.util.AbstractSet {
            constructor(c) {
                if (((c != null && (c["__interfaces"] != null && c["__interfaces"].indexOf("java.util.Collection") >= 0 || c.constructor != null && c.constructor["__interfaces"] != null && c.constructor["__interfaces"].indexOf("java.util.Collection") >= 0)) || c === null)) {
                    let __args = arguments;
                    {
                        let __args = arguments;
                        super();
                        if (this.map === undefined)
                            this.map = null;
                        if (this.map === undefined)
                            this.map = null;
                        (() => {
                            this.map = (new java.util.TreeMap());
                        })();
                    }
                    (() => {
                        this.addAll(c);
                    })();
                }
                else if (((c != null && (c["__interfaces"] != null && c["__interfaces"].indexOf("java.util.Comparator") >= 0 || c.constructor != null && c.constructor["__interfaces"] != null && c.constructor["__interfaces"].indexOf("java.util.Comparator") >= 0)) || c === null)) {
                    let __args = arguments;
                    super();
                    if (this.map === undefined)
                        this.map = null;
                    if (this.map === undefined)
                        this.map = null;
                    (() => {
                        this.map = (new java.util.TreeMap(c));
                    })();
                }
                else if (((c != null && (c["__interfaces"] != null && c["__interfaces"].indexOf("java.util.SortedSet") >= 0 || c.constructor != null && c.constructor["__interfaces"] != null && c.constructor["__interfaces"].indexOf("java.util.SortedSet") >= 0)) || c === null)) {
                    let __args = arguments;
                    let s = __args[0];
                    {
                        let __args = arguments;
                        let c = javaemul.internal.InternalPreconditions.checkNotNull(s).comparator();
                        super();
                        if (this.map === undefined)
                            this.map = null;
                        if (this.map === undefined)
                            this.map = null;
                        (() => {
                            this.map = (new java.util.TreeMap(c));
                        })();
                    }
                    (() => {
                        this.addAll(s);
                    })();
                }
                else if (((c != null && (c["__interfaces"] != null && c["__interfaces"].indexOf("java.util.NavigableMap") >= 0 || c.constructor != null && c.constructor["__interfaces"] != null && c.constructor["__interfaces"].indexOf("java.util.NavigableMap") >= 0)) || c === null)) {
                    let __args = arguments;
                    let map = __args[0];
                    super();
                    if (this.map === undefined)
                        this.map = null;
                    if (this.map === undefined)
                        this.map = null;
                    (() => {
                        this.map = map;
                    })();
                }
                else if (c === undefined) {
                    let __args = arguments;
                    super();
                    if (this.map === undefined)
                        this.map = null;
                    if (this.map === undefined)
                        this.map = null;
                    (() => {
                        this.map = (new java.util.TreeMap());
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            stream() {
                return (new javaemul.internal.stream.StreamHelper(this));
            }
            forEach(action) {
                javaemul.internal.InternalPreconditions.checkNotNull((action));
                for (let index168 = this.iterator(); index168.hasNext();) {
                    let t = index168.next();
                    {
                        (target => (typeof target === 'function') ? target(t) : target.accept(t))(action);
                    }
                }
            }
            removeIf(filter) {
                javaemul.internal.InternalPreconditions.checkNotNull((filter));
                let removed = false;
                for (let it = this.iterator(); it.hasNext();) {
                    {
                        if ((target => (typeof target === 'function') ? target(it.next()) : target.test(it.next()))(filter)) {
                            it.remove();
                            removed = true;
                        }
                    }
                    ;
                }
                return removed;
            }
            /**
             *
             * @param {*} o
             * @return {boolean}
             */
            add(o) {
                return this.map.put(o, javaemul.internal.BooleanHelper.FALSE) == null;
            }
            /**
             *
             * @param {*} e
             * @return {*}
             */
            ceiling(e) {
                return this.map.ceilingKey(e);
            }
            /**
             *
             */
            clear() {
                this.map.clear();
            }
            /**
             *
             * @return {*}
             */
            comparator() {
                return this.map.comparator();
            }
            /**
             *
             * @param {*} o
             * @return {boolean}
             */
            contains(o) {
                return this.map.containsKey(o);
            }
            /**
             *
             * @return {*}
             */
            descendingIterator() {
                return this.descendingSet().iterator();
            }
            /**
             *
             * @return {*}
             */
            descendingSet() {
                return (new TreeSet(this.map.descendingMap()));
            }
            /**
             *
             * @return {*}
             */
            first() {
                return this.map.firstKey();
            }
            /**
             *
             * @param {*} e
             * @return {*}
             */
            floor(e) {
                return this.map.floorKey(e);
            }
            headSet$java_lang_Object(toElement) {
                return this.headSet(toElement, false);
            }
            headSet$java_lang_Object$boolean(toElement, inclusive) {
                return (new TreeSet(this.map.headMap(toElement, inclusive)));
            }
            /**
             *
             * @param {*} toElement
             * @param {boolean} inclusive
             * @return {*}
             */
            headSet(toElement, inclusive) {
                if (((toElement != null) || toElement === null) && ((typeof inclusive === 'boolean') || inclusive === null)) {
                    return this.headSet$java_lang_Object$boolean(toElement, inclusive);
                }
                else if (((toElement != null) || toElement === null) && inclusive === undefined) {
                    return this.headSet$java_lang_Object(toElement);
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             *
             * @param {*} e
             * @return {*}
             */
            higher(e) {
                return this.map.higherKey(e);
            }
            /**
             *
             * @return {*}
             */
            iterator() {
                return this.map.keySet().iterator();
            }
            /**
             *
             * @return {*}
             */
            last() {
                return this.map.lastKey();
            }
            /**
             *
             * @param {*} e
             * @return {*}
             */
            lower(e) {
                return this.map.lowerKey(e);
            }
            /**
             *
             * @return {*}
             */
            pollFirst() {
                return (java.util.AbstractMap.getEntryKeyOrNull(this.map.pollFirstEntry()));
            }
            /**
             *
             * @return {*}
             */
            pollLast() {
                return (java.util.AbstractMap.getEntryKeyOrNull(this.map.pollLastEntry()));
            }
            /**
             *
             * @param {*} o
             * @return {boolean}
             */
            remove(o) {
                return this.map.remove(o) != null;
            }
            /**
             *
             * @return {number}
             */
            size() {
                return this.map.size();
            }
            subSet$java_lang_Object$boolean$java_lang_Object$boolean(fromElement, fromInclusive, toElement, toInclusive) {
                return (new TreeSet(this.map.subMap(fromElement, fromInclusive, toElement, toInclusive)));
            }
            /**
             *
             * @param {*} fromElement
             * @param {boolean} fromInclusive
             * @param {*} toElement
             * @param {boolean} toInclusive
             * @return {*}
             */
            subSet(fromElement, fromInclusive, toElement, toInclusive) {
                if (((fromElement != null) || fromElement === null) && ((typeof fromInclusive === 'boolean') || fromInclusive === null) && ((toElement != null) || toElement === null) && ((typeof toInclusive === 'boolean') || toInclusive === null)) {
                    return this.subSet$java_lang_Object$boolean$java_lang_Object$boolean(fromElement, fromInclusive, toElement, toInclusive);
                }
                else if (((fromElement != null) || fromElement === null) && ((fromInclusive != null) || fromInclusive === null) && toElement === undefined && toInclusive === undefined) {
                    return this.subSet$java_lang_Object$java_lang_Object(fromElement, fromInclusive);
                }
                else
                    throw new Error('invalid overload');
            }
            subSet$java_lang_Object$java_lang_Object(fromElement, toElement) {
                return this.subSet(fromElement, true, toElement, false);
            }
            tailSet$java_lang_Object(fromElement) {
                return this.tailSet(fromElement, true);
            }
            tailSet$java_lang_Object$boolean(fromElement, inclusive) {
                return (new TreeSet(this.map.tailMap(fromElement, inclusive)));
            }
            /**
             *
             * @param {*} fromElement
             * @param {boolean} inclusive
             * @return {*}
             */
            tailSet(fromElement, inclusive) {
                if (((fromElement != null) || fromElement === null) && ((typeof inclusive === 'boolean') || inclusive === null)) {
                    return this.tailSet$java_lang_Object$boolean(fromElement, inclusive);
                }
                else if (((fromElement != null) || fromElement === null) && inclusive === undefined) {
                    return this.tailSet$java_lang_Object(fromElement);
                }
                else
                    throw new Error('invalid overload');
            }
        }
        util.TreeSet = TreeSet;
        TreeSet["__class"] = "java.util.TreeSet";
        TreeSet["__interfaces"] = ["java.util.SortedSet", "java.util.Collection", "java.util.Set", "java.util.NavigableSet", "java.lang.Iterable", "java.io.Serializable"];
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (javaemul) {
    var internal;
    (function (internal) {
        var stream;
        (function (stream) {
            class StreamRowSortingCollector extends javaemul.internal.stream.StreamRowCollector {
                constructor(collection, comparator) {
                    super(collection);
                    if (this.comparator === undefined)
                        this.comparator = null;
                    this.comparator = comparator;
                }
                /**
                 *
                 */
                end() {
                    java.util.Collections.sort$java_util_List$java_util_Comparator(this.collection, this.comparator);
                    super.end();
                }
            }
            stream.StreamRowSortingCollector = StreamRowSortingCollector;
            StreamRowSortingCollector["__class"] = "javaemul.internal.stream.StreamRowSortingCollector";
            StreamRowSortingCollector["__interfaces"] = ["javaemul.internal.stream.StreamRow"];
        })(stream = internal.stream || (internal.stream = {}));
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
(function (java) {
    var lang;
    (function (lang) {
        /**
         * See <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/NumberFormatException.html">the
         * official Java API doc</a> for details.
         * @param {string} message
         * @class
         * @extends java.lang.IllegalArgumentException
         */
        class NumberFormatException extends java.lang.IllegalArgumentException {
            constructor(message) {
                if (((typeof message === 'string') || message === null)) {
                    let __args = arguments;
                    super(message);
                    Object.setPrototypeOf(this, NumberFormatException.prototype);
                }
                else if (message === undefined) {
                    let __args = arguments;
                    super();
                    Object.setPrototypeOf(this, NumberFormatException.prototype);
                }
                else
                    throw new Error('invalid overload');
            }
            static forInputString(s) {
                return new java.lang.NumberFormatException("For input string: \"" + s + "\"");
            }
            static forNullInputString() {
                return new java.lang.NumberFormatException("null");
            }
            static forRadix(radix) {
                return new java.lang.NumberFormatException("radix " + radix + " out of range");
            }
        }
        lang.NumberFormatException = NumberFormatException;
        NumberFormatException["__class"] = "java.lang.NumberFormatException";
        NumberFormatException["__interfaces"] = ["java.io.Serializable"];
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
(function (java) {
    var nio;
    (function (nio) {
        var charset;
        (function (charset) {
            /**
             * GWT emulation of {@link IllegalCharsetNameException}.
             * @param {string} charsetName
             * @class
             * @extends java.lang.IllegalArgumentException
             */
            class IllegalCharsetNameException extends java.lang.IllegalArgumentException {
                constructor(charsetName) {
                    super(/* valueOf */ new String(charsetName).toString());
                    Object.setPrototypeOf(this, IllegalCharsetNameException.prototype);
                    if (this.charsetName === undefined)
                        this.charsetName = null;
                    this.charsetName = charsetName;
                }
                getCharsetName() {
                    return this.charsetName;
                }
            }
            charset.IllegalCharsetNameException = IllegalCharsetNameException;
            IllegalCharsetNameException["__class"] = "java.nio.charset.IllegalCharsetNameException";
            IllegalCharsetNameException["__interfaces"] = ["java.io.Serializable"];
        })(charset = nio.charset || (nio.charset = {}));
    })(nio = java.nio || (java.nio = {}));
})(java || (java = {}));
(function (java) {
    var nio;
    (function (nio) {
        var charset;
        (function (charset) {
            /**
             * GWT emulation of {@link UnsupportedCharsetException}.
             * @param {string} charsetName
             * @class
             * @extends java.lang.IllegalArgumentException
             */
            class UnsupportedCharsetException extends java.lang.IllegalArgumentException {
                constructor(charsetName) {
                    super(/* valueOf */ new String(charsetName).toString());
                    Object.setPrototypeOf(this, UnsupportedCharsetException.prototype);
                    if (this.charsetName === undefined)
                        this.charsetName = null;
                    this.charsetName = charsetName;
                }
                getCharsetName() {
                    return this.charsetName;
                }
            }
            charset.UnsupportedCharsetException = UnsupportedCharsetException;
            UnsupportedCharsetException["__class"] = "java.nio.charset.UnsupportedCharsetException";
            UnsupportedCharsetException["__interfaces"] = ["java.io.Serializable"];
        })(charset = nio.charset || (nio.charset = {}));
    })(nio = java.nio || (java.nio = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        var regex;
        (function (regex) {
            class PatternSyntaxException extends java.lang.IllegalArgumentException {
                constructor(desc, pattern, index) {
                    if (((typeof desc === 'string') || desc === null) && ((typeof pattern === 'string') || pattern === null) && ((typeof index === 'number') || index === null)) {
                        let __args = arguments;
                        {
                            let __args = arguments;
                            let throwable = PatternSyntaxException.createSyntaxError(desc, index);
                            super(throwable);
                            if (this.pattern === undefined)
                                this.pattern = null;
                            Object.setPrototypeOf(this, PatternSyntaxException.prototype);
                            if (this.pattern === undefined)
                                this.pattern = null;
                            (() => {
                                this.pattern = pattern;
                            })();
                        }
                    }
                    else if (((desc != null && desc instanceof Error) || desc === null) && ((typeof pattern === 'string') || pattern === null) && index === undefined) {
                        let __args = arguments;
                        let throwable = __args[0];
                        super(throwable);
                        if (this.pattern === undefined)
                            this.pattern = null;
                        Object.setPrototypeOf(this, PatternSyntaxException.prototype);
                        if (this.pattern === undefined)
                            this.pattern = null;
                        (() => {
                            this.pattern = pattern;
                        })();
                    }
                    else
                        throw new Error('invalid overload');
                }
                /*private*/ static createSyntaxError(desc, index) {
                    let syntaxError = new SyntaxError(desc);
                    (syntaxError)["columnNumber"] = index;
                    return syntaxError;
                }
                getIndex() {
                    return ((null)["columnNumber"]);
                }
                getDescription() {
                    return this.message;
                }
                getPattern() {
                    return this.pattern;
                }
                /**
                 *
                 * @return {string}
                 */
                getMessage() {
                    return this.getDescription() + " Pattern: " + this.pattern;
                }
            }
            regex.PatternSyntaxException = PatternSyntaxException;
            PatternSyntaxException["__class"] = "java.util.regex.PatternSyntaxException";
            PatternSyntaxException["__interfaces"] = ["java.io.Serializable"];
        })(regex = util.regex || (util.regex = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var nio;
    (function (nio) {
        class InvalidMarkException extends java.lang.IllegalStateException {
            constructor() {
                super();
                Object.setPrototypeOf(this, InvalidMarkException.prototype);
            }
        }
        nio.InvalidMarkException = InvalidMarkException;
        InvalidMarkException["__class"] = "java.nio.InvalidMarkException";
        InvalidMarkException["__interfaces"] = ["java.io.Serializable"];
    })(nio = java.nio || (java.nio = {}));
})(java || (java = {}));
(function (java) {
    var lang;
    (function (lang) {
        /**
         * NOTE: in GWT this will never be thrown for normal array accesses, only for
         * explicit throws.
         *
         * See <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/ArrayIndexOutOfBoundsException.html">the
         * official Java API doc</a> for details.
         * @param {number} index
         * @class
         * @extends java.lang.IndexOutOfBoundsException
         */
        class ArrayIndexOutOfBoundsException extends java.lang.IndexOutOfBoundsException {
            constructor(msg) {
                if (((typeof msg === 'string') || msg === null)) {
                    let __args = arguments;
                    super(msg);
                    Object.setPrototypeOf(this, ArrayIndexOutOfBoundsException.prototype);
                }
                else if (((typeof msg === 'number') || msg === null)) {
                    let __args = arguments;
                    let index = __args[0];
                    super("Array index " + index + " out of range");
                    Object.setPrototypeOf(this, ArrayIndexOutOfBoundsException.prototype);
                }
                else if (msg === undefined) {
                    let __args = arguments;
                    super();
                    Object.setPrototypeOf(this, ArrayIndexOutOfBoundsException.prototype);
                }
                else
                    throw new Error('invalid overload');
            }
        }
        lang.ArrayIndexOutOfBoundsException = ArrayIndexOutOfBoundsException;
        ArrayIndexOutOfBoundsException["__class"] = "java.lang.ArrayIndexOutOfBoundsException";
        ArrayIndexOutOfBoundsException["__interfaces"] = ["java.io.Serializable"];
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
(function (java) {
    var lang;
    (function (lang) {
        /**
         * See <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/StringIndexOfBoundsException.html">the
         * official Java API doc</a> for details.
         * @param {string} message
         * @class
         * @extends java.lang.IndexOutOfBoundsException
         */
        class StringIndexOutOfBoundsException extends java.lang.IndexOutOfBoundsException {
            constructor(message) {
                if (((typeof message === 'string') || message === null)) {
                    let __args = arguments;
                    super(message);
                    Object.setPrototypeOf(this, StringIndexOutOfBoundsException.prototype);
                }
                else if (((typeof message === 'number') || message === null)) {
                    let __args = arguments;
                    let index = __args[0];
                    super("String index out of range: " + index);
                    Object.setPrototypeOf(this, StringIndexOutOfBoundsException.prototype);
                }
                else if (message === undefined) {
                    let __args = arguments;
                    super();
                    Object.setPrototypeOf(this, StringIndexOutOfBoundsException.prototype);
                }
                else
                    throw new Error('invalid overload');
            }
        }
        lang.StringIndexOutOfBoundsException = StringIndexOutOfBoundsException;
        StringIndexOutOfBoundsException["__class"] = "java.lang.StringIndexOutOfBoundsException";
        StringIndexOutOfBoundsException["__interfaces"] = ["java.io.Serializable"];
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
(function (java) {
    var nio;
    (function (nio) {
        class ReadOnlyBufferException extends java.lang.UnsupportedOperationException {
            constructor() {
                super();
                Object.setPrototypeOf(this, ReadOnlyBufferException.prototype);
            }
        }
        nio.ReadOnlyBufferException = ReadOnlyBufferException;
        ReadOnlyBufferException["__class"] = "java.nio.ReadOnlyBufferException";
        ReadOnlyBufferException["__interfaces"] = ["java.io.Serializable"];
    })(nio = java.nio || (java.nio = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        class InputMismatchException extends java.util.NoSuchElementException {
            constructor(message) {
                if (((typeof message === 'string') || message === null)) {
                    let __args = arguments;
                    super(message);
                    Object.setPrototypeOf(this, InputMismatchException.prototype);
                }
                else if (message === undefined) {
                    let __args = arguments;
                    super();
                    Object.setPrototypeOf(this, InputMismatchException.prototype);
                }
                else
                    throw new Error('invalid overload');
            }
        }
        util.InputMismatchException = InputMismatchException;
        InputMismatchException["__class"] = "java.util.InputMismatchException";
        InputMismatchException["__interfaces"] = ["java.io.Serializable"];
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        /**
         * Linked list implementation.
         * <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/LinkedList.html">
         * [Sun docs]</a>
         *
         * @param <E>
         * element type.
         * @param {*} c
         * @class
         * @extends java.util.AbstractSequentialList
         */
        class LinkedList extends java.util.AbstractSequentialList {
            constructor(c) {
                if (((c != null && (c["__interfaces"] != null && c["__interfaces"].indexOf("java.util.Collection") >= 0 || c.constructor != null && c.constructor["__interfaces"] != null && c.constructor["__interfaces"].indexOf("java.util.Collection") >= 0)) || c === null)) {
                    let __args = arguments;
                    super();
                    if (this.exposeElement === undefined)
                        this.exposeElement = null;
                    if (this.header === undefined)
                        this.header = null;
                    if (this.tail === undefined)
                        this.tail = null;
                    if (this.__size === undefined)
                        this.__size = 0;
                    if (this.exposeElement === undefined)
                        this.exposeElement = null;
                    if (this.header === undefined)
                        this.header = null;
                    if (this.tail === undefined)
                        this.tail = null;
                    if (this.__size === undefined)
                        this.__size = 0;
                    (() => {
                        this.header = (new LinkedList.Node());
                        this.tail = (new LinkedList.Node());
                        this.reset();
                        this.addAll(c);
                    })();
                }
                else if (c === undefined) {
                    let __args = arguments;
                    super();
                    if (this.exposeElement === undefined)
                        this.exposeElement = null;
                    if (this.header === undefined)
                        this.header = null;
                    if (this.tail === undefined)
                        this.tail = null;
                    if (this.__size === undefined)
                        this.__size = 0;
                    if (this.exposeElement === undefined)
                        this.exposeElement = null;
                    if (this.header === undefined)
                        this.header = null;
                    if (this.tail === undefined)
                        this.tail = null;
                    if (this.__size === undefined)
                        this.__size = 0;
                    (() => {
                        this.header = (new LinkedList.Node());
                        this.tail = (new LinkedList.Node());
                        this.reset();
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            stream() {
                return (new javaemul.internal.stream.StreamHelper(this));
            }
            forEach(action) {
                javaemul.internal.InternalPreconditions.checkNotNull((action));
                for (let index169 = this.iterator(); index169.hasNext();) {
                    let t = index169.next();
                    {
                        (target => (typeof target === 'function') ? target(t) : target.accept(t))(action);
                    }
                }
            }
            removeIf(filter) {
                javaemul.internal.InternalPreconditions.checkNotNull((filter));
                let removed = false;
                for (let it = this.iterator(); it.hasNext();) {
                    {
                        if ((target => (typeof target === 'function') ? target(it.next()) : target.test(it.next()))(filter)) {
                            it.remove();
                            removed = true;
                        }
                    }
                    ;
                }
                return removed;
            }
            /**
             *
             * @param {number} index
             * @param {*} element
             */
            add(index, element) {
                if (((typeof index === 'number') || index === null) && ((element != null) || element === null)) {
                    super.add(index, element);
                }
                else if (((index != null) || index === null) && element === undefined) {
                    return this.add$java_lang_Object(index);
                }
                else
                    throw new Error('invalid overload');
            }
            add$java_lang_Object(o) {
                this.addLast(o);
                return true;
            }
            /**
             *
             * @param {*} o
             */
            addFirst(o) {
                this.addNode(o, this.header, this.header.next);
            }
            /**
             *
             * @param {*} o
             */
            addLast(o) {
                this.addNode(o, this.tail.prev, this.tail);
            }
            /**
             *
             */
            clear() {
                this.reset();
            }
            reset() {
                this.header.next = this.tail;
                this.tail.prev = this.header;
                this.header.prev = this.tail.next = null;
                this.__size = 0;
            }
            clone() {
                return (new LinkedList(this));
            }
            /**
             *
             * @return {*}
             */
            descendingIterator() {
                return new LinkedList.DescendingIteratorImpl(this);
            }
            /**
             *
             * @return {*}
             */
            element() {
                return this.getFirst();
            }
            /**
             *
             * @return {*}
             */
            getFirst() {
                javaemul.internal.InternalPreconditions.checkElement(this.__size !== 0);
                return this.header.next.value;
            }
            /**
             *
             * @return {*}
             */
            getLast() {
                javaemul.internal.InternalPreconditions.checkElement(this.__size !== 0);
                return this.tail.prev.value;
            }
            listIterator$int(index) {
                javaemul.internal.InternalPreconditions.checkPositionIndex(index, this.__size);
                let node;
                if (index >= this.__size >> 1) {
                    node = this.tail;
                    for (let i = this.__size; i > index; --i) {
                        {
                            node = node.prev;
                        }
                        ;
                    }
                }
                else {
                    node = this.header.next;
                    for (let i = 0; i < index; ++i) {
                        {
                            node = node.next;
                        }
                        ;
                    }
                }
                return new LinkedList.ListIteratorImpl2(this, index, node);
            }
            /**
             *
             * @param {number} index
             * @return {*}
             */
            listIterator(index) {
                if (((typeof index === 'number') || index === null)) {
                    return this.listIterator$int(index);
                }
                else if (index === undefined) {
                    return this.listIterator$();
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             *
             * @param {*} o
             * @return {boolean}
             */
            offer(o) {
                return this.offerLast(o);
            }
            /**
             *
             * @param {*} e
             * @return {boolean}
             */
            offerFirst(e) {
                this.addFirst(e);
                return true;
            }
            /**
             *
             * @param {*} e
             * @return {boolean}
             */
            offerLast(e) {
                this.addLast(e);
                return true;
            }
            /**
             *
             * @return {*}
             */
            peek() {
                return this.peekFirst();
            }
            /**
             *
             * @return {*}
             */
            peekFirst() {
                return this.__size === 0 ? null : this.getFirst();
            }
            /**
             *
             * @return {*}
             */
            peekLast() {
                return this.__size === 0 ? null : this.getLast();
            }
            /**
             *
             * @return {*}
             */
            poll() {
                return this.pollFirst();
            }
            /**
             *
             * @return {*}
             */
            pollFirst() {
                return this.__size === 0 ? null : this.removeFirst();
            }
            /**
             *
             * @return {*}
             */
            pollLast() {
                return this.__size === 0 ? null : this.removeLast();
            }
            /**
             *
             * @return {*}
             */
            pop() {
                return this.removeFirst();
            }
            /**
             *
             * @param {*} e
             */
            push(e) {
                this.addFirst(e);
            }
            /**
             *
             * @param {number} index
             * @return {*}
             */
            remove(index) {
                if (((typeof index === 'number') || index === null)) {
                    super.remove(index);
                }
                else if (((index != null) || index === null)) {
                    super.remove(index);
                }
                else if (index === undefined) {
                    return this.remove$();
                }
                else
                    throw new Error('invalid overload');
            }
            remove$() {
                return this.removeFirst();
            }
            /**
             *
             * @return {*}
             */
            removeFirst() {
                javaemul.internal.InternalPreconditions.checkElement(this.__size !== 0);
                return this.removeNode(this.header.next);
            }
            /**
             *
             * @param {*} o
             * @return {boolean}
             */
            removeFirstOccurrence(o) {
                return this.remove(o);
            }
            /**
             *
             * @return {*}
             */
            removeLast() {
                javaemul.internal.InternalPreconditions.checkElement(this.__size !== 0);
                return this.removeNode(this.tail.prev);
            }
            /**
             *
             * @param {*} o
             * @return {boolean}
             */
            removeLastOccurrence(o) {
                for (let e = this.tail.prev; e !== this.header; e = e.prev) {
                    {
                        if (java.util.Objects.equals(e.value, o)) {
                            this.removeNode(e);
                            return true;
                        }
                    }
                    ;
                }
                return false;
            }
            /**
             *
             * @return {number}
             */
            size() {
                return this.__size;
            }
            addNode(o, prev, next) {
                let node = (new LinkedList.Node());
                node.value = o;
                node.prev = prev;
                node.next = next;
                next.prev = prev.next = node;
                ++this.__size;
            }
            removeNode(node) {
                let oldValue = node.value;
                node.next.prev = node.prev;
                node.prev.next = node.next;
                node.next = node.prev = null;
                node.value = null;
                --this.__size;
                return oldValue;
            }
        }
        util.LinkedList = LinkedList;
        LinkedList["__class"] = "java.util.LinkedList";
        LinkedList["__interfaces"] = ["java.lang.Cloneable", "java.util.List", "java.util.Collection", "java.util.Queue", "java.util.Deque", "java.lang.Iterable", "java.io.Serializable"];
        (function (LinkedList) {
            class DescendingIteratorImpl {
                constructor(__parent) {
                    this.__parent = __parent;
                    this.itr = new LinkedList.ListIteratorImpl2(this.__parent, this.__parent.__size, this.__parent.tail);
                }
                forEachRemaining(consumer) {
                    javaemul.internal.InternalPreconditions.checkNotNull((consumer));
                    while ((this.hasNext())) {
                        {
                            (target => (typeof target === 'function') ? target(this.next()) : target.accept(this.next()))(consumer);
                        }
                    }
                    ;
                }
                /**
                 *
                 * @return {boolean}
                 */
                hasNext() {
                    return this.itr.hasPrevious();
                }
                /**
                 *
                 * @return {*}
                 */
                next() {
                    return this.itr.previous();
                }
                /**
                 *
                 */
                remove() {
                    this.itr.remove();
                }
            }
            LinkedList.DescendingIteratorImpl = DescendingIteratorImpl;
            DescendingIteratorImpl["__class"] = "java.util.LinkedList.DescendingIteratorImpl";
            DescendingIteratorImpl["__interfaces"] = ["java.util.Iterator"];
            /**
             * @param {number} index
             * from the beginning of the list (0 = first node)
             * @param {java.util.LinkedList.Node} startNode
             * the initial current node
             * @class
             */
            class ListIteratorImpl2 {
                constructor(__parent, index, startNode) {
                    this.__parent = __parent;
                    if (this.currentIndex === undefined)
                        this.currentIndex = 0;
                    if (this.currentNode === undefined)
                        this.currentNode = null;
                    this.lastNode = null;
                    this.currentNode = startNode;
                    this.currentIndex = index;
                }
                forEachRemaining(consumer) {
                    javaemul.internal.InternalPreconditions.checkNotNull((consumer));
                    while ((this.hasNext())) {
                        {
                            (target => (typeof target === 'function') ? target(this.next()) : target.accept(this.next()))(consumer);
                        }
                    }
                    ;
                }
                /**
                 *
                 * @param {*} o
                 */
                add(o) {
                    this.__parent.addNode(o, this.currentNode.prev, this.currentNode);
                    ++this.currentIndex;
                    this.lastNode = null;
                }
                /**
                 *
                 * @return {boolean}
                 */
                hasNext() {
                    return this.currentNode !== this.__parent.tail;
                }
                /**
                 *
                 * @return {boolean}
                 */
                hasPrevious() {
                    return this.currentNode.prev !== this.__parent.header;
                }
                /**
                 *
                 * @return {*}
                 */
                next() {
                    javaemul.internal.InternalPreconditions.checkElement(this.hasNext());
                    this.lastNode = this.currentNode;
                    this.currentNode = this.currentNode.next;
                    ++this.currentIndex;
                    return this.lastNode.value;
                }
                /**
                 *
                 * @return {number}
                 */
                nextIndex() {
                    return this.currentIndex;
                }
                /**
                 *
                 * @return {*}
                 */
                previous() {
                    javaemul.internal.InternalPreconditions.checkElement(this.hasPrevious());
                    this.lastNode = this.currentNode = this.currentNode.prev;
                    --this.currentIndex;
                    return this.lastNode.value;
                }
                /**
                 *
                 * @return {number}
                 */
                previousIndex() {
                    return this.currentIndex - 1;
                }
                /**
                 *
                 */
                remove() {
                    javaemul.internal.InternalPreconditions.checkState(this.lastNode != null);
                    let nextNode = this.lastNode.next;
                    this.__parent.removeNode(this.lastNode);
                    if (this.currentNode === this.lastNode) {
                        this.currentNode = nextNode;
                    }
                    else {
                        --this.currentIndex;
                    }
                    this.lastNode = null;
                }
                /**
                 *
                 * @param {*} o
                 */
                set(o) {
                    javaemul.internal.InternalPreconditions.checkState(this.lastNode != null);
                    this.lastNode.value = o;
                }
            }
            LinkedList.ListIteratorImpl2 = ListIteratorImpl2;
            ListIteratorImpl2["__class"] = "java.util.LinkedList.ListIteratorImpl2";
            ListIteratorImpl2["__interfaces"] = ["java.util.Iterator", "java.util.ListIterator"];
            /**
             * Internal class representing a doubly-linked list node.
             *
             * @param <E>
             * element type
             * @class
             */
            class Node {
                constructor() {
                    if (this.next === undefined)
                        this.next = null;
                    if (this.prev === undefined)
                        this.prev = null;
                    if (this.value === undefined)
                        this.value = null;
                }
            }
            LinkedList.Node = Node;
            Node["__class"] = "java.util.LinkedList.Node";
        })(LinkedList = util.LinkedList || (util.LinkedList = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        /**
         * Maintains a last-in, first-out collection of objects. <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Stack.html">[Sun
         * docs]</a>
         *
         * @param <E> element type.
         * @class
         * @extends java.util.Vector
         */
        class Stack extends java.util.Vector {
            constructor() {
                super();
            }
            /**
             *
             * @return {*}
             */
            clone() {
                let s = (new Stack());
                s.addAll$java_util_Collection(this);
                return s;
            }
            empty() {
                return this.isEmpty();
            }
            peek() {
                let sz = this.size();
                if (sz > 0) {
                    return this.get(sz - 1);
                }
                else {
                    throw new java.util.EmptyStackException();
                }
            }
            pop() {
                let sz = this.size();
                if (sz > 0) {
                    return this.remove$int(sz - 1);
                }
                else {
                    throw new java.util.EmptyStackException();
                }
            }
            push(o) {
                this.add(o);
                return o;
            }
            search(o) {
                let pos = this.lastIndexOf$java_lang_Object(o);
                if (pos >= 0) {
                    return this.size() - pos;
                }
                return -1;
            }
        }
        util.Stack = Stack;
        Stack["__class"] = "java.util.Stack";
        Stack["__interfaces"] = ["java.util.RandomAccess", "java.util.List", "java.lang.Cloneable", "java.util.Collection", "java.lang.Iterable", "java.io.Serializable"];
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        /**
         * Implementation of Map interface based on a hash table.
         * <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/HashMap.html">[Sun
         * docs]</a>
         *
         * @param <K>
         * key type
         * @param <V>
         * value type
         * @param {number} ignored
         * @param {number} alsoIgnored
         * @class
         * @extends java.util.AbstractMap
         */
        class AbstractHashMap extends java.util.AbstractMap {
            constructor(ignored, alsoIgnored) {
                if (((typeof ignored === 'number') || ignored === null) && ((typeof alsoIgnored === 'number') || alsoIgnored === null)) {
                    let __args = arguments;
                    super();
                    if (this.hashCodeMap === undefined)
                        this.hashCodeMap = null;
                    if (this.stringMap === undefined)
                        this.stringMap = null;
                    if (this.hashCodeMap === undefined)
                        this.hashCodeMap = null;
                    if (this.stringMap === undefined)
                        this.stringMap = null;
                    (() => {
                        javaemul.internal.InternalPreconditions.checkArgument(ignored >= 0, "Negative initial capacity");
                        javaemul.internal.InternalPreconditions.checkArgument(alsoIgnored >= 0, "Non-positive load factor");
                        this.reset();
                    })();
                }
                else if (((ignored != null && (ignored["__interfaces"] != null && ignored["__interfaces"].indexOf("java.util.Map") >= 0 || ignored.constructor != null && ignored.constructor["__interfaces"] != null && ignored.constructor["__interfaces"].indexOf("java.util.Map") >= 0)) || ignored === null) && alsoIgnored === undefined) {
                    let __args = arguments;
                    let toBeCopied = __args[0];
                    super();
                    if (this.hashCodeMap === undefined)
                        this.hashCodeMap = null;
                    if (this.stringMap === undefined)
                        this.stringMap = null;
                    if (this.hashCodeMap === undefined)
                        this.hashCodeMap = null;
                    if (this.stringMap === undefined)
                        this.stringMap = null;
                    (() => {
                        this.reset();
                        this.putAll(toBeCopied);
                    })();
                }
                else if (((typeof ignored === 'number') || ignored === null) && alsoIgnored === undefined) {
                    let __args = arguments;
                    {
                        let __args = arguments;
                        let alsoIgnored = 0;
                        super();
                        if (this.hashCodeMap === undefined)
                            this.hashCodeMap = null;
                        if (this.stringMap === undefined)
                            this.stringMap = null;
                        if (this.hashCodeMap === undefined)
                            this.hashCodeMap = null;
                        if (this.stringMap === undefined)
                            this.stringMap = null;
                        (() => {
                            javaemul.internal.InternalPreconditions.checkArgument(ignored >= 0, "Negative initial capacity");
                            javaemul.internal.InternalPreconditions.checkArgument(alsoIgnored >= 0, "Non-positive load factor");
                            this.reset();
                        })();
                    }
                }
                else if (ignored === undefined && alsoIgnored === undefined) {
                    let __args = arguments;
                    super();
                    if (this.hashCodeMap === undefined)
                        this.hashCodeMap = null;
                    if (this.stringMap === undefined)
                        this.stringMap = null;
                    if (this.hashCodeMap === undefined)
                        this.hashCodeMap = null;
                    if (this.stringMap === undefined)
                        this.stringMap = null;
                    (() => {
                        this.reset();
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             *
             */
            clear() {
                this.reset();
            }
            reset() {
                this.hashCodeMap = (new java.util.InternalHashCodeMap(this));
                this.stringMap = (new java.util.InternalStringMap(this));
                java.util.ConcurrentModificationDetector.structureChanged(this);
            }
            /**
             *
             * @param {*} key
             * @return {boolean}
             */
            containsKey(key) {
                return (typeof key === 'string') ? this.hasStringValue(javaemul.internal.JsUtils.unsafeCastToString(key)) : this.hasHashValue(key);
            }
            /**
             *
             * @param {*} value
             * @return {boolean}
             */
            containsValue(value) {
                return this._containsValue(value, this.stringMap) || this._containsValue(value, this.hashCodeMap);
            }
            _containsValue(value, entries) {
                for (let index170 = entries.iterator(); index170.hasNext();) {
                    let entry = index170.next();
                    {
                        if (this._equals(value, entry.getValue())) {
                            return true;
                        }
                    }
                }
                return false;
            }
            /**
             *
             * @return {*}
             */
            entrySet() {
                return new AbstractHashMap.EntrySet(this);
            }
            /**
             *
             * @param {*} key
             * @return {*}
             */
            get(key) {
                let v = (typeof key === 'string') ? this.getStringValue(javaemul.internal.JsUtils.unsafeCastToString(key)) : this.getHashValue(key);
                return v === undefined ? null : v;
            }
            /**
             *
             * @param {*} key
             * @param {*} value
             * @return {*}
             */
            put(key, value) {
                return (typeof key === 'string') ? this.putStringValue(javaemul.internal.JsUtils.unsafeCastToString(key), value) : this.putHashValue(key, value);
            }
            /**
             *
             * @param {*} key
             * @return {*}
             */
            remove(key) {
                return (typeof key === 'string') ? this.removeStringValue(javaemul.internal.JsUtils.unsafeCastToString(key)) : this.removeHashValue(key);
            }
            /**
             *
             * @return {number}
             */
            size() {
                return this.hashCodeMap.size() + this.stringMap.getSize();
            }
            /**
             * Returns the Map.Entry whose key is Object equal to <code>key</code>,
             * provided that <code>key</code>'s hash code is <code>hashCode</code>; or
             * <code>null</code> if no such Map.Entry exists at the specified hashCode.
             * @param {*} key
             * @return {*}
             * @private
             */
            getHashValue(key) {
                return (util.AbstractMap.getEntryValueOrNull(this.hashCodeMap.getEntry(key)));
            }
            /**
             * Returns the value for the given key in the stringMap. Returns
             * <code>null</code> if the specified key does not exist.
             * @param {string} key
             * @return {*}
             * @private
             */
            getStringValue(key) {
                return key == null ? this.getHashValue(null) : this.stringMap.get(key);
            }
            /**
             * Returns true if the a key exists in the hashCodeMap that is Object equal
             * to <code>key</code>, provided that <code>key</code>'s hash code is
             * <code>hashCode</code>.
             * @param {*} key
             * @return {boolean}
             * @private
             */
            hasHashValue(key) {
                return this.hashCodeMap.getEntry(key) != null;
            }
            /**
             * Returns true if the given key exists in the stringMap.
             * @param {string} key
             * @return {boolean}
             * @private
             */
            hasStringValue(key) {
                return key == null ? this.hasHashValue(null) : this.stringMap.contains(key);
            }
            /**
             * Sets the specified key to the specified value in the hashCodeMap. Returns
             * the value previously at that key. Returns <code>null</code> if the
             * specified key did not exist.
             * @param {*} key
             * @param {*} value
             * @return {*}
             * @private
             */
            putHashValue(key, value) {
                return this.hashCodeMap.put(key, value);
            }
            /**
             * Sets the specified key to the specified value in the stringMap. Returns
             * the value previously at that key. Returns <code>null</code> if the
             * specified key did not exist.
             * @param {string} key
             * @param {*} value
             * @return {*}
             * @private
             */
            putStringValue(key, value) {
                return key == null ? this.putHashValue(null, value) : this.stringMap.put(key, value);
            }
            /**
             * Removes the pair whose key is Object equal to <code>key</code> from
             * <code>hashCodeMap</code>, provided that <code>key</code>'s hash code is
             * <code>hashCode</code>. Returns the value that was associated with the
             * removed key, or null if no such key existed.
             * @param {*} key
             * @return {*}
             * @private
             */
            removeHashValue(key) {
                return this.hashCodeMap.remove(key);
            }
            /**
             * Removes the specified key from the stringMap and returns the value that
             * was previously there. Returns <code>null</code> if the specified key does
             * not exist.
             * @param {string} key
             * @return {*}
             * @private
             */
            removeStringValue(key) {
                return key == null ? this.removeHashValue(null) : this.stringMap.remove(key);
            }
        }
        util.AbstractHashMap = AbstractHashMap;
        AbstractHashMap["__class"] = "java.util.AbstractHashMap";
        AbstractHashMap["__interfaces"] = ["java.util.Map"];
        (function (AbstractHashMap) {
            class EntrySet extends java.util.AbstractSet {
                constructor(__parent) {
                    super();
                    this.__parent = __parent;
                }
                /**
                 *
                 */
                clear() {
                    this.clear();
                }
                /**
                 *
                 * @param {*} o
                 * @return {boolean}
                 */
                contains(o) {
                    if (o != null && (o["__interfaces"] != null && o["__interfaces"].indexOf("java.util.Map.Entry") >= 0 || o.constructor != null && o.constructor["__interfaces"] != null && o.constructor["__interfaces"].indexOf("java.util.Map.Entry") >= 0)) {
                        return this.__parent.containsEntry(o);
                    }
                    return false;
                }
                /**
                 *
                 * @return {*}
                 */
                iterator() {
                    return new AbstractHashMap.EntrySetIterator(this.__parent);
                }
                /**
                 *
                 * @param {*} entry
                 * @return {boolean}
                 */
                remove(entry) {
                    if (this.contains(entry)) {
                        let key = entry.getKey();
                        this.remove(key);
                        return true;
                    }
                    return false;
                }
                /**
                 *
                 * @return {number}
                 */
                size() {
                    return this.size();
                }
            }
            AbstractHashMap.EntrySet = EntrySet;
            EntrySet["__class"] = "java.util.AbstractHashMap.EntrySet";
            EntrySet["__interfaces"] = ["java.util.Collection", "java.util.Set", "java.lang.Iterable"];
            /**
             * Iterator for <code>EntrySet</code>.
             * @class
             */
            class EntrySetIterator {
                constructor(__parent) {
                    this.__parent = __parent;
                    if (this.stringMapEntries === undefined)
                        this.stringMapEntries = null;
                    if (this.current === undefined)
                        this.current = null;
                    if (this.last === undefined)
                        this.last = null;
                    if (this.__hasNext === undefined)
                        this.__hasNext = false;
                    this.stringMapEntries = __parent.stringMap.iterator();
                    this.current = this.stringMapEntries;
                    this.__hasNext = this.computeHasNext();
                    java.util.ConcurrentModificationDetector.recordLastKnownStructure(__parent, this);
                }
                forEachRemaining(consumer) {
                    javaemul.internal.InternalPreconditions.checkNotNull((consumer));
                    while ((this.hasNext())) {
                        {
                            (target => (typeof target === 'function') ? target(this.next()) : target.accept(this.next()))(consumer);
                        }
                    }
                    ;
                }
                /**
                 *
                 * @return {boolean}
                 */
                hasNext() {
                    return this.__hasNext;
                }
                computeHasNext() {
                    if (this.current.hasNext()) {
                        return true;
                    }
                    if (this.current !== this.stringMapEntries) {
                        return false;
                    }
                    this.current = this.__parent.hashCodeMap.iterator();
                    return this.current.hasNext();
                }
                /**
                 *
                 * @return {*}
                 */
                next() {
                    java.util.ConcurrentModificationDetector.checkStructuralChange(this.__parent, this);
                    javaemul.internal.InternalPreconditions.checkElement(this.hasNext());
                    this.last = this.current;
                    let rv = this.current.next();
                    this.__hasNext = this.computeHasNext();
                    return rv;
                }
                /**
                 *
                 */
                remove() {
                    javaemul.internal.InternalPreconditions.checkState(this.last != null);
                    java.util.ConcurrentModificationDetector.checkStructuralChange(this.__parent, this);
                    this.last.remove();
                    this.last = null;
                    this.__hasNext = this.computeHasNext();
                    java.util.ConcurrentModificationDetector.recordLastKnownStructure(this.__parent, this);
                }
            }
            AbstractHashMap.EntrySetIterator = EntrySetIterator;
            EntrySetIterator["__class"] = "java.util.AbstractHashMap.EntrySetIterator";
            EntrySetIterator["__interfaces"] = ["java.util.Iterator"];
        })(AbstractHashMap = util.AbstractHashMap || (util.AbstractHashMap = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        /**
         * Skeletal implementation of a NavigableMap.
         * @extends java.util.AbstractMap
         * @class
         */
        class AbstractNavigableMap extends java.util.AbstractMap {
            constructor() {
                super();
            }
            merge(key, value, map) {
                let old = this.get(key);
                let next = (old == null) ? value : (target => (typeof target === 'function') ? target(old, value) : target.apply(old, value))(map);
                if (next == null) {
                    this.remove(key);
                }
                else {
                    this.put(key, next);
                }
                return next;
            }
            computeIfAbsent(key, mappingFunction) {
                let result;
                if ((result = this.get(key)) == null) {
                    result = (target => (typeof target === 'function') ? target(key) : target.apply(key))(mappingFunction);
                    if (result != null)
                        this.put(key, result);
                }
                return result;
            }
            static copyOf(entry) {
                return entry == null ? null : (new util.AbstractMap.SimpleImmutableEntry(entry));
            }
            static getKeyOrNSE(entry) {
                if (entry == null) {
                    throw new java.util.NoSuchElementException();
                }
                return entry.getKey();
            }
            /**
             *
             * @param {*} key
             * @return {*}
             */
            ceilingEntry(key) {
                return AbstractNavigableMap.copyOf(this.getCeilingEntry(key));
            }
            /**
             *
             * @param {*} key
             * @return {*}
             */
            ceilingKey(key) {
                return (util.AbstractMap.getEntryKeyOrNull(this.getCeilingEntry(key)));
            }
            /**
             *
             * @param {*} k
             * @return {boolean}
             */
            containsKey(k) {
                let key = k;
                return this.getEntry(key) != null;
            }
            /**
             *
             * @return {*}
             */
            descendingKeySet() {
                return this.descendingMap().navigableKeySet();
            }
            /**
             *
             * @return {*}
             */
            descendingMap() {
                return new AbstractNavigableMap.DescendingMap(this);
            }
            /**
             *
             * @return {*}
             */
            entrySet() {
                return new AbstractNavigableMap.EntrySet(this);
            }
            /**
             *
             * @return {*}
             */
            firstEntry() {
                return AbstractNavigableMap.copyOf(this.getFirstEntry());
            }
            /**
             *
             * @return {*}
             */
            firstKey() {
                return (AbstractNavigableMap.getKeyOrNSE(this.getFirstEntry()));
            }
            /**
             *
             * @param {*} key
             * @return {*}
             */
            floorEntry(key) {
                return AbstractNavigableMap.copyOf(this.getFloorEntry(key));
            }
            /**
             *
             * @param {*} key
             * @return {*}
             */
            floorKey(key) {
                return (util.AbstractMap.getEntryKeyOrNull(this.getFloorEntry(key)));
            }
            /**
             *
             * @param {*} k
             * @return {*}
             */
            get(k) {
                let key = k;
                return (util.AbstractMap.getEntryValueOrNull(this.getEntry(key)));
            }
            headMap(toKey, inclusive) {
                if (((toKey != null) || toKey === null) && inclusive === undefined) {
                    return this.headMap$java_lang_Object(toKey);
                }
                else
                    throw new Error('invalid overload');
            }
            headMap$java_lang_Object(toKey) {
                return this.headMap(toKey, false);
            }
            /**
             *
             * @param {*} key
             * @return {*}
             */
            higherEntry(key) {
                return AbstractNavigableMap.copyOf(this.getHigherEntry(key));
            }
            /**
             *
             * @param {*} key
             * @return {*}
             */
            higherKey(key) {
                return (util.AbstractMap.getEntryKeyOrNull(this.getHigherEntry(key)));
            }
            /**
             *
             * @return {*}
             */
            keySet() {
                return this.navigableKeySet();
            }
            /**
             *
             * @return {*}
             */
            lastEntry() {
                return AbstractNavigableMap.copyOf(this.getLastEntry());
            }
            /**
             *
             * @return {*}
             */
            lastKey() {
                return (AbstractNavigableMap.getKeyOrNSE(this.getLastEntry()));
            }
            /**
             *
             * @param {*} key
             * @return {*}
             */
            lowerEntry(key) {
                return AbstractNavigableMap.copyOf(this.getLowerEntry(key));
            }
            /**
             *
             * @param {*} key
             * @return {*}
             */
            lowerKey(key) {
                return (util.AbstractMap.getEntryKeyOrNull(this.getLowerEntry(key)));
            }
            /**
             *
             * @return {*}
             */
            navigableKeySet() {
                return (new AbstractNavigableMap.NavigableKeySet(this));
            }
            /**
             *
             * @return {*}
             */
            pollFirstEntry() {
                return this.pollEntry(this.getFirstEntry());
            }
            /**
             *
             * @return {*}
             */
            pollLastEntry() {
                return this.pollEntry(this.getLastEntry());
            }
            subMap(fromKey, fromInclusive, toKey, toInclusive) {
                if (((fromKey != null) || fromKey === null) && ((fromInclusive != null) || fromInclusive === null) && toKey === undefined && toInclusive === undefined) {
                    return this.subMap$java_lang_Object$java_lang_Object(fromKey, fromInclusive);
                }
                else
                    throw new Error('invalid overload');
            }
            subMap$java_lang_Object$java_lang_Object(fromKey, toKey) {
                return this.subMap(fromKey, true, toKey, false);
            }
            tailMap(fromKey, inclusive) {
                if (((fromKey != null) || fromKey === null) && inclusive === undefined) {
                    return this.tailMap$java_lang_Object(fromKey);
                }
                else
                    throw new Error('invalid overload');
            }
            tailMap$java_lang_Object(fromKey) {
                return this.tailMap(fromKey, true);
            }
            /**
             *
             * @param {*} entry
             * @return {boolean}
             */
            containsEntry(entry) {
                let key = entry.getKey();
                let lookupEntry = this.getEntry(key);
                return lookupEntry != null && java.util.Objects.equals(lookupEntry.getValue(), entry.getValue());
            }
            pollEntry(entry) {
                if (entry != null) {
                    this.removeEntry(entry);
                }
                return AbstractNavigableMap.copyOf(entry);
            }
        }
        util.AbstractNavigableMap = AbstractNavigableMap;
        AbstractNavigableMap["__class"] = "java.util.AbstractNavigableMap";
        AbstractNavigableMap["__interfaces"] = ["java.util.Map", "java.util.NavigableMap", "java.util.SortedMap"];
        (function (AbstractNavigableMap) {
            class DescendingMap extends java.util.AbstractNavigableMap {
                constructor(__parent) {
                    super();
                    this.__parent = __parent;
                }
                /**
                 *
                 */
                clear() {
                    this.ascendingMap().clear();
                }
                /**
                 *
                 * @return {*}
                 */
                comparator() {
                    return java.util.Collections.reverseOrder$java_util_Comparator(this.ascendingMap().comparator());
                }
                /**
                 *
                 * @return {*}
                 */
                descendingMap() {
                    return this.ascendingMap();
                }
                headMap$java_lang_Object$boolean(toKey, inclusive) {
                    return this.ascendingMap().tailMap(toKey, inclusive).descendingMap();
                }
                /**
                 *
                 * @param {*} toKey
                 * @param {boolean} inclusive
                 * @return {*}
                 */
                headMap(toKey, inclusive) {
                    if (((toKey != null) || toKey === null) && ((typeof inclusive === 'boolean') || inclusive === null)) {
                        return this.headMap$java_lang_Object$boolean(toKey, inclusive);
                    }
                    else if (((toKey != null) || toKey === null) && inclusive === undefined) {
                        return this.headMap$java_lang_Object(toKey);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 *
                 * @param {*} key
                 * @param {*} value
                 * @return {*}
                 */
                put(key, value) {
                    return this.ascendingMap().put(key, value);
                }
                /**
                 *
                 * @param {*} key
                 * @return {*}
                 */
                remove(key) {
                    return this.ascendingMap().remove(key);
                }
                /**
                 *
                 * @return {number}
                 */
                size() {
                    return this.ascendingMap().size();
                }
                subMap$java_lang_Object$boolean$java_lang_Object$boolean(fromKey, fromInclusive, toKey, toInclusive) {
                    return this.ascendingMap().subMap(toKey, toInclusive, fromKey, fromInclusive).descendingMap();
                }
                /**
                 *
                 * @param {*} fromKey
                 * @param {boolean} fromInclusive
                 * @param {*} toKey
                 * @param {boolean} toInclusive
                 * @return {*}
                 */
                subMap(fromKey, fromInclusive, toKey, toInclusive) {
                    if (((fromKey != null) || fromKey === null) && ((typeof fromInclusive === 'boolean') || fromInclusive === null) && ((toKey != null) || toKey === null) && ((typeof toInclusive === 'boolean') || toInclusive === null)) {
                        return this.subMap$java_lang_Object$boolean$java_lang_Object$boolean(fromKey, fromInclusive, toKey, toInclusive);
                    }
                    else if (((fromKey != null) || fromKey === null) && ((fromInclusive != null) || fromInclusive === null) && toKey === undefined && toInclusive === undefined) {
                        return this.subMap$java_lang_Object$java_lang_Object(fromKey, fromInclusive);
                    }
                    else
                        throw new Error('invalid overload');
                }
                tailMap$java_lang_Object$boolean(fromKey, inclusive) {
                    return this.ascendingMap().headMap(fromKey, inclusive).descendingMap();
                }
                /**
                 *
                 * @param {*} fromKey
                 * @param {boolean} inclusive
                 * @return {*}
                 */
                tailMap(fromKey, inclusive) {
                    if (((fromKey != null) || fromKey === null) && ((typeof inclusive === 'boolean') || inclusive === null)) {
                        return this.tailMap$java_lang_Object$boolean(fromKey, inclusive);
                    }
                    else if (((fromKey != null) || fromKey === null) && inclusive === undefined) {
                        return this.tailMap$java_lang_Object(fromKey);
                    }
                    else
                        throw new Error('invalid overload');
                }
                ascendingMap() {
                    return this.__parent;
                }
                /**
                 *
                 * @return {*}
                 */
                descendingEntryIterator() {
                    return this.ascendingMap().entryIterator();
                }
                /**
                 *
                 * @return {*}
                 */
                entryIterator() {
                    return this.ascendingMap().descendingEntryIterator();
                }
                /**
                 *
                 * @param {*} key
                 * @return {*}
                 */
                getEntry(key) {
                    return this.ascendingMap().getEntry(key);
                }
                /**
                 *
                 * @return {*}
                 */
                getFirstEntry() {
                    return this.ascendingMap().getLastEntry();
                }
                /**
                 *
                 * @return {*}
                 */
                getLastEntry() {
                    return this.ascendingMap().getFirstEntry();
                }
                /**
                 *
                 * @param {*} key
                 * @return {*}
                 */
                getCeilingEntry(key) {
                    return this.ascendingMap().getFloorEntry(key);
                }
                /**
                 *
                 * @param {*} key
                 * @return {*}
                 */
                getFloorEntry(key) {
                    return this.ascendingMap().getCeilingEntry(key);
                }
                /**
                 *
                 * @param {*} key
                 * @return {*}
                 */
                getHigherEntry(key) {
                    return this.ascendingMap().getLowerEntry(key);
                }
                /**
                 *
                 * @param {*} key
                 * @return {*}
                 */
                getLowerEntry(key) {
                    return this.ascendingMap().getHigherEntry(key);
                }
                /**
                 *
                 * @param {*} entry
                 * @return {boolean}
                 */
                removeEntry(entry) {
                    return this.ascendingMap().removeEntry(entry);
                }
            }
            AbstractNavigableMap.DescendingMap = DescendingMap;
            DescendingMap["__class"] = "java.util.AbstractNavigableMap.DescendingMap";
            DescendingMap["__interfaces"] = ["java.util.Map", "java.util.NavigableMap", "java.util.SortedMap"];
            class EntrySet extends java.util.AbstractSet {
                constructor(__parent) {
                    super();
                    this.__parent = __parent;
                }
                /**
                 *
                 * @param {*} o
                 * @return {boolean}
                 */
                contains(o) {
                    return (o != null && (o["__interfaces"] != null && o["__interfaces"].indexOf("java.util.Map.Entry") >= 0 || o.constructor != null && o.constructor["__interfaces"] != null && o.constructor["__interfaces"].indexOf("java.util.Map.Entry") >= 0)) && this.__parent.containsEntry(o);
                }
                /**
                 *
                 * @return {*}
                 */
                iterator() {
                    return this.__parent.entryIterator();
                }
                /**
                 *
                 * @param {*} o
                 * @return {boolean}
                 */
                remove(o) {
                    if (o != null && (o["__interfaces"] != null && o["__interfaces"].indexOf("java.util.Map.Entry") >= 0 || o.constructor != null && o.constructor["__interfaces"] != null && o.constructor["__interfaces"].indexOf("java.util.Map.Entry") >= 0)) {
                        let entry = o;
                        return this.__parent.removeEntry(entry);
                    }
                    return false;
                }
                /**
                 *
                 * @return {number}
                 */
                size() {
                    return this.size();
                }
            }
            AbstractNavigableMap.EntrySet = EntrySet;
            EntrySet["__class"] = "java.util.AbstractNavigableMap.EntrySet";
            EntrySet["__interfaces"] = ["java.util.Collection", "java.util.Set", "java.lang.Iterable"];
            class NavigableKeySet extends java.util.AbstractSet {
                constructor(map) {
                    super();
                    if (this.map === undefined)
                        this.map = null;
                    this.map = map;
                }
                stream() {
                    return (new javaemul.internal.stream.StreamHelper(this));
                }
                forEach(action) {
                    javaemul.internal.InternalPreconditions.checkNotNull((action));
                    for (let index171 = this.iterator(); index171.hasNext();) {
                        let t = index171.next();
                        {
                            (target => (typeof target === 'function') ? target(t) : target.accept(t))(action);
                        }
                    }
                }
                removeIf(filter) {
                    javaemul.internal.InternalPreconditions.checkNotNull((filter));
                    let removed = false;
                    for (let it = this.iterator(); it.hasNext();) {
                        {
                            if ((target => (typeof target === 'function') ? target(it.next()) : target.test(it.next()))(filter)) {
                                it.remove();
                                removed = true;
                            }
                        }
                        ;
                    }
                    return removed;
                }
                /**
                 *
                 * @param {*} k
                 * @return {*}
                 */
                ceiling(k) {
                    return this.map.ceilingKey(k);
                }
                /**
                 *
                 */
                clear() {
                    this.map.clear();
                }
                /**
                 *
                 * @return {*}
                 */
                comparator() {
                    return this.map.comparator();
                }
                /**
                 *
                 * @param {*} o
                 * @return {boolean}
                 */
                contains(o) {
                    return this.map.containsKey(o);
                }
                /**
                 *
                 * @return {*}
                 */
                descendingIterator() {
                    return this.descendingSet().iterator();
                }
                /**
                 *
                 * @return {*}
                 */
                descendingSet() {
                    return this.map.descendingMap().navigableKeySet();
                }
                /**
                 *
                 * @return {*}
                 */
                first() {
                    return this.map.firstKey();
                }
                /**
                 *
                 * @param {*} k
                 * @return {*}
                 */
                floor(k) {
                    return this.map.floorKey(k);
                }
                headSet$java_lang_Object(toElement) {
                    return this.headSet(toElement, false);
                }
                headSet$java_lang_Object$boolean(toElement, inclusive) {
                    return this.map.headMap(toElement, inclusive).navigableKeySet();
                }
                /**
                 *
                 * @param {*} toElement
                 * @param {boolean} inclusive
                 * @return {*}
                 */
                headSet(toElement, inclusive) {
                    if (((toElement != null) || toElement === null) && ((typeof inclusive === 'boolean') || inclusive === null)) {
                        return this.headSet$java_lang_Object$boolean(toElement, inclusive);
                    }
                    else if (((toElement != null) || toElement === null) && inclusive === undefined) {
                        return this.headSet$java_lang_Object(toElement);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 *
                 * @param {*} k
                 * @return {*}
                 */
                higher(k) {
                    return this.map.higherKey(k);
                }
                /**
                 *
                 * @return {*}
                 */
                iterator() {
                    let entryIterator = this.map.entrySet().iterator();
                    return new NavigableKeySet.NavigableKeySet$0(this, entryIterator);
                }
                /**
                 *
                 * @return {*}
                 */
                last() {
                    return this.map.lastKey();
                }
                /**
                 *
                 * @param {*} k
                 * @return {*}
                 */
                lower(k) {
                    return this.map.lowerKey(k);
                }
                /**
                 *
                 * @return {*}
                 */
                pollFirst() {
                    return (util.AbstractMap.getEntryKeyOrNull(this.map.pollFirstEntry()));
                }
                /**
                 *
                 * @return {*}
                 */
                pollLast() {
                    return (util.AbstractMap.getEntryKeyOrNull(this.map.pollLastEntry()));
                }
                /**
                 *
                 * @param {*} o
                 * @return {boolean}
                 */
                remove(o) {
                    if (this.map.containsKey(o)) {
                        this.map.remove(o);
                        return true;
                    }
                    return false;
                }
                /**
                 *
                 * @return {number}
                 */
                size() {
                    return this.map.size();
                }
                subSet$java_lang_Object$boolean$java_lang_Object$boolean(fromElement, fromInclusive, toElement, toInclusive) {
                    return this.map.subMap(fromElement, fromInclusive, toElement, toInclusive).navigableKeySet();
                }
                /**
                 *
                 * @param {*} fromElement
                 * @param {boolean} fromInclusive
                 * @param {*} toElement
                 * @param {boolean} toInclusive
                 * @return {*}
                 */
                subSet(fromElement, fromInclusive, toElement, toInclusive) {
                    if (((fromElement != null) || fromElement === null) && ((typeof fromInclusive === 'boolean') || fromInclusive === null) && ((toElement != null) || toElement === null) && ((typeof toInclusive === 'boolean') || toInclusive === null)) {
                        return this.subSet$java_lang_Object$boolean$java_lang_Object$boolean(fromElement, fromInclusive, toElement, toInclusive);
                    }
                    else if (((fromElement != null) || fromElement === null) && ((fromInclusive != null) || fromInclusive === null) && toElement === undefined && toInclusive === undefined) {
                        return this.subSet$java_lang_Object$java_lang_Object(fromElement, fromInclusive);
                    }
                    else
                        throw new Error('invalid overload');
                }
                subSet$java_lang_Object$java_lang_Object(fromElement, toElement) {
                    return this.subSet(fromElement, true, toElement, false);
                }
                tailSet$java_lang_Object(fromElement) {
                    return this.tailSet(fromElement, true);
                }
                tailSet$java_lang_Object$boolean(fromElement, inclusive) {
                    return this.map.tailMap(fromElement, inclusive).navigableKeySet();
                }
                /**
                 *
                 * @param {*} fromElement
                 * @param {boolean} inclusive
                 * @return {*}
                 */
                tailSet(fromElement, inclusive) {
                    if (((fromElement != null) || fromElement === null) && ((typeof inclusive === 'boolean') || inclusive === null)) {
                        return this.tailSet$java_lang_Object$boolean(fromElement, inclusive);
                    }
                    else if (((fromElement != null) || fromElement === null) && inclusive === undefined) {
                        return this.tailSet$java_lang_Object(fromElement);
                    }
                    else
                        throw new Error('invalid overload');
                }
            }
            AbstractNavigableMap.NavigableKeySet = NavigableKeySet;
            NavigableKeySet["__class"] = "java.util.AbstractNavigableMap.NavigableKeySet";
            NavigableKeySet["__interfaces"] = ["java.util.SortedSet", "java.util.Collection", "java.util.Set", "java.util.NavigableSet", "java.lang.Iterable"];
            (function (NavigableKeySet) {
                class NavigableKeySet$0 {
                    constructor(__parent, entryIterator) {
                        this.entryIterator = entryIterator;
                        this.__parent = __parent;
                    }
                    forEachRemaining(consumer) {
                        javaemul.internal.InternalPreconditions.checkNotNull((consumer));
                        while ((this.hasNext())) {
                            {
                                (target => (typeof target === 'function') ? target(this.next()) : target.accept(this.next()))(consumer);
                            }
                        }
                        ;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    hasNext() {
                        return this.entryIterator.hasNext();
                    }
                    /**
                     *
                     * @return {*}
                     */
                    next() {
                        let entry = this.entryIterator.next();
                        return entry.getKey();
                    }
                    /**
                     *
                     */
                    remove() {
                        this.entryIterator.remove();
                    }
                }
                NavigableKeySet.NavigableKeySet$0 = NavigableKeySet$0;
                NavigableKeySet$0["__interfaces"] = ["java.util.Iterator"];
            })(NavigableKeySet = AbstractNavigableMap.NavigableKeySet || (AbstractNavigableMap.NavigableKeySet = {}));
        })(AbstractNavigableMap = util.AbstractNavigableMap || (util.AbstractNavigableMap = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        /**
         * Utility methods that operate on collections. <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Collections.html">[Sun
         * docs]</a>
         * @class
         */
        class Collections {
            static EMPTY_LIST_$LI$() { if (Collections.EMPTY_LIST == null)
                Collections.EMPTY_LIST = new Collections.EmptyList(); return Collections.EMPTY_LIST; }
            ;
            static EMPTY_MAP_$LI$() { if (Collections.EMPTY_MAP == null)
                Collections.EMPTY_MAP = new Collections.EmptyMap(); return Collections.EMPTY_MAP; }
            ;
            static EMPTY_SET_$LI$() { if (Collections.EMPTY_SET == null)
                Collections.EMPTY_SET = new Collections.EmptySet(); return Collections.EMPTY_SET; }
            ;
            static addAll(c, ...a) {
                let result = false;
                for (let index172 = 0; index172 < a.length; index172++) {
                    let e = a[index172];
                    {
                        result = c.add(e) || result;
                    }
                }
                return result;
            }
            static asLifoQueue(deque) {
                return (new Collections.LifoQueue(deque));
            }
            static binarySearch$java_util_List$java_lang_Object(sortedList, key) {
                return Collections.binarySearch(sortedList, key, null);
            }
            static binarySearch$java_util_List$java_lang_Object$java_util_Comparator(sortedList, key, comparator) {
                if (comparator == null) {
                    comparator = java.util.Comparators.natural();
                }
                let low = 0;
                let high = sortedList.size() - 1;
                while ((low <= high)) {
                    {
                        let mid = low + ((high - low) >> 1);
                        let midVal = sortedList.get(mid);
                        let compareResult = comparator.compare(midVal, key);
                        if (compareResult < 0) {
                            low = mid + 1;
                        }
                        else if (compareResult > 0) {
                            high = mid - 1;
                        }
                        else {
                            return mid;
                        }
                    }
                }
                ;
                return -low - 1;
            }
            /**
             * Perform a binary search on a sorted List, using a user-specified comparison
             * function.
             *
             * <p>
             * Note: The GWT implementation differs from the JDK implementation in that it
             * does not do an iterator-based binary search for Lists that do not implement
             * RandomAccess.
             * </p>
             *
             * @param {*} sortedList List to search
             * @param {*} key value to search for
             * @param {*} comparator comparision function, <code>null</code> indicates
             * <i>natural ordering</i> should be used.
             * @return {number} the index of an element with a matching value, or a negative number
             * which is the index of the next larger value (or just past the end
             * of the array if the searched value is larger than all elements in
             * the array) minus 1 (to ensure error returns are negative)
             * @throws ClassCastException if <code>key</code> and
             * <code>sortedList</code>'s elements cannot be compared by
             * <code>comparator</code>.
             */
            static binarySearch(sortedList, key, comparator) {
                if (((sortedList != null && (sortedList["__interfaces"] != null && sortedList["__interfaces"].indexOf("java.util.List") >= 0 || sortedList.constructor != null && sortedList.constructor["__interfaces"] != null && sortedList.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || sortedList === null) && ((key != null) || key === null) && ((comparator != null && (comparator["__interfaces"] != null && comparator["__interfaces"].indexOf("java.util.Comparator") >= 0 || comparator.constructor != null && comparator.constructor["__interfaces"] != null && comparator.constructor["__interfaces"].indexOf("java.util.Comparator") >= 0)) || comparator === null)) {
                    return java.util.Collections.binarySearch$java_util_List$java_lang_Object$java_util_Comparator(sortedList, key, comparator);
                }
                else if (((sortedList != null && (sortedList["__interfaces"] != null && sortedList["__interfaces"].indexOf("java.util.List") >= 0 || sortedList.constructor != null && sortedList.constructor["__interfaces"] != null && sortedList.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || sortedList === null) && ((key != null) || key === null) && comparator === undefined) {
                    return java.util.Collections.binarySearch$java_util_List$java_lang_Object(sortedList, key);
                }
                else
                    throw new Error('invalid overload');
            }
            static copy(dest, src) {
                if (src.size() > dest.size()) {
                    throw new java.lang.IndexOutOfBoundsException("src does not fit in dest");
                }
                let destIt = dest.listIterator();
                for (let index173 = src.iterator(); index173.hasNext();) {
                    let e = index173.next();
                    {
                        destIt.next();
                        destIt.set(e);
                    }
                }
            }
            static disjoint(c1, c2) {
                let iterating = c1;
                let testing = c2;
                if ((c1 != null && (c1["__interfaces"] != null && c1["__interfaces"].indexOf("java.util.Set") >= 0 || c1.constructor != null && c1.constructor["__interfaces"] != null && c1.constructor["__interfaces"].indexOf("java.util.Set") >= 0)) && !(c2 != null && (c2["__interfaces"] != null && c2["__interfaces"].indexOf("java.util.Set") >= 0 || c2.constructor != null && c2.constructor["__interfaces"] != null && c2.constructor["__interfaces"].indexOf("java.util.Set") >= 0))) {
                    iterating = c2;
                    testing = c1;
                }
                for (let index174 = iterating.iterator(); index174.hasNext();) {
                    let o = index174.next();
                    {
                        if (testing.contains(o)) {
                            return false;
                        }
                    }
                }
                return true;
            }
            static emptyIterator() {
                return Collections.EmptyListIterator.INSTANCE_$LI$();
            }
            static emptyList() {
                return Collections.EMPTY_LIST_$LI$();
            }
            static emptyListIterator() {
                return Collections.EmptyListIterator.INSTANCE_$LI$();
            }
            static emptyMap() {
                return Collections.EMPTY_MAP_$LI$();
            }
            static emptySet() {
                return Collections.EMPTY_SET_$LI$();
            }
            static enumeration(c) {
                let it = c.iterator();
                return new Collections.Collections$0(it);
            }
            static fill(list, obj) {
                for (let it = list.listIterator(); it.hasNext();) {
                    {
                        it.next();
                        it.set(obj);
                    }
                    ;
                }
            }
            static frequency(c, o) {
                let count = 0;
                for (let index175 = c.iterator(); index175.hasNext();) {
                    let e = index175.next();
                    {
                        if (java.util.Objects.equals(o, e)) {
                            ++count;
                        }
                    }
                }
                return count;
            }
            static list(e) {
                let arrayList = (new java.util.ArrayList());
                while ((e.hasMoreElements())) {
                    {
                        arrayList.add(e.nextElement());
                    }
                }
                ;
                return arrayList;
            }
            static max$java_util_Collection(coll) {
                return (Collections.max$java_util_Collection$java_util_Comparator(coll, null));
            }
            static max$java_util_Collection$java_util_Comparator(coll, comp) {
                if (comp == null) {
                    comp = java.util.Comparators.natural();
                }
                let it = coll.iterator();
                let max = it.next();
                while ((it.hasNext())) {
                    {
                        let t = it.next();
                        if (comp.compare(t, max) > 0) {
                            max = t;
                        }
                    }
                }
                ;
                return max;
            }
            static max(coll, comp) {
                if (((coll != null && (coll["__interfaces"] != null && coll["__interfaces"].indexOf("java.util.Collection") >= 0 || coll.constructor != null && coll.constructor["__interfaces"] != null && coll.constructor["__interfaces"].indexOf("java.util.Collection") >= 0)) || coll === null) && ((comp != null && (comp["__interfaces"] != null && comp["__interfaces"].indexOf("java.util.Comparator") >= 0 || comp.constructor != null && comp.constructor["__interfaces"] != null && comp.constructor["__interfaces"].indexOf("java.util.Comparator") >= 0)) || comp === null)) {
                    return java.util.Collections.max$java_util_Collection$java_util_Comparator(coll, comp);
                }
                else if (((coll != null && (coll["__interfaces"] != null && coll["__interfaces"].indexOf("java.util.Collection") >= 0 || coll.constructor != null && coll.constructor["__interfaces"] != null && coll.constructor["__interfaces"].indexOf("java.util.Collection") >= 0)) || coll === null) && comp === undefined) {
                    return java.util.Collections.max$java_util_Collection(coll);
                }
                else
                    throw new Error('invalid overload');
            }
            static min(coll, comp = null) {
                return (Collections.max$java_util_Collection$java_util_Comparator(coll, Collections.reverseOrder$java_util_Comparator(comp)));
            }
            static newSetFromMap(map) {
                javaemul.internal.InternalPreconditions.checkArgument(map.isEmpty(), "map is not empty");
                return (new Collections.SetFromMap(map));
            }
            static nCopies(n, o) {
                let list = (new java.util.ArrayList());
                for (let i = 0; i < n; ++i) {
                    {
                        list.add(o);
                    }
                    ;
                }
                return Collections.unmodifiableList(list);
            }
            static replaceAll(list, oldVal, newVal) {
                let modified = false;
                for (let it = list.listIterator(); it.hasNext();) {
                    {
                        let t = it.next();
                        if (java.util.Objects.equals(t, oldVal)) {
                            it.set(newVal);
                            modified = true;
                        }
                    }
                    ;
                }
                return modified;
            }
            static reverse(l) {
                if (l != null && (l["__interfaces"] != null && l["__interfaces"].indexOf("java.util.RandomAccess") >= 0 || l.constructor != null && l.constructor["__interfaces"] != null && l.constructor["__interfaces"].indexOf("java.util.RandomAccess") >= 0)) {
                    for (let iFront = 0, iBack = l.size() - 1; iFront < iBack; ++iFront, --iBack) {
                        {
                            Collections.swap(l, iFront, iBack);
                        }
                        ;
                    }
                }
                else {
                    let head = l.listIterator();
                    let tail = l['listIterator$int'](l.size());
                    while ((head.nextIndex() < tail.previousIndex())) {
                        {
                            let headElem = head.next();
                            let tailElem = tail.previous();
                            head.set(tailElem);
                            tail.set(headElem);
                        }
                    }
                    ;
                }
            }
            static reverseOrder$() {
                return (Collections.ReverseComparator.INSTANCE_$LI$());
            }
            static reverseOrder$java_util_Comparator(cmp) {
                if (cmp == null) {
                    return Collections.reverseOrder();
                }
                return new Collections.Collections$1(cmp);
            }
            static reverseOrder(cmp) {
                if (((cmp != null && (cmp["__interfaces"] != null && cmp["__interfaces"].indexOf("java.util.Comparator") >= 0 || cmp.constructor != null && cmp.constructor["__interfaces"] != null && cmp.constructor["__interfaces"].indexOf("java.util.Comparator") >= 0)) || cmp === null)) {
                    return java.util.Collections.reverseOrder$java_util_Comparator(cmp);
                }
                else if (cmp === undefined) {
                    return java.util.Collections.reverseOrder$();
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             * Rotates the elements in {@code list} by the distance {@code dist}
             * <p>
             * e.g. for a given list with elements [1, 2, 3, 4, 5, 6, 7, 8, 9, 0], calling rotate(list, 3) or
             * rotate(list, -7) would modify the list to look like this: [8, 9, 0, 1, 2, 3, 4, 5, 6, 7]
             *
             * @param {*} lst the list whose elements are to be rotated.
             * @param {number} dist is the distance the list is rotated. This can be any valid integer. Negative values
             * rotate the list backwards.
             */
            static rotate(lst, dist) {
                javaemul.internal.InternalPreconditions.checkNotNull(lst);
                let size = lst.size();
                if (size === 0) {
                    return;
                }
                let normdist = dist % size;
                if (normdist === 0) {
                    return;
                }
                if (normdist < 0) {
                    normdist += size;
                }
                if (lst != null && (lst["__interfaces"] != null && lst["__interfaces"].indexOf("java.util.RandomAccess") >= 0 || lst.constructor != null && lst.constructor["__interfaces"] != null && lst.constructor["__interfaces"].indexOf("java.util.RandomAccess") >= 0)) {
                    let list = lst;
                    let temp = list.get(0);
                    let index = 0;
                    let beginIndex = 0;
                    for (let i = 0; i < size; i++) {
                        {
                            index = (index + normdist) % size;
                            temp = list.set(index, temp);
                            if (index === beginIndex) {
                                index = ++beginIndex;
                                temp = list.get(beginIndex);
                            }
                        }
                        ;
                    }
                }
                else {
                    let divideIndex = size - normdist;
                    let sublist1 = lst.subList(0, divideIndex);
                    let sublist2 = lst.subList(divideIndex, size);
                    Collections.reverse(sublist1);
                    Collections.reverse(sublist2);
                    Collections.reverse(lst);
                }
            }
            static shuffle(list, rnd = Collections.RandomHolder.rnd_$LI$()) {
                if (list != null && (list["__interfaces"] != null && list["__interfaces"].indexOf("java.util.RandomAccess") >= 0 || list.constructor != null && list.constructor["__interfaces"] != null && list.constructor["__interfaces"].indexOf("java.util.RandomAccess") >= 0)) {
                    for (let i = list.size() - 1; i >= 1; i--) {
                        {
                            Collections.swapImpl$java_util_List$int$int(list, i, rnd.nextInt$int(i + 1));
                        }
                        ;
                    }
                }
                else {
                    let arr = list.toArray();
                    for (let i = arr.length - 1; i >= 1; i--) {
                        {
                            Collections.swapImpl$java_lang_Object_A$int$int(arr, i, rnd.nextInt$int(i + 1));
                        }
                        ;
                    }
                    let it = list.listIterator();
                    for (let index176 = 0; index176 < arr.length; index176++) {
                        let e = arr[index176];
                        {
                            it.next();
                            it.set(e);
                        }
                    }
                }
            }
            static singleton(o) {
                let set = (new java.util.HashSet(1));
                set.add(o);
                return Collections.unmodifiableSet(set);
            }
            static singletonList(o) {
                return (new Collections.SingletonList(o));
            }
            static singletonMap(key, value) {
                let map = (new java.util.HashMap(1));
                map.put(key, value);
                return Collections.unmodifiableMap(map);
            }
            static sort$java_util_List(target) {
                Collections.sort$java_util_List$java_util_Comparator(target, null);
            }
            static sort$java_util_List$java_util_Comparator(target, c) {
                let x = target.toArray();
                java.util.Arrays.sort$java_lang_Object_A$java_util_Comparator(x, c);
                Collections.replaceContents(target, x);
            }
            static sort(target, c) {
                if (((target != null && (target["__interfaces"] != null && target["__interfaces"].indexOf("java.util.List") >= 0 || target.constructor != null && target.constructor["__interfaces"] != null && target.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || target === null) && ((c != null && (c["__interfaces"] != null && c["__interfaces"].indexOf("java.util.Comparator") >= 0 || c.constructor != null && c.constructor["__interfaces"] != null && c.constructor["__interfaces"].indexOf("java.util.Comparator") >= 0)) || c === null)) {
                    return java.util.Collections.sort$java_util_List$java_util_Comparator(target, c);
                }
                else if (((target != null && (target["__interfaces"] != null && target["__interfaces"].indexOf("java.util.List") >= 0 || target.constructor != null && target.constructor["__interfaces"] != null && target.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || target === null) && c === undefined) {
                    return java.util.Collections.sort$java_util_List(target);
                }
                else
                    throw new Error('invalid overload');
            }
            static swap(list, i, j) {
                Collections.swapImpl$java_util_List$int$int(list, i, j);
            }
            static unmodifiableCollection(coll) {
                return (new Collections.UnmodifiableCollection(coll));
            }
            static unmodifiableList(list) {
                return (list != null && (list["__interfaces"] != null && list["__interfaces"].indexOf("java.util.RandomAccess") >= 0 || list.constructor != null && list.constructor["__interfaces"] != null && list.constructor["__interfaces"].indexOf("java.util.RandomAccess") >= 0)) ? (new Collections.UnmodifiableRandomAccessList(list)) : (new Collections.UnmodifiableList(list));
            }
            static unmodifiableMap(map) {
                return (new Collections.UnmodifiableMap(map));
            }
            static unmodifiableSet(set) {
                return (new Collections.UnmodifiableSet(set));
            }
            static unmodifiableSortedMap(map) {
                return (new Collections.UnmodifiableSortedMap(map));
            }
            static unmodifiableSortedSet(set) {
                return (new Collections.UnmodifiableSortedSet(set));
            }
            static hashCode$java_lang_Iterable(collection) {
                let hashCode = 0;
                for (let index177 = collection.iterator(); index177.hasNext();) {
                    let e = index177.next();
                    {
                        hashCode = hashCode + java.util.Objects.hashCode(e);
                        hashCode = javaemul.internal.Coercions.ensureInt(hashCode);
                    }
                }
                return hashCode;
            }
            static hashCode$java_util_List(list) {
                let hashCode = 1;
                for (let index178 = list.iterator(); index178.hasNext();) {
                    let e = index178.next();
                    {
                        hashCode = 31 * hashCode + java.util.Objects.hashCode(e);
                        hashCode = javaemul.internal.Coercions.ensureInt(hashCode);
                    }
                }
                return hashCode;
            }
            /**
             * Computes hash code preserving collection order (e.g. ArrayList).
             * @param {*} list
             * @return {number}
             */
            static hashCode(list) {
                if (((list != null && (list["__interfaces"] != null && list["__interfaces"].indexOf("java.util.List") >= 0 || list.constructor != null && list.constructor["__interfaces"] != null && list.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || list === null)) {
                    return java.util.Collections.hashCode$java_util_List(list);
                }
                else if (((list != null && (list["__interfaces"] != null && list["__interfaces"].indexOf("java.lang.Iterable") >= 0 || list.constructor != null && list.constructor["__interfaces"] != null && list.constructor["__interfaces"].indexOf("java.lang.Iterable") >= 0)) || list === null)) {
                    return java.util.Collections.hashCode$java_lang_Iterable(list);
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             * Replace contents of a list from an array.
             *
             * @param <T> element type
             * @param {*} target list to replace contents from an array
             * @param {Array} x an Object array which can contain only T instances
             * @private
             */
            static replaceContents(target, x) {
                let size = target.size();
                for (let i = 0; i < size; i++) {
                    {
                        target.set(i, x[i]);
                    }
                    ;
                }
            }
            static swapImpl$java_util_List$int$int(list, i, j) {
                let t = list.get(i);
                list.set(i, list.get(j));
                list.set(j, t);
            }
            static swapImpl(list, i, j) {
                if (((list != null && (list["__interfaces"] != null && list["__interfaces"].indexOf("java.util.List") >= 0 || list.constructor != null && list.constructor["__interfaces"] != null && list.constructor["__interfaces"].indexOf("java.util.List") >= 0)) || list === null) && ((typeof i === 'number') || i === null) && ((typeof j === 'number') || j === null)) {
                    return java.util.Collections.swapImpl$java_util_List$int$int(list, i, j);
                }
                else if (((list != null && list instanceof Array && (list.length == 0 || list[0] == null || (list[0] != null))) || list === null) && ((typeof i === 'number') || i === null) && ((typeof j === 'number') || j === null)) {
                    return java.util.Collections.swapImpl$java_lang_Object_A$int$int(list, i, j);
                }
                else
                    throw new Error('invalid overload');
            }
            static swapImpl$java_lang_Object_A$int$int(a, i, j) {
                let obj = a[i];
                a[i] = a[j];
                a[j] = obj;
            }
        }
        util.Collections = Collections;
        Collections["__class"] = "java.util.Collections";
        (function (Collections) {
            class LifoQueue extends java.util.AbstractQueue {
                constructor(deque) {
                    super();
                    if (this.deque === undefined)
                        this.deque = null;
                    this.deque = deque;
                }
                /**
                 *
                 * @return {*}
                 */
                iterator() {
                    return this.deque.iterator();
                }
                /**
                 *
                 * @param {*} e
                 * @return {boolean}
                 */
                offer(e) {
                    return this.deque.offerFirst(e);
                }
                /**
                 *
                 * @return {*}
                 */
                peek() {
                    return this.deque.peekFirst();
                }
                /**
                 *
                 * @return {*}
                 */
                poll() {
                    return this.deque.pollFirst();
                }
                /**
                 *
                 * @return {number}
                 */
                size() {
                    return this.deque.size();
                }
            }
            Collections.LifoQueue = LifoQueue;
            LifoQueue["__class"] = "java.util.Collections.LifoQueue";
            LifoQueue["__interfaces"] = ["java.util.Collection", "java.util.Queue", "java.lang.Iterable", "java.io.Serializable"];
            class EmptyList extends java.util.AbstractList {
                constructor() {
                    super();
                }
                /**
                 *
                 * @param {*} object
                 * @return {boolean}
                 */
                contains(object) {
                    return false;
                }
                /**
                 *
                 * @param {number} location
                 * @return {*}
                 */
                get(location) {
                    javaemul.internal.InternalPreconditions.checkElementIndex(location, 0);
                    return null;
                }
                /**
                 *
                 * @return {*}
                 */
                iterator() {
                    return Collections.emptyIterator();
                }
                /**
                 *
                 * @param {number} from
                 * @return {*}
                 */
                listIterator(from) {
                    if (((typeof from === 'number') || from === null)) {
                        super.listIterator(from);
                    }
                    else if (from === undefined) {
                        return this.listIterator$();
                    }
                    else
                        throw new Error('invalid overload');
                }
                listIterator$() {
                    return Collections.emptyListIterator();
                }
                /**
                 *
                 * @return {number}
                 */
                size() {
                    return 0;
                }
            }
            Collections.EmptyList = EmptyList;
            EmptyList["__class"] = "java.util.Collections.EmptyList";
            EmptyList["__interfaces"] = ["java.util.RandomAccess", "java.util.List", "java.util.Collection", "java.lang.Iterable", "java.io.Serializable"];
            class EmptyListIterator {
                constructor() {
                }
                forEachRemaining(consumer) {
                    javaemul.internal.InternalPreconditions.checkNotNull((consumer));
                    while ((this.hasNext())) {
                        {
                            (target => (typeof target === 'function') ? target(this.next()) : target.accept(this.next()))(consumer);
                        }
                    }
                    ;
                }
                static INSTANCE_$LI$() { if (EmptyListIterator.INSTANCE == null)
                    EmptyListIterator.INSTANCE = new Collections.EmptyListIterator(); return EmptyListIterator.INSTANCE; }
                ;
                /**
                 *
                 * @param {*} o
                 */
                add(o) {
                    throw new java.lang.UnsupportedOperationException();
                }
                /**
                 *
                 * @return {boolean}
                 */
                hasNext() {
                    return false;
                }
                /**
                 *
                 * @return {boolean}
                 */
                hasPrevious() {
                    return false;
                }
                /**
                 *
                 * @return {*}
                 */
                next() {
                    throw new java.util.NoSuchElementException();
                }
                /**
                 *
                 * @return {number}
                 */
                nextIndex() {
                    return 0;
                }
                /**
                 *
                 * @return {*}
                 */
                previous() {
                    throw new java.util.NoSuchElementException();
                }
                /**
                 *
                 * @return {number}
                 */
                previousIndex() {
                    return -1;
                }
                /**
                 *
                 */
                remove() {
                    throw new java.lang.IllegalStateException();
                }
                /**
                 *
                 * @param {*} o
                 */
                set(o) {
                    throw new java.lang.IllegalStateException();
                }
            }
            Collections.EmptyListIterator = EmptyListIterator;
            EmptyListIterator["__class"] = "java.util.Collections.EmptyListIterator";
            EmptyListIterator["__interfaces"] = ["java.util.Iterator", "java.util.ListIterator"];
            class EmptySet extends java.util.AbstractSet {
                constructor() {
                    super();
                }
                /**
                 *
                 * @param {*} object
                 * @return {boolean}
                 */
                contains(object) {
                    return false;
                }
                /**
                 *
                 * @return {*}
                 */
                iterator() {
                    return Collections.emptyIterator();
                }
                /**
                 *
                 * @return {number}
                 */
                size() {
                    return 0;
                }
            }
            Collections.EmptySet = EmptySet;
            EmptySet["__class"] = "java.util.Collections.EmptySet";
            EmptySet["__interfaces"] = ["java.util.Collection", "java.util.Set", "java.lang.Iterable", "java.io.Serializable"];
            class EmptyMap extends java.util.AbstractMap {
                constructor() {
                    super();
                }
                /**
                 *
                 * @param {*} key
                 * @return {boolean}
                 */
                containsKey(key) {
                    return false;
                }
                /**
                 *
                 * @param {*} value
                 * @return {boolean}
                 */
                containsValue(value) {
                    return false;
                }
                /**
                 *
                 * @return {*}
                 */
                entrySet() {
                    return java.util.Collections.EMPTY_SET_$LI$();
                }
                /**
                 *
                 * @param {*} key
                 * @return {*}
                 */
                get(key) {
                    return null;
                }
                /**
                 *
                 * @return {*}
                 */
                keySet() {
                    return java.util.Collections.EMPTY_SET_$LI$();
                }
                /**
                 *
                 * @return {number}
                 */
                size() {
                    return 0;
                }
                /**
                 *
                 * @return {*}
                 */
                values() {
                    return java.util.Collections.EMPTY_LIST_$LI$();
                }
            }
            Collections.EmptyMap = EmptyMap;
            EmptyMap["__class"] = "java.util.Collections.EmptyMap";
            EmptyMap["__interfaces"] = ["java.util.Map", "java.io.Serializable"];
            class ReverseComparator {
                constructor() {
                }
                static INSTANCE_$LI$() { if (ReverseComparator.INSTANCE == null)
                    ReverseComparator.INSTANCE = new Collections.ReverseComparator(); return ReverseComparator.INSTANCE; }
                ;
                compare$java_lang_Comparable$java_lang_Comparable(o1, o2) {
                    return o2.compareTo(o1);
                }
                /**
                 *
                 * @param {*} o1
                 * @param {*} o2
                 * @return {number}
                 */
                compare(o1, o2) {
                    if (((o1 != null && (o1["__interfaces"] != null && o1["__interfaces"].indexOf("java.lang.Comparable") >= 0 || o1.constructor != null && o1.constructor["__interfaces"] != null && o1.constructor["__interfaces"].indexOf("java.lang.Comparable") >= 0)) || o1 === null) && ((o2 != null && (o2["__interfaces"] != null && o2["__interfaces"].indexOf("java.lang.Comparable") >= 0 || o2.constructor != null && o2.constructor["__interfaces"] != null && o2.constructor["__interfaces"].indexOf("java.lang.Comparable") >= 0)) || o2 === null)) {
                        return this.compare$java_lang_Comparable$java_lang_Comparable(o1, o2);
                    }
                    else
                        throw new Error('invalid overload');
                }
            }
            Collections.ReverseComparator = ReverseComparator;
            ReverseComparator["__class"] = "java.util.Collections.ReverseComparator";
            ReverseComparator["__interfaces"] = ["java.util.Comparator"];
            class SetFromMap extends java.util.AbstractSet {
                constructor(map) {
                    super();
                    if (this.backingMap === undefined)
                        this.backingMap = null;
                    if (this.__keySet === undefined)
                        this.__keySet = null;
                    this.backingMap = map;
                }
                /**
                 *
                 * @param {*} e
                 * @return {boolean}
                 */
                add(e) {
                    return this.backingMap.put(e, javaemul.internal.BooleanHelper.TRUE) == null;
                }
                /**
                 *
                 */
                clear() {
                    this.backingMap.clear();
                }
                /**
                 *
                 * @param {*} o
                 * @return {boolean}
                 */
                contains(o) {
                    return this.backingMap.containsKey(o);
                }
                /**
                 *
                 * @param {*} o
                 * @return {boolean}
                 */
                equals(o) {
                    return o === this || ((o1, o2) => { if (o1 && o1.equals) {
                        return o1.equals(o2);
                    }
                    else {
                        return o1 === o2;
                    } })(this.keySet(), o);
                }
                /**
                 *
                 * @return {number}
                 */
                hashCode() {
                    return ((o) => { if (o.hashCode) {
                        return o.hashCode();
                    }
                    else {
                        return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                    } })(this.keySet());
                }
                /**
                 *
                 * @return {*}
                 */
                iterator() {
                    return this.keySet().iterator();
                }
                /**
                 *
                 * @param {*} o
                 * @return {boolean}
                 */
                remove(o) {
                    return this.backingMap.remove(o) != null;
                }
                /**
                 *
                 * @return {number}
                 */
                size() {
                    return this.keySet().size();
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    return this.keySet().toString();
                }
                /**
                 * Lazy initialize keySet to avoid NPE after deserialization.
                 * @return {*}
                 * @private
                 */
                keySet() {
                    if (this.__keySet == null) {
                        this.__keySet = this.backingMap.keySet();
                    }
                    return this.__keySet;
                }
            }
            Collections.SetFromMap = SetFromMap;
            SetFromMap["__class"] = "java.util.Collections.SetFromMap";
            SetFromMap["__interfaces"] = ["java.util.Collection", "java.util.Set", "java.lang.Iterable", "java.io.Serializable"];
            class SingletonList extends java.util.AbstractList {
                constructor(element) {
                    super();
                    if (this.element === undefined)
                        this.element = null;
                    this.element = element;
                }
                /**
                 *
                 * @param {*} item
                 * @return {boolean}
                 */
                contains(item) {
                    return java.util.Objects.equals(this.element, item);
                }
                /**
                 *
                 * @param {number} index
                 * @return {*}
                 */
                get(index) {
                    javaemul.internal.InternalPreconditions.checkElementIndex(index, 1);
                    return this.element;
                }
                /**
                 *
                 * @return {number}
                 */
                size() {
                    return 1;
                }
            }
            Collections.SingletonList = SingletonList;
            SingletonList["__class"] = "java.util.Collections.SingletonList";
            SingletonList["__interfaces"] = ["java.util.List", "java.util.Collection", "java.lang.Iterable", "java.io.Serializable"];
            class UnmodifiableCollection {
                constructor(coll) {
                    if (this.coll === undefined)
                        this.coll = null;
                    this.coll = coll;
                }
                stream() {
                    return (new javaemul.internal.stream.StreamHelper(this));
                }
                forEach(action) {
                    javaemul.internal.InternalPreconditions.checkNotNull((action));
                    for (let index179 = this.iterator(); index179.hasNext();) {
                        let t = index179.next();
                        {
                            (target => (typeof target === 'function') ? target(t) : target.accept(t))(action);
                        }
                    }
                }
                removeIf(filter) {
                    javaemul.internal.InternalPreconditions.checkNotNull((filter));
                    let removed = false;
                    for (let it = this.iterator(); it.hasNext();) {
                        {
                            if ((target => (typeof target === 'function') ? target(it.next()) : target.test(it.next()))(filter)) {
                                it.remove();
                                removed = true;
                            }
                        }
                        ;
                    }
                    return removed;
                }
                /**
                 *
                 * @param {*} o
                 * @return {boolean}
                 */
                add(o) {
                    throw new java.lang.UnsupportedOperationException();
                }
                /**
                 *
                 * @param {*} c
                 * @return {boolean}
                 */
                addAll(c) {
                    throw new java.lang.UnsupportedOperationException();
                }
                /**
                 *
                 */
                clear() {
                    throw new java.lang.UnsupportedOperationException();
                }
                /**
                 *
                 * @param {*} o
                 * @return {boolean}
                 */
                contains(o) {
                    return this.coll.contains(o);
                }
                /**
                 *
                 * @param {*} c
                 * @return {boolean}
                 */
                containsAll(c) {
                    return this.coll.containsAll(c);
                }
                /**
                 *
                 * @return {boolean}
                 */
                isEmpty() {
                    return this.coll.isEmpty();
                }
                /**
                 *
                 * @return {*}
                 */
                iterator() {
                    return (new Collections.UnmodifiableCollectionIterator(this.coll.iterator()));
                }
                /**
                 *
                 * @param {*} o
                 * @return {boolean}
                 */
                remove(o) {
                    throw new java.lang.UnsupportedOperationException();
                }
                /**
                 *
                 * @param {*} c
                 * @return {boolean}
                 */
                removeAll(c) {
                    throw new java.lang.UnsupportedOperationException();
                }
                /**
                 *
                 * @param {*} c
                 * @return {boolean}
                 */
                retainAll(c) {
                    throw new java.lang.UnsupportedOperationException();
                }
                /**
                 *
                 * @return {number}
                 */
                size() {
                    return this.coll.size();
                }
                toArray$() {
                    return this.coll.toArray();
                }
                toArray$java_lang_Object_A(a) {
                    return this.coll['toArray$java_lang_Object_A'](a);
                }
                /**
                 *
                 * @param {Array} a
                 * @return {Array}
                 */
                toArray(a) {
                    if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (a[0] != null))) || a === null)) {
                        return this.toArray$java_lang_Object_A(a);
                    }
                    else if (a === undefined) {
                        return this.toArray$();
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    return this.coll.toString();
                }
            }
            Collections.UnmodifiableCollection = UnmodifiableCollection;
            UnmodifiableCollection["__class"] = "java.util.Collections.UnmodifiableCollection";
            UnmodifiableCollection["__interfaces"] = ["java.util.Collection", "java.lang.Iterable"];
            class UnmodifiableCollectionIterator {
                constructor(it) {
                    if (this.it === undefined)
                        this.it = null;
                    this.it = it;
                }
                forEachRemaining(consumer) {
                    javaemul.internal.InternalPreconditions.checkNotNull((consumer));
                    while ((this.hasNext())) {
                        {
                            (target => (typeof target === 'function') ? target(this.next()) : target.accept(this.next()))(consumer);
                        }
                    }
                    ;
                }
                /**
                 *
                 * @return {boolean}
                 */
                hasNext() {
                    return this.it.hasNext();
                }
                /**
                 *
                 * @return {*}
                 */
                next() {
                    return this.it.next();
                }
                /**
                 *
                 */
                remove() {
                    throw new java.lang.UnsupportedOperationException();
                }
            }
            Collections.UnmodifiableCollectionIterator = UnmodifiableCollectionIterator;
            UnmodifiableCollectionIterator["__class"] = "java.util.Collections.UnmodifiableCollectionIterator";
            UnmodifiableCollectionIterator["__interfaces"] = ["java.util.Iterator"];
            class RandomHolder {
                constructor() {
                }
                static rnd_$LI$() { if (RandomHolder.rnd == null)
                    RandomHolder.rnd = new java.util.Random(); return RandomHolder.rnd; }
                ;
            }
            Collections.RandomHolder = RandomHolder;
            RandomHolder["__class"] = "java.util.Collections.RandomHolder";
            class UnmodifiableList extends Collections.UnmodifiableCollection {
                constructor(list) {
                    super(list);
                    if (this.list === undefined)
                        this.list = null;
                    this.list = list;
                }
                stream() {
                    return (new javaemul.internal.stream.StreamHelper(this));
                }
                forEach(action) {
                    javaemul.internal.InternalPreconditions.checkNotNull((action));
                    for (let index180 = this.iterator(); index180.hasNext();) {
                        let t = index180.next();
                        {
                            (target => (typeof target === 'function') ? target(t) : target.accept(t))(action);
                        }
                    }
                }
                removeIf(filter) {
                    javaemul.internal.InternalPreconditions.checkNotNull((filter));
                    let removed = false;
                    for (let it = this.iterator(); it.hasNext();) {
                        {
                            if ((target => (typeof target === 'function') ? target(it.next()) : target.test(it.next()))(filter)) {
                                it.remove();
                                removed = true;
                            }
                        }
                        ;
                    }
                    return removed;
                }
                add$int$java_lang_Object(index, element) {
                    throw new java.lang.UnsupportedOperationException();
                }
                /**
                 *
                 * @param {number} index
                 * @param {*} element
                 */
                add(index, element) {
                    if (((typeof index === 'number') || index === null) && ((element != null) || element === null)) {
                        return this.add$int$java_lang_Object(index, element);
                    }
                    else if (((index != null) || index === null) && element === undefined) {
                        super.add(index);
                    }
                    else
                        throw new Error('invalid overload');
                }
                addAll$int$java_util_Collection(index, c) {
                    throw new java.lang.UnsupportedOperationException();
                }
                /**
                 *
                 * @param {number} index
                 * @param {*} c
                 * @return {boolean}
                 */
                addAll(index, c) {
                    if (((typeof index === 'number') || index === null) && ((c != null && (c["__interfaces"] != null && c["__interfaces"].indexOf("java.util.Collection") >= 0 || c.constructor != null && c.constructor["__interfaces"] != null && c.constructor["__interfaces"].indexOf("java.util.Collection") >= 0)) || c === null)) {
                        return this.addAll$int$java_util_Collection(index, c);
                    }
                    else if (((index != null && (index["__interfaces"] != null && index["__interfaces"].indexOf("java.util.Collection") >= 0 || index.constructor != null && index.constructor["__interfaces"] != null && index.constructor["__interfaces"].indexOf("java.util.Collection") >= 0)) || index === null) && c === undefined) {
                        super.addAll(index);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 *
                 * @param {*} o
                 * @return {boolean}
                 */
                equals(o) {
                    return ((o1, o2) => { if (o1 && o1.equals) {
                        return o1.equals(o2);
                    }
                    else {
                        return o1 === o2;
                    } })(this.list, o);
                }
                /**
                 *
                 * @param {number} index
                 * @return {*}
                 */
                get(index) {
                    return this.list.get(index);
                }
                /**
                 *
                 * @return {number}
                 */
                hashCode() {
                    return ((o) => { if (o.hashCode) {
                        return o.hashCode();
                    }
                    else {
                        return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                    } })(this.list);
                }
                /**
                 *
                 * @param {*} o
                 * @return {number}
                 */
                indexOf(o) {
                    return this.list.indexOf(o);
                }
                /**
                 *
                 * @return {boolean}
                 */
                isEmpty() {
                    return this.list.isEmpty();
                }
                /**
                 *
                 * @param {*} o
                 * @return {number}
                 */
                lastIndexOf(o) {
                    return this.list.lastIndexOf(o);
                }
                listIterator$() {
                    return this.listIterator$int(0);
                }
                listIterator$int(from) {
                    return (new Collections.UnmodifiableListIterator(this.list['listIterator$int'](from)));
                }
                /**
                 *
                 * @param {number} from
                 * @return {*}
                 */
                listIterator(from) {
                    if (((typeof from === 'number') || from === null)) {
                        return this.listIterator$int(from);
                    }
                    else if (from === undefined) {
                        return this.listIterator$();
                    }
                    else
                        throw new Error('invalid overload');
                }
                remove$int(index) {
                    throw new java.lang.UnsupportedOperationException();
                }
                /**
                 *
                 * @param {number} index
                 * @return {*}
                 */
                remove(index) {
                    if (((typeof index === 'number') || index === null)) {
                        return this.remove$int(index);
                    }
                    else if (((index != null) || index === null)) {
                        super.remove(index);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 *
                 * @param {number} index
                 * @param {*} element
                 * @return {*}
                 */
                set(index, element) {
                    throw new java.lang.UnsupportedOperationException();
                }
                /**
                 *
                 * @param {number} fromIndex
                 * @param {number} toIndex
                 * @return {*}
                 */
                subList(fromIndex, toIndex) {
                    return (new Collections.UnmodifiableList(this.list.subList(fromIndex, toIndex)));
                }
            }
            Collections.UnmodifiableList = UnmodifiableList;
            UnmodifiableList["__class"] = "java.util.Collections.UnmodifiableList";
            UnmodifiableList["__interfaces"] = ["java.util.List", "java.util.Collection", "java.lang.Iterable"];
            class UnmodifiableSet extends Collections.UnmodifiableCollection {
                constructor(set) {
                    super(set);
                }
                stream() {
                    return (new javaemul.internal.stream.StreamHelper(this));
                }
                forEach(action) {
                    javaemul.internal.InternalPreconditions.checkNotNull((action));
                    for (let index181 = this.iterator(); index181.hasNext();) {
                        let t = index181.next();
                        {
                            (target => (typeof target === 'function') ? target(t) : target.accept(t))(action);
                        }
                    }
                }
                removeIf(filter) {
                    javaemul.internal.InternalPreconditions.checkNotNull((filter));
                    let removed = false;
                    for (let it = this.iterator(); it.hasNext();) {
                        {
                            if ((target => (typeof target === 'function') ? target(it.next()) : target.test(it.next()))(filter)) {
                                it.remove();
                                removed = true;
                            }
                        }
                        ;
                    }
                    return removed;
                }
                /**
                 *
                 * @param {*} o
                 * @return {boolean}
                 */
                equals(o) {
                    return ((o1, o2) => { if (o1 && o1.equals) {
                        return o1.equals(o2);
                    }
                    else {
                        return o1 === o2;
                    } })(this.coll, o);
                }
                /**
                 *
                 * @return {number}
                 */
                hashCode() {
                    return ((o) => { if (o.hashCode) {
                        return o.hashCode();
                    }
                    else {
                        return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                    } })(this.coll);
                }
            }
            Collections.UnmodifiableSet = UnmodifiableSet;
            UnmodifiableSet["__class"] = "java.util.Collections.UnmodifiableSet";
            UnmodifiableSet["__interfaces"] = ["java.util.Collection", "java.util.Set", "java.lang.Iterable"];
            class UnmodifiableListIterator extends Collections.UnmodifiableCollectionIterator {
                constructor(lit) {
                    super(lit);
                    if (this.lit === undefined)
                        this.lit = null;
                    this.lit = lit;
                }
                forEachRemaining(consumer) {
                    javaemul.internal.InternalPreconditions.checkNotNull((consumer));
                    while ((this.hasNext())) {
                        {
                            (target => (typeof target === 'function') ? target(this.next()) : target.accept(this.next()))(consumer);
                        }
                    }
                    ;
                }
                /**
                 *
                 * @param {*} o
                 */
                add(o) {
                    throw new java.lang.UnsupportedOperationException();
                }
                /**
                 *
                 * @return {boolean}
                 */
                hasPrevious() {
                    return this.lit.hasPrevious();
                }
                /**
                 *
                 * @return {number}
                 */
                nextIndex() {
                    return this.lit.nextIndex();
                }
                /**
                 *
                 * @return {*}
                 */
                previous() {
                    return this.lit.previous();
                }
                /**
                 *
                 * @return {number}
                 */
                previousIndex() {
                    return this.lit.previousIndex();
                }
                /**
                 *
                 * @param {*} o
                 */
                set(o) {
                    throw new java.lang.UnsupportedOperationException();
                }
            }
            Collections.UnmodifiableListIterator = UnmodifiableListIterator;
            UnmodifiableListIterator["__class"] = "java.util.Collections.UnmodifiableListIterator";
            UnmodifiableListIterator["__interfaces"] = ["java.util.Iterator", "java.util.ListIterator"];
            class UnmodifiableRandomAccessList extends Collections.UnmodifiableList {
                constructor(list) {
                    super(list);
                }
            }
            Collections.UnmodifiableRandomAccessList = UnmodifiableRandomAccessList;
            UnmodifiableRandomAccessList["__class"] = "java.util.Collections.UnmodifiableRandomAccessList";
            UnmodifiableRandomAccessList["__interfaces"] = ["java.util.RandomAccess", "java.util.List", "java.util.Collection", "java.lang.Iterable"];
            class UnmodifiableMap {
                constructor(map) {
                    if (this.__entrySet === undefined)
                        this.__entrySet = null;
                    if (this.__keySet === undefined)
                        this.__keySet = null;
                    if (this.map === undefined)
                        this.map = null;
                    if (this.__values === undefined)
                        this.__values = null;
                    this.map = map;
                }
                merge(key, value, map) {
                    let old = this.get(key);
                    let next = (old == null) ? value : (target => (typeof target === 'function') ? target(old, value) : target.apply(old, value))(map);
                    if (next == null) {
                        this.remove(key);
                    }
                    else {
                        this.put(key, next);
                    }
                    return next;
                }
                computeIfAbsent(key, mappingFunction) {
                    let result;
                    if ((result = this.get(key)) == null) {
                        result = (target => (typeof target === 'function') ? target(key) : target.apply(key))(mappingFunction);
                        if (result != null)
                            this.put(key, result);
                    }
                    return result;
                }
                /**
                 *
                 */
                clear() {
                    throw new java.lang.UnsupportedOperationException();
                }
                /**
                 *
                 * @param {*} key
                 * @return {boolean}
                 */
                containsKey(key) {
                    return this.map.containsKey(key);
                }
                /**
                 *
                 * @param {*} val
                 * @return {boolean}
                 */
                containsValue(val) {
                    return this.map.containsValue(val);
                }
                /**
                 *
                 * @return {*}
                 */
                entrySet() {
                    if (this.__entrySet == null) {
                        this.__entrySet = (new UnmodifiableMap.UnmodifiableEntrySet(this.map.entrySet()));
                    }
                    return this.__entrySet;
                }
                /**
                 *
                 * @param {*} o
                 * @return {boolean}
                 */
                equals(o) {
                    return ((o1, o2) => { if (o1 && o1.equals) {
                        return o1.equals(o2);
                    }
                    else {
                        return o1 === o2;
                    } })(this.map, o);
                }
                /**
                 *
                 * @param {*} key
                 * @return {*}
                 */
                get(key) {
                    return this.map.get(key);
                }
                /**
                 *
                 * @return {number}
                 */
                hashCode() {
                    return ((o) => { if (o.hashCode) {
                        return o.hashCode();
                    }
                    else {
                        return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                    } })(this.map);
                }
                /**
                 *
                 * @return {boolean}
                 */
                isEmpty() {
                    return this.map.isEmpty();
                }
                /**
                 *
                 * @return {*}
                 */
                keySet() {
                    if (this.__keySet == null) {
                        this.__keySet = (new Collections.UnmodifiableSet(this.map.keySet()));
                    }
                    return this.__keySet;
                }
                /**
                 *
                 * @param {*} key
                 * @param {*} value
                 * @return {*}
                 */
                put(key, value) {
                    throw new java.lang.UnsupportedOperationException();
                }
                /**
                 *
                 * @param {*} t
                 */
                putAll(t) {
                    throw new java.lang.UnsupportedOperationException();
                }
                /**
                 *
                 * @param {*} key
                 * @return {*}
                 */
                remove(key) {
                    throw new java.lang.UnsupportedOperationException();
                }
                /**
                 *
                 * @return {number}
                 */
                size() {
                    return this.map.size();
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    return this.map.toString();
                }
                /**
                 *
                 * @return {*}
                 */
                values() {
                    if (this.__values == null) {
                        this.__values = (new Collections.UnmodifiableCollection(this.map.values()));
                    }
                    return this.__values;
                }
            }
            Collections.UnmodifiableMap = UnmodifiableMap;
            UnmodifiableMap["__class"] = "java.util.Collections.UnmodifiableMap";
            UnmodifiableMap["__interfaces"] = ["java.util.Map"];
            (function (UnmodifiableMap) {
                class UnmodifiableEntrySet extends Collections.UnmodifiableSet {
                    constructor(s) {
                        super(s);
                    }
                    /**
                     *
                     * @param {*} o
                     * @return {boolean}
                     */
                    contains(o) {
                        return this.coll.contains(o);
                    }
                    /**
                     *
                     * @param {*} o
                     * @return {boolean}
                     */
                    containsAll(o) {
                        return this.coll.containsAll(o);
                    }
                    /**
                     *
                     * @return {*}
                     */
                    iterator() {
                        let it = this.coll.iterator();
                        return new UnmodifiableEntrySet.UnmodifiableEntrySet$0(this, it);
                    }
                    toArray$() {
                        let array = super.toArray();
                        this.wrap(array, array.length);
                        return array;
                    }
                    toArray$java_lang_Object_A(a) {
                        let result = super.toArray$java_lang_Object_A(a);
                        this.wrap(result, this.coll.size());
                        return result;
                    }
                    /**
                     *
                     * @param {Array} a
                     * @return {Array}
                     */
                    toArray(a) {
                        if (((a != null && a instanceof Array && (a.length == 0 || a[0] == null || (a[0] != null))) || a === null)) {
                            return this.toArray$java_lang_Object_A(a);
                        }
                        else if (a === undefined) {
                            return this.toArray$();
                        }
                        else
                            throw new Error('invalid overload');
                    }
                    /**
                     * Wrap an array of Map.Entries as UnmodifiableEntries.
                     *
                     * @param {Array} array array to wrap
                     * @param {number} size number of entries to wrap
                     * @private
                     */
                    wrap(array, size) {
                        for (let i = 0; i < size; ++i) {
                            {
                                array[i] = (new UnmodifiableEntrySet.UnmodifiableEntry(array[i]));
                            }
                            ;
                        }
                    }
                }
                UnmodifiableMap.UnmodifiableEntrySet = UnmodifiableEntrySet;
                UnmodifiableEntrySet["__class"] = "java.util.Collections.UnmodifiableMap.UnmodifiableEntrySet";
                UnmodifiableEntrySet["__interfaces"] = ["java.util.Collection", "java.util.Set", "java.lang.Iterable"];
                (function (UnmodifiableEntrySet) {
                    class UnmodifiableEntry {
                        constructor(entry) {
                            if (this.entry === undefined)
                                this.entry = null;
                            this.entry = entry;
                        }
                        /**
                         *
                         * @param {*} o
                         * @return {boolean}
                         */
                        equals(o) {
                            return ((o1, o2) => { if (o1 && o1.equals) {
                                return o1.equals(o2);
                            }
                            else {
                                return o1 === o2;
                            } })(this.entry, o);
                        }
                        /**
                         *
                         * @return {*}
                         */
                        getKey() {
                            return this.entry.getKey();
                        }
                        /**
                         *
                         * @return {*}
                         */
                        getValue() {
                            return this.entry.getValue();
                        }
                        /**
                         *
                         * @return {number}
                         */
                        hashCode() {
                            return ((o) => { if (o.hashCode) {
                                return o.hashCode();
                            }
                            else {
                                return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                            } })(this.entry);
                        }
                        /**
                         *
                         * @param {*} value
                         * @return {*}
                         */
                        setValue(value) {
                            throw new java.lang.UnsupportedOperationException();
                        }
                        /**
                         *
                         * @return {string}
                         */
                        toString() {
                            return this.entry.toString();
                        }
                    }
                    UnmodifiableEntrySet.UnmodifiableEntry = UnmodifiableEntry;
                    UnmodifiableEntry["__class"] = "java.util.Collections.UnmodifiableMap.UnmodifiableEntrySet.UnmodifiableEntry";
                    UnmodifiableEntry["__interfaces"] = ["java.util.Map.Entry"];
                    class UnmodifiableEntrySet$0 {
                        constructor(__parent, it) {
                            this.it = it;
                            this.__parent = __parent;
                        }
                        forEachRemaining(consumer) {
                            javaemul.internal.InternalPreconditions.checkNotNull((consumer));
                            while ((this.hasNext())) {
                                {
                                    (target => (typeof target === 'function') ? target(this.next()) : target.accept(this.next()))(consumer);
                                }
                            }
                            ;
                        }
                        /**
                         *
                         * @return {boolean}
                         */
                        hasNext() {
                            return this.it.hasNext();
                        }
                        /**
                         *
                         * @return {*}
                         */
                        next() {
                            return (new UnmodifiableEntrySet.UnmodifiableEntry(this.it.next()));
                        }
                        /**
                         *
                         */
                        remove() {
                            throw new java.lang.UnsupportedOperationException();
                        }
                    }
                    UnmodifiableEntrySet.UnmodifiableEntrySet$0 = UnmodifiableEntrySet$0;
                    UnmodifiableEntrySet$0["__interfaces"] = ["java.util.Iterator"];
                })(UnmodifiableEntrySet = UnmodifiableMap.UnmodifiableEntrySet || (UnmodifiableMap.UnmodifiableEntrySet = {}));
            })(UnmodifiableMap = Collections.UnmodifiableMap || (Collections.UnmodifiableMap = {}));
            class UnmodifiableSortedSet extends Collections.UnmodifiableSet {
                constructor(sortedSet) {
                    super(sortedSet);
                    if (this.sortedSet === undefined)
                        this.sortedSet = null;
                    this.sortedSet = sortedSet;
                }
                stream() {
                    return (new javaemul.internal.stream.StreamHelper(this));
                }
                forEach(action) {
                    javaemul.internal.InternalPreconditions.checkNotNull((action));
                    for (let index182 = this.iterator(); index182.hasNext();) {
                        let t = index182.next();
                        {
                            (target => (typeof target === 'function') ? target(t) : target.accept(t))(action);
                        }
                    }
                }
                removeIf(filter) {
                    javaemul.internal.InternalPreconditions.checkNotNull((filter));
                    let removed = false;
                    for (let it = this.iterator(); it.hasNext();) {
                        {
                            if ((target => (typeof target === 'function') ? target(it.next()) : target.test(it.next()))(filter)) {
                                it.remove();
                                removed = true;
                            }
                        }
                        ;
                    }
                    return removed;
                }
                /**
                 *
                 * @return {*}
                 */
                comparator() {
                    return this.sortedSet.comparator();
                }
                /**
                 *
                 * @param {*} o
                 * @return {boolean}
                 */
                equals(o) {
                    return ((o1, o2) => { if (o1 && o1.equals) {
                        return o1.equals(o2);
                    }
                    else {
                        return o1 === o2;
                    } })(this.sortedSet, o);
                }
                /**
                 *
                 * @return {*}
                 */
                first() {
                    return this.sortedSet.first();
                }
                /**
                 *
                 * @return {number}
                 */
                hashCode() {
                    return ((o) => { if (o.hashCode) {
                        return o.hashCode();
                    }
                    else {
                        return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                    } })(this.sortedSet);
                }
                /**
                 *
                 * @param {*} toElement
                 * @return {*}
                 */
                headSet(toElement) {
                    return (new Collections.UnmodifiableSortedSet(this.sortedSet.headSet(toElement)));
                }
                /**
                 *
                 * @return {*}
                 */
                last() {
                    return this.sortedSet.last();
                }
                /**
                 *
                 * @param {*} fromElement
                 * @param {*} toElement
                 * @return {*}
                 */
                subSet(fromElement, toElement) {
                    return (new Collections.UnmodifiableSortedSet(this.sortedSet.subSet(fromElement, toElement)));
                }
                /**
                 *
                 * @param {*} fromElement
                 * @return {*}
                 */
                tailSet(fromElement) {
                    return (new Collections.UnmodifiableSortedSet(this.sortedSet.tailSet(fromElement)));
                }
            }
            Collections.UnmodifiableSortedSet = UnmodifiableSortedSet;
            UnmodifiableSortedSet["__class"] = "java.util.Collections.UnmodifiableSortedSet";
            UnmodifiableSortedSet["__interfaces"] = ["java.util.SortedSet", "java.util.Collection", "java.util.Set", "java.lang.Iterable"];
            class UnmodifiableSortedMap extends Collections.UnmodifiableMap {
                constructor(sortedMap) {
                    super(sortedMap);
                    if (this.sortedMap === undefined)
                        this.sortedMap = null;
                    this.sortedMap = sortedMap;
                }
                merge(key, value, map) {
                    let old = this.get(key);
                    let next = (old == null) ? value : (target => (typeof target === 'function') ? target(old, value) : target.apply(old, value))(map);
                    if (next == null) {
                        this.remove(key);
                    }
                    else {
                        this.put(key, next);
                    }
                    return next;
                }
                computeIfAbsent(key, mappingFunction) {
                    let result;
                    if ((result = this.get(key)) == null) {
                        result = (target => (typeof target === 'function') ? target(key) : target.apply(key))(mappingFunction);
                        if (result != null)
                            this.put(key, result);
                    }
                    return result;
                }
                /**
                 *
                 * @return {*}
                 */
                comparator() {
                    return this.sortedMap.comparator();
                }
                /**
                 *
                 * @param {*} o
                 * @return {boolean}
                 */
                equals(o) {
                    return ((o1, o2) => { if (o1 && o1.equals) {
                        return o1.equals(o2);
                    }
                    else {
                        return o1 === o2;
                    } })(this.sortedMap, o);
                }
                /**
                 *
                 * @return {*}
                 */
                firstKey() {
                    return this.sortedMap.firstKey();
                }
                /**
                 *
                 * @return {number}
                 */
                hashCode() {
                    return ((o) => { if (o.hashCode) {
                        return o.hashCode();
                    }
                    else {
                        return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                    } })(this.sortedMap);
                }
                /**
                 *
                 * @param {*} toKey
                 * @return {*}
                 */
                headMap(toKey) {
                    return (new Collections.UnmodifiableSortedMap(this.sortedMap.headMap(toKey)));
                }
                /**
                 *
                 * @return {*}
                 */
                lastKey() {
                    return this.sortedMap.lastKey();
                }
                /**
                 *
                 * @param {*} fromKey
                 * @param {*} toKey
                 * @return {*}
                 */
                subMap(fromKey, toKey) {
                    return (new Collections.UnmodifiableSortedMap(this.sortedMap.subMap(fromKey, toKey)));
                }
                /**
                 *
                 * @param {*} fromKey
                 * @return {*}
                 */
                tailMap(fromKey) {
                    return (new Collections.UnmodifiableSortedMap(this.sortedMap.tailMap(fromKey)));
                }
            }
            Collections.UnmodifiableSortedMap = UnmodifiableSortedMap;
            UnmodifiableSortedMap["__class"] = "java.util.Collections.UnmodifiableSortedMap";
            UnmodifiableSortedMap["__interfaces"] = ["java.util.Map", "java.util.SortedMap"];
            class Collections$0 {
                constructor(it) {
                    this.it = it;
                }
                /**
                 *
                 * @return {boolean}
                 */
                hasMoreElements() {
                    return this.it.hasNext();
                }
                /**
                 *
                 * @return {*}
                 */
                nextElement() {
                    return this.it.next();
                }
            }
            Collections.Collections$0 = Collections$0;
            Collections$0["__interfaces"] = ["java.util.Enumeration"];
            class Collections$1 {
                constructor(cmp) {
                    this.cmp = cmp;
                }
                /**
                 *
                 * @param {*} t1
                 * @param {*} t2
                 * @return {number}
                 */
                compare(t1, t2) {
                    return this.cmp.compare(t2, t1);
                }
            }
            Collections.Collections$1 = Collections$1;
            Collections$1["__interfaces"] = ["java.util.Comparator"];
        })(Collections = util.Collections || (util.Collections = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        /**
         * A {@link java.util.Map} of {@link Enum}s. <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/EnumMap.html">[Sun
         * docs]</a>
         *
         * @param <K> key type
         * @param <V> value type
         * @param {java.lang.Class} type
         * @class
         * @extends java.util.AbstractMap
         */
        class EnumMap extends java.util.AbstractMap {
            constructor(type) {
                if (((type != null && type instanceof java.lang.Class) || type === null)) {
                    let __args = arguments;
                    super();
                    if (this.__keySet === undefined)
                        this.__keySet = null;
                    if (this.__values === undefined)
                        this.__values = null;
                    if (this.__keySet === undefined)
                        this.__keySet = null;
                    if (this.__values === undefined)
                        this.__values = null;
                    (() => {
                        this.init$java_lang_Class(type);
                    })();
                }
                else if (((type != null && type instanceof java.util.EnumMap) || type === null)) {
                    let __args = arguments;
                    let m = __args[0];
                    super();
                    if (this.__keySet === undefined)
                        this.__keySet = null;
                    if (this.__values === undefined)
                        this.__values = null;
                    if (this.__keySet === undefined)
                        this.__keySet = null;
                    if (this.__values === undefined)
                        this.__values = null;
                    (() => {
                        this.init$java_util_EnumMap(m);
                    })();
                }
                else if (((type != null && (type["__interfaces"] != null && type["__interfaces"].indexOf("java.util.Map") >= 0 || type.constructor != null && type.constructor["__interfaces"] != null && type.constructor["__interfaces"].indexOf("java.util.Map") >= 0)) || type === null)) {
                    let __args = arguments;
                    let m = __args[0];
                    super();
                    if (this.__keySet === undefined)
                        this.__keySet = null;
                    if (this.__values === undefined)
                        this.__values = null;
                    if (this.__keySet === undefined)
                        this.__keySet = null;
                    if (this.__values === undefined)
                        this.__values = null;
                    (() => {
                        if (m != null && m instanceof java.util.EnumMap) {
                            this.init$java_util_EnumMap(m);
                        }
                        else {
                            javaemul.internal.InternalPreconditions.checkArgument(!m.isEmpty(), "Specified map is empty");
                            this.init$java_lang_Class(m.keySet().iterator().next().getDeclaringClass());
                            this.putAll(m);
                        }
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             *
             */
            clear() {
                this.__keySet.clear();
                this.__values = (s => { let a = []; while (s-- > 0)
                    a.push(null); return a; })(this.__values.length);
            }
            clone() {
                return (new EnumMap(this));
            }
            /**
             *
             * @param {*} key
             * @return {boolean}
             */
            containsKey(key) {
                return this.__keySet.contains(key);
            }
            /**
             *
             * @param {*} value
             * @return {boolean}
             */
            containsValue(value) {
                for (let index183 = this.__keySet.iterator(); index183.hasNext();) {
                    let key = index183.next();
                    {
                        if (java.util.Objects.equals(value, this.__values[key.ordinal()])) {
                            return true;
                        }
                    }
                }
                return false;
            }
            /**
             *
             * @return {*}
             */
            entrySet() {
                return new EnumMap.EntrySet(this);
            }
            /**
             *
             * @param {*} k
             * @return {*}
             */
            get(k) {
                return this.__keySet.contains(k) ? this.__values[this.asOrdinal(k)] : null;
            }
            put$java_lang_Enum$java_lang_Object(key, value) {
                this.__keySet.add(key);
                return this.set(key.ordinal(), value);
            }
            /**
             *
             * @param {java.lang.Enum} key
             * @param {*} value
             * @return {*}
             */
            put(key, value) {
                if (((key != null) || key === null) && ((value != null) || value === null)) {
                    return this.put$java_lang_Enum$java_lang_Object(key, value);
                }
                else if (((key != null) || key === null) && ((value != null) || value === null)) {
                    super.put(key, value);
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             *
             * @param {*} key
             * @return {*}
             */
            remove(key) {
                return this.__keySet.remove(key) ? this.set(this.asOrdinal(key), null) : null;
            }
            /**
             *
             * @return {number}
             */
            size() {
                return this.__keySet.size();
            }
            /**
             * Returns <code>key</code> as <code>K</code>. Only runtime checks that
             * key is an Enum, not that it's the particular Enum K. Should only be called
             * when you are sure <code>key</code> is of type <code>K</code>.
             * @param {*} key
             * @return {java.lang.Enum}
             * @private
             */
            asKey(key) {
                return key;
            }
            asOrdinal(key) {
                return this.asKey(key).ordinal();
            }
            init$java_lang_Class(type) {
                this.__keySet = java.util.EnumSet.noneOf(type);
                this.__values = (s => { let a = []; while (s-- > 0)
                    a.push(null); return a; })(this.__keySet.capacity());
            }
            init(type) {
                if (((type != null && type instanceof java.lang.Class) || type === null)) {
                    return this.init$java_lang_Class(type);
                }
                else if (((type != null && type instanceof java.util.EnumMap) || type === null)) {
                    return this.init$java_util_EnumMap(type);
                }
                else
                    throw new Error('invalid overload');
            }
            init$java_util_EnumMap(m) {
                this.__keySet = ((o) => { if (o.clone != undefined) {
                    return o.clone();
                }
                else {
                    let clone = Object.create(o);
                    for (let p in o) {
                        if (o.hasOwnProperty(p))
                            clone[p] = o[p];
                    }
                    return clone;
                } })(m.__keySet);
                this.__values = javaemul.internal.ArrayHelper.clone(m.__values, 0, m.__values.length);
            }
            set(ordinal, value) {
                let was = this.__values[ordinal];
                this.__values[ordinal] = value;
                return was;
            }
        }
        util.EnumMap = EnumMap;
        EnumMap["__class"] = "java.util.EnumMap";
        EnumMap["__interfaces"] = ["java.util.Map"];
        (function (EnumMap) {
            class EntrySet extends java.util.AbstractSet {
                constructor(__parent) {
                    super();
                    this.__parent = __parent;
                }
                /**
                 *
                 */
                clear() {
                    this.clear();
                }
                /**
                 *
                 * @param {*} o
                 * @return {boolean}
                 */
                contains(o) {
                    if (o != null && (o["__interfaces"] != null && o["__interfaces"].indexOf("java.util.Map.Entry") >= 0 || o.constructor != null && o.constructor["__interfaces"] != null && o.constructor["__interfaces"].indexOf("java.util.Map.Entry") >= 0)) {
                        return this.__parent.containsEntry(o);
                    }
                    return false;
                }
                /**
                 *
                 * @return {*}
                 */
                iterator() {
                    return new EnumMap.EntrySetIterator(this.__parent);
                }
                /**
                 *
                 * @param {*} entry
                 * @return {boolean}
                 */
                remove(entry) {
                    if (this.contains(entry)) {
                        let key = entry.getKey();
                        this.remove(key);
                        return true;
                    }
                    return false;
                }
                /**
                 *
                 * @return {number}
                 */
                size() {
                    return this.size();
                }
            }
            EnumMap.EntrySet = EntrySet;
            EntrySet["__class"] = "java.util.EnumMap.EntrySet";
            EntrySet["__interfaces"] = ["java.util.Collection", "java.util.Set", "java.lang.Iterable"];
            class EntrySetIterator {
                constructor(__parent) {
                    this.__parent = __parent;
                    this.it = this.__parent.__keySet.iterator();
                    if (this.key === undefined)
                        this.key = null;
                }
                forEachRemaining(consumer) {
                    javaemul.internal.InternalPreconditions.checkNotNull((consumer));
                    while ((this.hasNext())) {
                        {
                            (target => (typeof target === 'function') ? target(this.next()) : target.accept(this.next()))(consumer);
                        }
                    }
                    ;
                }
                /**
                 *
                 * @return {boolean}
                 */
                hasNext() {
                    return this.it.hasNext();
                }
                /**
                 *
                 * @return {*}
                 */
                next() {
                    this.key = this.it.next();
                    return new EnumMap.MapEntry(this.__parent, this.key);
                }
                /**
                 *
                 */
                remove() {
                    javaemul.internal.InternalPreconditions.checkState(this.key != null);
                    this.__parent.remove(this.key);
                    this.key = null;
                }
            }
            EnumMap.EntrySetIterator = EntrySetIterator;
            EntrySetIterator["__class"] = "java.util.EnumMap.EntrySetIterator";
            EntrySetIterator["__interfaces"] = ["java.util.Iterator"];
            class MapEntry extends java.util.AbstractMapEntry {
                constructor(__parent, key) {
                    super();
                    this.__parent = __parent;
                    if (this.key === undefined)
                        this.key = null;
                    this.key = key;
                }
                /**
                 *
                 * @return {java.lang.Enum}
                 */
                getKey() {
                    return this.key;
                }
                /**
                 *
                 * @return {*}
                 */
                getValue() {
                    return this.__parent.__values[this.key.ordinal()];
                }
                /**
                 *
                 * @param {*} value
                 * @return {*}
                 */
                setValue(value) {
                    return this.__parent.set(this.key.ordinal(), value);
                }
            }
            EnumMap.MapEntry = MapEntry;
            MapEntry["__class"] = "java.util.EnumMap.MapEntry";
            MapEntry["__interfaces"] = ["java.util.Map.Entry"];
        })(EnumMap = util.EnumMap || (util.EnumMap = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        /**
         * Hash table and linked-list implementation of the Set interface with
         * predictable iteration order. <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/LinkedHashSet.html">[Sun
         * docs]</a>
         *
         * @param <E> element type.
         * @param {number} ignored
         * @param {number} alsoIgnored
         * @class
         * @extends java.util.HashSet
         */
        class LinkedHashSet extends java.util.HashSet {
            constructor(ignored, alsoIgnored) {
                if (((typeof ignored === 'number') || ignored === null) && ((typeof alsoIgnored === 'number') || alsoIgnored === null)) {
                    let __args = arguments;
                    super((new java.util.LinkedHashMap(ignored, alsoIgnored)));
                }
                else if (((ignored != null && (ignored["__interfaces"] != null && ignored["__interfaces"].indexOf("java.util.Collection") >= 0 || ignored.constructor != null && ignored.constructor["__interfaces"] != null && ignored.constructor["__interfaces"].indexOf("java.util.Collection") >= 0)) || ignored === null) && alsoIgnored === undefined) {
                    let __args = arguments;
                    let c = __args[0];
                    super((new java.util.LinkedHashMap()));
                    (() => {
                        this.addAll(c);
                    })();
                }
                else if (((typeof ignored === 'number') || ignored === null) && alsoIgnored === undefined) {
                    let __args = arguments;
                    super((new java.util.LinkedHashMap(ignored)));
                }
                else if (ignored === undefined && alsoIgnored === undefined) {
                    let __args = arguments;
                    super((new java.util.LinkedHashMap()));
                }
                else
                    throw new Error('invalid overload');
            }
            stream() {
                return (new javaemul.internal.stream.StreamHelper(this));
            }
            forEach(action) {
                javaemul.internal.InternalPreconditions.checkNotNull((action));
                for (let index184 = this.iterator(); index184.hasNext();) {
                    let t = index184.next();
                    {
                        (target => (typeof target === 'function') ? target(t) : target.accept(t))(action);
                    }
                }
            }
            removeIf(filter) {
                javaemul.internal.InternalPreconditions.checkNotNull((filter));
                let removed = false;
                for (let it = this.iterator(); it.hasNext();) {
                    {
                        if ((target => (typeof target === 'function') ? target(it.next()) : target.test(it.next()))(filter)) {
                            it.remove();
                            removed = true;
                        }
                    }
                    ;
                }
                return removed;
            }
            /**
             *
             * @return {*}
             */
            clone() {
                return (new LinkedHashSet(this));
            }
        }
        util.LinkedHashSet = LinkedHashSet;
        LinkedHashSet["__class"] = "java.util.LinkedHashSet";
        LinkedHashSet["__interfaces"] = ["java.lang.Cloneable", "java.util.Collection", "java.util.Set", "java.lang.Iterable", "java.io.Serializable"];
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        /**
         * Implementation of Map interface based on a hash table. <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/HashMap.html">[Sun
         * docs]</a>
         *
         * @param <K> key type
         * @param <V> value type
         * @param {number} ignored
         * @param {number} alsoIgnored
         * @class
         * @extends java.util.AbstractHashMap
         */
        class HashMap extends java.util.AbstractHashMap {
            constructor(ignored, alsoIgnored) {
                if (((typeof ignored === 'number') || ignored === null) && ((typeof alsoIgnored === 'number') || alsoIgnored === null)) {
                    let __args = arguments;
                    super(ignored, alsoIgnored);
                    if (this.exposeKey === undefined)
                        this.exposeKey = null;
                    if (this.exposeValue === undefined)
                        this.exposeValue = null;
                    if (this.exposeKey === undefined)
                        this.exposeKey = null;
                    if (this.exposeValue === undefined)
                        this.exposeValue = null;
                }
                else if (((ignored != null && (ignored["__interfaces"] != null && ignored["__interfaces"].indexOf("java.util.Map") >= 0 || ignored.constructor != null && ignored.constructor["__interfaces"] != null && ignored.constructor["__interfaces"].indexOf("java.util.Map") >= 0)) || ignored === null) && alsoIgnored === undefined) {
                    let __args = arguments;
                    let toBeCopied = __args[0];
                    super(toBeCopied);
                    if (this.exposeKey === undefined)
                        this.exposeKey = null;
                    if (this.exposeValue === undefined)
                        this.exposeValue = null;
                    if (this.exposeKey === undefined)
                        this.exposeKey = null;
                    if (this.exposeValue === undefined)
                        this.exposeValue = null;
                }
                else if (((typeof ignored === 'number') || ignored === null) && alsoIgnored === undefined) {
                    let __args = arguments;
                    super(ignored);
                    if (this.exposeKey === undefined)
                        this.exposeKey = null;
                    if (this.exposeValue === undefined)
                        this.exposeValue = null;
                    if (this.exposeKey === undefined)
                        this.exposeKey = null;
                    if (this.exposeValue === undefined)
                        this.exposeValue = null;
                }
                else if (ignored === undefined && alsoIgnored === undefined) {
                    let __args = arguments;
                    super();
                    if (this.exposeKey === undefined)
                        this.exposeKey = null;
                    if (this.exposeValue === undefined)
                        this.exposeValue = null;
                    if (this.exposeKey === undefined)
                        this.exposeKey = null;
                    if (this.exposeValue === undefined)
                        this.exposeValue = null;
                }
                else
                    throw new Error('invalid overload');
            }
            clone() {
                return (new HashMap(this));
            }
            /**
             *
             * @param {*} value1
             * @param {*} value2
             * @return {boolean}
             */
            _equals(value1, value2) {
                return java.util.Objects.equals(value1, value2);
            }
            /**
             *
             * @param {*} key
             * @return {number}
             */
            getHashCode(key) {
                let hashCode = ((o) => { if (o.hashCode) {
                    return o.hashCode();
                }
                else {
                    return o.toString().split('').reduce((prevHash, currVal) => (((prevHash << 5) - prevHash) + currVal.charCodeAt(0)) | 0, 0);
                } })(key);
                return javaemul.internal.Coercions.ensureInt(hashCode);
            }
        }
        util.HashMap = HashMap;
        HashMap["__class"] = "java.util.HashMap";
        HashMap["__interfaces"] = ["java.lang.Cloneable", "java.util.Map", "java.io.Serializable"];
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        /**
         * Map using reference equality on keys. <a
         * href="http://java.sun.com/j2se/1.5.0/docs/api/java/util/IdentityHashMap.html">[Sun
         * docs]</a>
         *
         * @param <K> key type
         * @param <V> value type
         * @param {number} ignored
         * @class
         * @extends java.util.AbstractHashMap
         */
        class IdentityHashMap extends java.util.AbstractHashMap {
            constructor(toBeCopied) {
                if (((toBeCopied != null && (toBeCopied["__interfaces"] != null && toBeCopied["__interfaces"].indexOf("java.util.Map") >= 0 || toBeCopied.constructor != null && toBeCopied.constructor["__interfaces"] != null && toBeCopied.constructor["__interfaces"].indexOf("java.util.Map") >= 0)) || toBeCopied === null)) {
                    let __args = arguments;
                    super(toBeCopied);
                    if (this.exposeKey === undefined)
                        this.exposeKey = null;
                    if (this.exposeValue === undefined)
                        this.exposeValue = null;
                    if (this.exposeKey === undefined)
                        this.exposeKey = null;
                    if (this.exposeValue === undefined)
                        this.exposeValue = null;
                }
                else if (((typeof toBeCopied === 'number') || toBeCopied === null)) {
                    let __args = arguments;
                    let ignored = __args[0];
                    super(ignored);
                    if (this.exposeKey === undefined)
                        this.exposeKey = null;
                    if (this.exposeValue === undefined)
                        this.exposeValue = null;
                    if (this.exposeKey === undefined)
                        this.exposeKey = null;
                    if (this.exposeValue === undefined)
                        this.exposeValue = null;
                }
                else if (toBeCopied === undefined) {
                    let __args = arguments;
                    super();
                    if (this.exposeKey === undefined)
                        this.exposeKey = null;
                    if (this.exposeValue === undefined)
                        this.exposeValue = null;
                    if (this.exposeKey === undefined)
                        this.exposeKey = null;
                    if (this.exposeValue === undefined)
                        this.exposeValue = null;
                }
                else
                    throw new Error('invalid overload');
            }
            merge(key, value, map) {
                let old = this.get(key);
                let next = (old == null) ? value : (target => (typeof target === 'function') ? target(old, value) : target.apply(old, value))(map);
                if (next == null) {
                    this.remove(key);
                }
                else {
                    this.put(key, next);
                }
                return next;
            }
            computeIfAbsent(key, mappingFunction) {
                let result;
                if ((result = this.get(key)) == null) {
                    result = (target => (typeof target === 'function') ? target(key) : target.apply(key))(mappingFunction);
                    if (result != null)
                        this.put(key, result);
                }
                return result;
            }
            clone() {
                return (new IdentityHashMap(this));
            }
            /**
             *
             * @param {*} obj
             * @return {boolean}
             */
            equals(obj) {
                if (obj === this) {
                    return true;
                }
                if (!(obj != null && (obj["__interfaces"] != null && obj["__interfaces"].indexOf("java.util.Map") >= 0 || obj.constructor != null && obj.constructor["__interfaces"] != null && obj.constructor["__interfaces"].indexOf("java.util.Map") >= 0))) {
                    return false;
                }
                let otherMap = obj;
                if (this.size() !== otherMap.size()) {
                    return false;
                }
                for (let index185 = otherMap.entrySet().iterator(); index185.hasNext();) {
                    let entry = index185.next();
                    {
                        let otherKey = entry.getKey();
                        let otherValue = entry.getValue();
                        if (!this.containsKey(otherKey)) {
                            return false;
                        }
                        if (otherValue !== this.get(otherKey)) {
                            return false;
                        }
                    }
                }
                return true;
            }
            /**
             *
             * @return {number}
             */
            hashCode() {
                let hashCode = 0;
                for (let index186 = this.entrySet().iterator(); index186.hasNext();) {
                    let entry = index186.next();
                    {
                        hashCode += java.lang.System.identityHashCode(entry.getKey());
                        hashCode += java.lang.System.identityHashCode(entry.getValue());
                    }
                }
                return hashCode;
            }
            /**
             *
             * @param {*} value1
             * @param {*} value2
             * @return {boolean}
             */
            _equals(value1, value2) {
                return value1 === value2;
            }
            /**
             *
             * @param {*} key
             * @return {number}
             */
            getHashCode(key) {
                return javaemul.internal.HashCodes.getObjectIdentityHashCode(key);
            }
        }
        util.IdentityHashMap = IdentityHashMap;
        IdentityHashMap["__class"] = "java.util.IdentityHashMap";
        IdentityHashMap["__interfaces"] = ["java.lang.Cloneable", "java.util.Map", "java.io.Serializable"];
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        /**
         * Implements a TreeMap using a red-black tree. This guarantees O(log n)
         * performance on lookups, inserts, and deletes while maintaining linear
         * in-order traversal time. Null keys and values are fully supported if the
         * comparator supports them (the default comparator does not).
         *
         * @param <K> key type
         * @param <V> value type
         * @param {*} c
         * @class
         * @extends java.util.AbstractNavigableMap
         */
        class TreeMap extends java.util.AbstractNavigableMap {
            constructor(c) {
                if (((c != null && (c["__interfaces"] != null && c["__interfaces"].indexOf("java.util.Comparator") >= 0 || c.constructor != null && c.constructor["__interfaces"] != null && c.constructor["__interfaces"].indexOf("java.util.Comparator") >= 0)) || c === null)) {
                    let __args = arguments;
                    super();
                    if (this.cmp === undefined)
                        this.cmp = null;
                    if (this.exposeKeyType === undefined)
                        this.exposeKeyType = null;
                    if (this.exposeValueType === undefined)
                        this.exposeValueType = null;
                    if (this.root === undefined)
                        this.root = null;
                    if (this.__size === undefined)
                        this.__size = 0;
                    if (this.cmp === undefined)
                        this.cmp = null;
                    if (this.exposeKeyType === undefined)
                        this.exposeKeyType = null;
                    if (this.exposeValueType === undefined)
                        this.exposeValueType = null;
                    if (this.root === undefined)
                        this.root = null;
                    if (this.__size === undefined)
                        this.__size = 0;
                    (() => {
                        this.root = null;
                        if (c == null) {
                            c = java.util.Comparators.natural();
                        }
                        this.cmp = c;
                    })();
                }
                else if (((c != null && (c["__interfaces"] != null && c["__interfaces"].indexOf("java.util.SortedMap") >= 0 || c.constructor != null && c.constructor["__interfaces"] != null && c.constructor["__interfaces"].indexOf("java.util.SortedMap") >= 0)) || c === null)) {
                    let __args = arguments;
                    let map = __args[0];
                    {
                        let __args = arguments;
                        let c = javaemul.internal.InternalPreconditions.checkNotNull(map).comparator();
                        super();
                        if (this.cmp === undefined)
                            this.cmp = null;
                        if (this.exposeKeyType === undefined)
                            this.exposeKeyType = null;
                        if (this.exposeValueType === undefined)
                            this.exposeValueType = null;
                        if (this.root === undefined)
                            this.root = null;
                        if (this.__size === undefined)
                            this.__size = 0;
                        if (this.cmp === undefined)
                            this.cmp = null;
                        if (this.exposeKeyType === undefined)
                            this.exposeKeyType = null;
                        if (this.exposeValueType === undefined)
                            this.exposeValueType = null;
                        if (this.root === undefined)
                            this.root = null;
                        if (this.__size === undefined)
                            this.__size = 0;
                        (() => {
                            this.root = null;
                            if (c == null) {
                                c = java.util.Comparators.natural();
                            }
                            this.cmp = c;
                        })();
                    }
                    (() => {
                        this.putAll(map);
                    })();
                }
                else if (((c != null && (c["__interfaces"] != null && c["__interfaces"].indexOf("java.util.Map") >= 0 || c.constructor != null && c.constructor["__interfaces"] != null && c.constructor["__interfaces"].indexOf("java.util.Map") >= 0)) || c === null)) {
                    let __args = arguments;
                    let map = __args[0];
                    {
                        let __args = arguments;
                        {
                            let __args = arguments;
                            let c = null;
                            super();
                            if (this.cmp === undefined)
                                this.cmp = null;
                            if (this.exposeKeyType === undefined)
                                this.exposeKeyType = null;
                            if (this.exposeValueType === undefined)
                                this.exposeValueType = null;
                            if (this.root === undefined)
                                this.root = null;
                            if (this.__size === undefined)
                                this.__size = 0;
                            if (this.cmp === undefined)
                                this.cmp = null;
                            if (this.exposeKeyType === undefined)
                                this.exposeKeyType = null;
                            if (this.exposeValueType === undefined)
                                this.exposeValueType = null;
                            if (this.root === undefined)
                                this.root = null;
                            if (this.__size === undefined)
                                this.__size = 0;
                            (() => {
                                this.root = null;
                                if (c == null) {
                                    c = java.util.Comparators.natural();
                                }
                                this.cmp = c;
                            })();
                        }
                    }
                    (() => {
                        this.putAll(map);
                    })();
                }
                else if (c === undefined) {
                    let __args = arguments;
                    {
                        let __args = arguments;
                        let c = null;
                        super();
                        if (this.cmp === undefined)
                            this.cmp = null;
                        if (this.exposeKeyType === undefined)
                            this.exposeKeyType = null;
                        if (this.exposeValueType === undefined)
                            this.exposeValueType = null;
                        if (this.root === undefined)
                            this.root = null;
                        if (this.__size === undefined)
                            this.__size = 0;
                        if (this.cmp === undefined)
                            this.cmp = null;
                        if (this.exposeKeyType === undefined)
                            this.exposeKeyType = null;
                        if (this.exposeValueType === undefined)
                            this.exposeValueType = null;
                        if (this.root === undefined)
                            this.root = null;
                        if (this.__size === undefined)
                            this.__size = 0;
                        (() => {
                            this.root = null;
                            if (c == null) {
                                c = java.util.Comparators.natural();
                            }
                            this.cmp = c;
                        })();
                    }
                }
                else
                    throw new Error('invalid overload');
            }
            static SubMapType_All_$LI$() { if (TreeMap.SubMapType_All == null)
                TreeMap.SubMapType_All = new TreeMap.SubMapType(); return TreeMap.SubMapType_All; }
            ;
            static SubMapType_Head_$LI$() { if (TreeMap.SubMapType_Head == null)
                TreeMap.SubMapType_Head = new TreeMap.SubMapTypeHead(); return TreeMap.SubMapType_Head; }
            ;
            static SubMapType_Range_$LI$() { if (TreeMap.SubMapType_Range == null)
                TreeMap.SubMapType_Range = new TreeMap.SubMapTypeRange(); return TreeMap.SubMapType_Range; }
            ;
            static SubMapType_Tail_$LI$() { if (TreeMap.SubMapType_Tail == null)
                TreeMap.SubMapType_Tail = new TreeMap.SubMapTypeTail(); return TreeMap.SubMapType_Tail; }
            ;
            static otherChild(child) {
                return 1 - child;
            }
            /**
             *
             */
            clear() {
                this.root = null;
                this.__size = 0;
            }
            /**
             *
             * @return {*}
             */
            comparator() {
                if (this.cmp === java.util.Comparators.natural()) {
                    return null;
                }
                return this.cmp;
            }
            /**
             *
             * @return {*}
             */
            entrySet() {
                return new TreeMap.__java_util_TreeMap_EntrySet(this);
            }
            headMap$java_lang_Object$boolean(toKey, inclusive) {
                return new TreeMap.SubMap(this, TreeMap.SubMapType_Head_$LI$(), null, false, toKey, inclusive);
            }
            /**
             *
             * @param {*} toKey
             * @param {boolean} inclusive
             * @return {*}
             */
            headMap(toKey, inclusive) {
                if (((toKey != null) || toKey === null) && ((typeof inclusive === 'boolean') || inclusive === null)) {
                    return this.headMap$java_lang_Object$boolean(toKey, inclusive);
                }
                else if (((toKey != null) || toKey === null) && inclusive === undefined) {
                    return this.headMap$java_lang_Object(toKey);
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             *
             * @param {*} key
             * @param {*} value
             * @return {*}
             */
            put(key, value) {
                let node = (new TreeMap.Node(key, value));
                let state = (new TreeMap.State());
                this.root = this.insert(this.root, node, state);
                if (!state.found) {
                    ++this.__size;
                }
                this.root.isRed = false;
                return state.value;
            }
            /**
             *
             * @param {*} k
             * @return {*}
             */
            remove(k) {
                let key = k;
                let state = (new TreeMap.State());
                this.removeWithState(key, state);
                return state.value;
            }
            /**
             *
             * @return {number}
             */
            size() {
                return this.__size;
            }
            subMap$java_lang_Object$boolean$java_lang_Object$boolean(fromKey, fromInclusive, toKey, toInclusive) {
                return new TreeMap.SubMap(this, TreeMap.SubMapType_Range_$LI$(), fromKey, fromInclusive, toKey, toInclusive);
            }
            /**
             *
             * @param {*} fromKey
             * @param {boolean} fromInclusive
             * @param {*} toKey
             * @param {boolean} toInclusive
             * @return {*}
             */
            subMap(fromKey, fromInclusive, toKey, toInclusive) {
                if (((fromKey != null) || fromKey === null) && ((typeof fromInclusive === 'boolean') || fromInclusive === null) && ((toKey != null) || toKey === null) && ((typeof toInclusive === 'boolean') || toInclusive === null)) {
                    return this.subMap$java_lang_Object$boolean$java_lang_Object$boolean(fromKey, fromInclusive, toKey, toInclusive);
                }
                else if (((fromKey != null) || fromKey === null) && ((fromInclusive != null) || fromInclusive === null) && toKey === undefined && toInclusive === undefined) {
                    return this.subMap$java_lang_Object$java_lang_Object(fromKey, fromInclusive);
                }
                else
                    throw new Error('invalid overload');
            }
            tailMap$java_lang_Object$boolean(fromKey, inclusive) {
                return new TreeMap.SubMap(this, TreeMap.SubMapType_Tail_$LI$(), fromKey, inclusive, null, false);
            }
            /**
             *
             * @param {*} fromKey
             * @param {boolean} inclusive
             * @return {*}
             */
            tailMap(fromKey, inclusive) {
                if (((fromKey != null) || fromKey === null) && ((typeof inclusive === 'boolean') || inclusive === null)) {
                    return this.tailMap$java_lang_Object$boolean(fromKey, inclusive);
                }
                else if (((fromKey != null) || fromKey === null) && inclusive === undefined) {
                    return this.tailMap$java_lang_Object(fromKey);
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             * Returns the first node which compares greater than the given key.
             *
             * @param {*} key the key to search for
             * @return {java.util.TreeMap.Node} the next node, or null if there is none
             * @param {boolean} inclusive
             * @private
             */
            getNodeAfter(key, inclusive) {
                let foundNode = null;
                let node = this.root;
                while ((node != null)) {
                    {
                        let c = this.cmp.compare(key, node.getKey());
                        if (inclusive && c === 0) {
                            return node;
                        }
                        if (c >= 0) {
                            node = node.child[TreeMap.RIGHT];
                        }
                        else {
                            foundNode = node;
                            node = node.child[TreeMap.LEFT];
                        }
                    }
                }
                ;
                return foundNode;
            }
            /**
             * Returns the last node which is strictly less than the given key.
             *
             * @param {*} key the key to search for
             * @return {java.util.TreeMap.Node} the previous node, or null if there is none
             * @param {boolean} inclusive
             * @private
             */
            getNodeBefore(key, inclusive) {
                let foundNode = null;
                let node = this.root;
                while ((node != null)) {
                    {
                        let c = this.cmp.compare(key, node.getKey());
                        if (inclusive && c === 0) {
                            return node;
                        }
                        if (c <= 0) {
                            node = node.child[TreeMap.LEFT];
                        }
                        else {
                            foundNode = node;
                            node = node.child[TreeMap.RIGHT];
                        }
                    }
                }
                ;
                return foundNode;
            }
            assertCorrectness$() {
                this.assertCorrectness$java_util_TreeMap_Node$boolean(this.root, true);
            }
            /**
             *
             * @return {*}
             */
            descendingEntryIterator() {
                return new TreeMap.DescendingEntryIterator(this);
            }
            /**
             *
             * @return {*}
             */
            entryIterator() {
                return new TreeMap.EntryIterator(this);
            }
            assertCorrectness$java_util_TreeMap_Node$boolean(tree, isRed) {
                if (tree == null) {
                    return 0;
                }
                if (isRed && tree.isRed) {
                    throw new java.lang.RuntimeException("Two red nodes adjacent");
                }
                let leftNode = tree.child[TreeMap.LEFT];
                if (leftNode != null && this.cmp.compare(leftNode.getKey(), tree.getKey()) > 0) {
                    throw new java.lang.RuntimeException("Left child " + leftNode + " larger than " + tree);
                }
                let rightNode = tree.child[TreeMap.RIGHT];
                if (rightNode != null && this.cmp.compare(rightNode.getKey(), tree.getKey()) < 0) {
                    throw new java.lang.RuntimeException("Right child " + rightNode + " smaller than " + tree);
                }
                let leftHeight = this.assertCorrectness$java_util_TreeMap_Node$boolean(leftNode, tree.isRed);
                let rightHeight = this.assertCorrectness$java_util_TreeMap_Node$boolean(rightNode, tree.isRed);
                if (leftHeight !== 0 && rightHeight !== 0 && leftHeight !== rightHeight) {
                    throw new java.lang.RuntimeException("Black heights don\'t match");
                }
                return tree.isRed ? leftHeight : leftHeight + 1;
            }
            /**
             * Internal helper function for public {@link #assertCorrectness()}.
             *
             * @param {java.util.TreeMap.Node} tree the subtree to validate.
             * @param {boolean} isRed true if the parent of this node is red.
             * @return {number} the black height of this subtree.
             * @throws RuntimeException if this RB-tree is not valid.
             * @private
             */
            assertCorrectness(tree, isRed) {
                if (((tree != null && tree instanceof java.util.TreeMap.Node) || tree === null) && ((typeof isRed === 'boolean') || isRed === null)) {
                    return this.assertCorrectness$java_util_TreeMap_Node$boolean(tree, isRed);
                }
                else if (tree === undefined && isRed === undefined) {
                    return this.assertCorrectness$();
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             * Finds an entry given a key and returns the node.
             *
             * @param {*} key the search key
             * @return {*} the node matching the key or null
             */
            getEntry(key) {
                let tree = this.root;
                while ((tree != null)) {
                    {
                        let c = this.cmp.compare(key, tree.getKey());
                        if (c === 0) {
                            return tree;
                        }
                        let childNum = c < 0 ? TreeMap.LEFT : TreeMap.RIGHT;
                        tree = tree.child[childNum];
                    }
                }
                ;
                return null;
            }
            /**
             * Returns the left-most node of the tree, or null if empty.
             * @return {*}
             */
            getFirstEntry() {
                if (this.root == null) {
                    return null;
                }
                let node = this.root;
                let nextNode;
                while (((nextNode = node.child[TreeMap.LEFT]) != null)) {
                    {
                        node = nextNode;
                    }
                }
                ;
                return node;
            }
            /**
             * Returns the right-most node of the tree, or null if empty.
             * @return {*}
             */
            getLastEntry() {
                if (this.root == null) {
                    return null;
                }
                let node = this.root;
                let nextNode;
                while (((nextNode = node.child[TreeMap.RIGHT]) != null)) {
                    {
                        node = nextNode;
                    }
                }
                ;
                return node;
            }
            /**
             *
             * @param {*} key
             * @return {*}
             */
            getCeilingEntry(key) {
                return this.getNodeAfter(key, true);
            }
            /**
             *
             * @param {*} key
             * @return {*}
             */
            getFloorEntry(key) {
                return this.getNodeBefore(key, true);
            }
            /**
             *
             * @param {*} key
             * @return {*}
             */
            getHigherEntry(key) {
                return this.getNodeAfter(key, false);
            }
            /**
             *
             * @param {*} key
             * @return {*}
             */
            getLowerEntry(key) {
                return this.getNodeBefore(key, false);
            }
            /**
             *
             * @param {*} entry
             * @return {boolean}
             */
            removeEntry(entry) {
                let state = (new TreeMap.State());
                state.matchValue = true;
                state.value = entry.getValue();
                return this.removeWithState(entry.getKey(), state);
            }
            inOrderAdd(list, type, current, fromKey, fromInclusive, toKey, toInclusive) {
                if (current == null) {
                    return;
                }
                let leftNode = current.child[TreeMap.LEFT];
                if (leftNode != null) {
                    this.inOrderAdd(list, type, leftNode, fromKey, fromInclusive, toKey, toInclusive);
                }
                if (this.inRange(type, current.getKey(), fromKey, fromInclusive, toKey, toInclusive)) {
                    list.add(current);
                }
                let rightNode = current.child[TreeMap.RIGHT];
                if (rightNode != null) {
                    this.inOrderAdd(list, type, rightNode, fromKey, fromInclusive, toKey, toInclusive);
                }
            }
            inRange(type, key, fromKey, fromInclusive, toKey, toInclusive) {
                if (type.fromKeyValid() && this.smaller(key, fromKey, !fromInclusive)) {
                    return false;
                }
                if (type.toKeyValid() && this.larger(key, toKey, !toInclusive)) {
                    return false;
                }
                return true;
            }
            /**
             * Insert a node into a subtree, collecting state about the insertion.
             *
             * If the same key already exists, the value of the node is overwritten with
             * the value from the new node instead.
             *
             * @param {java.util.TreeMap.Node} tree subtree to insert into
             * @param {java.util.TreeMap.Node} newNode new node to insert
             * @param {java.util.TreeMap.State} state result of the insertion: state.found true if the key already
             * existed in the tree state.value the old value if the key existed
             * @return {java.util.TreeMap.Node} the new subtree root
             * @private
             */
            insert(tree, newNode, state) {
                if (tree == null) {
                    return newNode;
                }
                else {
                    let c = this.cmp.compare(newNode.getKey(), tree.getKey());
                    if (c === 0) {
                        state.value = tree.setValue(newNode.getValue());
                        state.found = true;
                        return tree;
                    }
                    let childNum = c < 0 ? TreeMap.LEFT : TreeMap.RIGHT;
                    tree.child[childNum] = this.insert(tree.child[childNum], newNode, state);
                    if (this.isRed(tree.child[childNum])) {
                        if (this.isRed(tree.child[TreeMap.otherChild(childNum)])) {
                            tree.isRed = true;
                            tree.child[TreeMap.LEFT].isRed = false;
                            tree.child[TreeMap.RIGHT].isRed = false;
                        }
                        else {
                            if (this.isRed(tree.child[childNum].child[childNum])) {
                                tree = this.rotateSingle(tree, TreeMap.otherChild(childNum));
                            }
                            else if (this.isRed(tree.child[childNum].child[TreeMap.otherChild(childNum)])) {
                                tree = this.rotateDouble(tree, TreeMap.otherChild(childNum));
                            }
                        }
                    }
                }
                return tree;
            }
            /**
             * Returns true if <code>node</code> is red. Note that null pointers are
             * considered black.
             * @param {java.util.TreeMap.Node} node
             * @return {boolean}
             * @private
             */
            isRed(node) {
                return node != null && node.isRed;
            }
            /**
             * Returns true if <code>a</code> is greater than or equal to <code>b</code>.
             * @param {*} a
             * @param {*} b
             * @param {boolean} orEqual
             * @return {boolean}
             * @private
             */
            larger(a, b, orEqual) {
                let compare = this.cmp.compare(a, b);
                return compare > 0 || (orEqual && compare === 0);
            }
            /**
             * Returns true if <code>a</code> is less than or equal to <code>b</code>.
             * @param {*} a
             * @param {*} b
             * @param {boolean} orEqual
             * @return {boolean}
             * @private
             */
            smaller(a, b, orEqual) {
                let compare = this.cmp.compare(a, b);
                return compare < 0 || (orEqual && compare === 0);
            }
            /**
             * Remove a key from the tree, returning whether it was found and its value.
             *
             * @param {*} key key to remove
             * @param {java.util.TreeMap.State} state return state, not null
             * @return {boolean} true if the value was found
             * @private
             */
            removeWithState(key, state) {
                if (this.root == null) {
                    return false;
                }
                let found = null;
                let parent = null;
                let head = (new TreeMap.Node(null, null));
                let dir = TreeMap.RIGHT;
                head.child[TreeMap.RIGHT] = this.root;
                let node = head;
                while ((node.child[dir] != null)) {
                    {
                        let last = dir;
                        let grandparent = parent;
                        parent = node;
                        node = node.child[dir];
                        let c = this.cmp.compare(key, node.getKey());
                        dir = c < 0 ? TreeMap.LEFT : TreeMap.RIGHT;
                        if (c === 0 && (!state.matchValue || java.util.Objects.equals(node.getValue(), state.value))) {
                            found = node;
                        }
                        if (!this.isRed(node) && !this.isRed(node.child[dir])) {
                            if (this.isRed(node.child[TreeMap.otherChild(dir)])) {
                                parent = parent.child[last] = this.rotateSingle(node, dir);
                            }
                            else if (!this.isRed(node.child[TreeMap.otherChild(dir)])) {
                                let sibling = parent.child[TreeMap.otherChild(last)];
                                if (sibling != null) {
                                    if (!this.isRed(sibling.child[TreeMap.otherChild(last)]) && !this.isRed(sibling.child[last])) {
                                        parent.isRed = false;
                                        sibling.isRed = true;
                                        node.isRed = true;
                                    }
                                    else {
                                        let dir2 = grandparent.child[TreeMap.RIGHT] === parent ? TreeMap.RIGHT : TreeMap.LEFT;
                                        if (this.isRed(sibling.child[last])) {
                                            grandparent.child[dir2] = this.rotateDouble(parent, last);
                                        }
                                        else if (this.isRed(sibling.child[TreeMap.otherChild(last)])) {
                                            grandparent.child[dir2] = this.rotateSingle(parent, last);
                                        }
                                        node.isRed = grandparent.child[dir2].isRed = true;
                                        grandparent.child[dir2].child[TreeMap.LEFT].isRed = false;
                                        grandparent.child[dir2].child[TreeMap.RIGHT].isRed = false;
                                    }
                                }
                            }
                        }
                    }
                }
                ;
                if (found != null) {
                    state.found = true;
                    state.value = found.getValue();
                    if (node !== found) {
                        let newNode = (new TreeMap.Node(node.getKey(), node.getValue()));
                        this.replaceNode(head, found, newNode);
                        if (parent === found) {
                            parent = newNode;
                        }
                    }
                    parent.child[parent.child[TreeMap.RIGHT] === node ? TreeMap.RIGHT : TreeMap.LEFT] = node.child[node.child[TreeMap.LEFT] == null ? TreeMap.RIGHT : TreeMap.LEFT];
                    this.__size--;
                }
                this.root = head.child[TreeMap.RIGHT];
                if (this.root != null) {
                    this.root.isRed = false;
                }
                return state.found;
            }
            /**
             * replace 'node' with 'newNode' in the tree rooted at 'head'. Could have
             * avoided this traversal if each node maintained a parent pointer.
             * @param {java.util.TreeMap.Node} head
             * @param {java.util.TreeMap.Node} node
             * @param {java.util.TreeMap.Node} newNode
             * @private
             */
            replaceNode(head, node, newNode) {
                let parent = head;
                let direction = (parent.getKey() == null || this.cmp.compare(node.getKey(), parent.getKey()) > 0) ? TreeMap.RIGHT : TreeMap.LEFT;
                while ((parent.child[direction] !== node)) {
                    {
                        parent = parent.child[direction];
                        direction = this.cmp.compare(node.getKey(), parent.getKey()) > 0 ? TreeMap.RIGHT : TreeMap.LEFT;
                    }
                }
                ;
                parent.child[direction] = newNode;
                newNode.isRed = node.isRed;
                newNode.child[TreeMap.LEFT] = node.child[TreeMap.LEFT];
                newNode.child[TreeMap.RIGHT] = node.child[TreeMap.RIGHT];
                node.child[TreeMap.LEFT] = null;
                node.child[TreeMap.RIGHT] = null;
            }
            /**
             * Perform a double rotation, first rotating the child which will become the
             * root in the opposite direction, then rotating the root in the specified
             * direction.
             *
             * <pre>
             * A                                               F
             * B   C    becomes (with rotateDirection=0)       A   C
             * D E F G                                         B E   G
             * D
             * </pre>
             *
             * @param {java.util.TreeMap.Node} tree root of the subtree to rotate
             * @param {number} rotateDirection the direction to rotate: 0=left, 1=right
             * @return {java.util.TreeMap.Node} the new root of the rotated subtree
             * @private
             */
            rotateDouble(tree, rotateDirection) {
                let otherChildDir = TreeMap.otherChild(rotateDirection);
                tree.child[otherChildDir] = this.rotateSingle(tree.child[otherChildDir], otherChildDir);
                return this.rotateSingle(tree, rotateDirection);
            }
            /**
             * Perform a single rotation, pushing the root of the subtree to the specified
             * direction.
             *
             * <pre>
             * A                                              B
             * B   C     becomes (with rotateDirection=1)     D   A
             * D E                                              E   C
             * </pre>
             *
             * @param {java.util.TreeMap.Node} tree the root of the subtree to rotate
             * @param {number} rotateDirection the direction to rotate: 0=left rotation, 1=right
             * @return {java.util.TreeMap.Node} the new root of the rotated subtree
             * @private
             */
            rotateSingle(tree, rotateDirection) {
                let otherChildDir = TreeMap.otherChild(rotateDirection);
                let save = tree.child[otherChildDir];
                tree.child[otherChildDir] = save.child[rotateDirection];
                save.child[rotateDirection] = tree;
                tree.isRed = true;
                save.isRed = false;
                return save;
            }
        }
        TreeMap.LEFT = 0;
        TreeMap.RIGHT = 1;
        util.TreeMap = TreeMap;
        TreeMap["__class"] = "java.util.TreeMap";
        TreeMap["__interfaces"] = ["java.util.Map", "java.util.NavigableMap", "java.util.SortedMap", "java.io.Serializable"];
        (function (TreeMap) {
            /**
             * Create an iterator which may return only a restricted range.
             *
             * @param {*} fromKey the first key to return in the iterator.
             * @param {*} toKey the upper bound of keys to return.
             * @param {java.util.TreeMap.SubMapType} type
             * @param {boolean} fromInclusive
             * @param {boolean} toInclusive
             * @class
             */
            class DescendingEntryIterator {
                constructor(__parent, type, fromKey, fromInclusive, toKey, toInclusive) {
                    if (((type != null && type instanceof java.util.TreeMap.SubMapType) || type === null) && ((fromKey != null) || fromKey === null) && ((typeof fromInclusive === 'boolean') || fromInclusive === null) && ((toKey != null) || toKey === null) && ((typeof toInclusive === 'boolean') || toInclusive === null)) {
                        let __args = Array.prototype.slice.call(arguments, [1]);
                        if (this.iter === undefined)
                            this.iter = null;
                        if (this.last === undefined)
                            this.last = null;
                        this.__parent = __parent;
                        if (this.iter === undefined)
                            this.iter = null;
                        if (this.last === undefined)
                            this.last = null;
                        (() => {
                            let list = (new java.util.ArrayList());
                            __parent.inOrderAdd(list, type, __parent.root, fromKey, fromInclusive, toKey, toInclusive);
                            this.iter = list['listIterator$int'](list.size());
                        })();
                    }
                    else if (type === undefined && fromKey === undefined && fromInclusive === undefined && toKey === undefined && toInclusive === undefined) {
                        let __args = Array.prototype.slice.call(arguments, [1]);
                        {
                            let __args = Array.prototype.slice.call(arguments, [1]);
                            let type = java.util.TreeMap.SubMapType_All_$LI$();
                            let fromKey = null;
                            let fromInclusive = false;
                            let toKey = null;
                            let toInclusive = false;
                            if (this.iter === undefined)
                                this.iter = null;
                            if (this.last === undefined)
                                this.last = null;
                            this.__parent = __parent;
                            if (this.iter === undefined)
                                this.iter = null;
                            if (this.last === undefined)
                                this.last = null;
                            (() => {
                                let list = (new java.util.ArrayList());
                                __parent.inOrderAdd(list, type, __parent.root, fromKey, fromInclusive, toKey, toInclusive);
                                this.iter = list['listIterator$int'](list.size());
                            })();
                        }
                    }
                    else
                        throw new Error('invalid overload');
                }
                forEachRemaining(consumer) {
                    javaemul.internal.InternalPreconditions.checkNotNull((consumer));
                    while ((this.hasNext())) {
                        {
                            (target => (typeof target === 'function') ? target(this.next()) : target.accept(this.next()))(consumer);
                        }
                    }
                    ;
                }
                /**
                 *
                 * @return {boolean}
                 */
                hasNext() {
                    return this.iter.hasPrevious();
                }
                /**
                 *
                 * @return {*}
                 */
                next() {
                    return this.last = this.iter.previous();
                }
                /**
                 *
                 */
                remove() {
                    this.iter.remove();
                    this.__parent.removeEntry(this.last);
                    this.last = null;
                }
            }
            TreeMap.DescendingEntryIterator = DescendingEntryIterator;
            DescendingEntryIterator["__class"] = "java.util.TreeMap.DescendingEntryIterator";
            DescendingEntryIterator["__interfaces"] = ["java.util.Iterator"];
            /**
             * Create an iterator which may return only a restricted range.
             *
             * @param {*} fromKey the first key to return in the iterator.
             * @param {*} toKey the upper bound of keys to return.
             * @param {java.util.TreeMap.SubMapType} type
             * @param {boolean} fromInclusive
             * @param {boolean} toInclusive
             * @class
             */
            class EntryIterator {
                constructor(__parent, type, fromKey, fromInclusive, toKey, toInclusive) {
                    if (((type != null && type instanceof java.util.TreeMap.SubMapType) || type === null) && ((fromKey != null) || fromKey === null) && ((typeof fromInclusive === 'boolean') || fromInclusive === null) && ((toKey != null) || toKey === null) && ((typeof toInclusive === 'boolean') || toInclusive === null)) {
                        let __args = Array.prototype.slice.call(arguments, [1]);
                        if (this.iter === undefined)
                            this.iter = null;
                        if (this.last === undefined)
                            this.last = null;
                        this.__parent = __parent;
                        if (this.iter === undefined)
                            this.iter = null;
                        if (this.last === undefined)
                            this.last = null;
                        (() => {
                            let list = (new java.util.ArrayList());
                            __parent.inOrderAdd(list, type, __parent.root, fromKey, fromInclusive, toKey, toInclusive);
                            this.iter = list.listIterator();
                        })();
                    }
                    else if (type === undefined && fromKey === undefined && fromInclusive === undefined && toKey === undefined && toInclusive === undefined) {
                        let __args = Array.prototype.slice.call(arguments, [1]);
                        {
                            let __args = Array.prototype.slice.call(arguments, [1]);
                            let type = java.util.TreeMap.SubMapType_All_$LI$();
                            let fromKey = null;
                            let fromInclusive = false;
                            let toKey = null;
                            let toInclusive = false;
                            if (this.iter === undefined)
                                this.iter = null;
                            if (this.last === undefined)
                                this.last = null;
                            this.__parent = __parent;
                            if (this.iter === undefined)
                                this.iter = null;
                            if (this.last === undefined)
                                this.last = null;
                            (() => {
                                let list = (new java.util.ArrayList());
                                __parent.inOrderAdd(list, type, __parent.root, fromKey, fromInclusive, toKey, toInclusive);
                                this.iter = list.listIterator();
                            })();
                        }
                    }
                    else
                        throw new Error('invalid overload');
                }
                forEachRemaining(consumer) {
                    javaemul.internal.InternalPreconditions.checkNotNull((consumer));
                    while ((this.hasNext())) {
                        {
                            (target => (typeof target === 'function') ? target(this.next()) : target.accept(this.next()))(consumer);
                        }
                    }
                    ;
                }
                /**
                 *
                 * @return {boolean}
                 */
                hasNext() {
                    return this.iter.hasNext();
                }
                /**
                 *
                 * @return {*}
                 */
                next() {
                    return this.last = this.iter.next();
                }
                /**
                 *
                 */
                remove() {
                    this.iter.remove();
                    this.__parent.removeEntry(this.last);
                    this.last = null;
                }
            }
            TreeMap.EntryIterator = EntryIterator;
            EntryIterator["__class"] = "java.util.TreeMap.EntryIterator";
            EntryIterator["__interfaces"] = ["java.util.Iterator"];
            class __java_util_TreeMap_EntrySet extends java.util.AbstractNavigableMap.EntrySet {
                constructor(__parent) {
                    super(__parent);
                    this.__parent = __parent;
                }
                /**
                 *
                 */
                clear() {
                    this.clear();
                }
            }
            TreeMap.__java_util_TreeMap_EntrySet = __java_util_TreeMap_EntrySet;
            __java_util_TreeMap_EntrySet["__class"] = "java.util.TreeMap.EntrySet";
            __java_util_TreeMap_EntrySet["__interfaces"] = ["java.util.Collection", "java.util.Set", "java.lang.Iterable"];
            /**
             * Create a node of the specified color.
             *
             * @param {*} key
             * @param {*} value
             * @param {boolean} isRed true if this should be a red node, false for black
             * @class
             * @extends java.util.AbstractMap.SimpleEntry
             */
            class Node extends util.AbstractMap.SimpleEntry {
                constructor(key, value, isRed) {
                    if (((key != null) || key === null) && ((value != null) || value === null) && ((typeof isRed === 'boolean') || isRed === null)) {
                        let __args = arguments;
                        super(key, value);
                        if (this.isRed === undefined)
                            this.isRed = false;
                        this.child = [null, null];
                        if (this.isRed === undefined)
                            this.isRed = false;
                        (() => {
                            this.isRed = isRed;
                        })();
                    }
                    else if (((key != null) || key === null) && ((value != null) || value === null) && isRed === undefined) {
                        let __args = arguments;
                        {
                            let __args = arguments;
                            let isRed = true;
                            super(key, value);
                            if (this.isRed === undefined)
                                this.isRed = false;
                            this.child = [null, null];
                            if (this.isRed === undefined)
                                this.isRed = false;
                            (() => {
                                this.isRed = isRed;
                            })();
                        }
                    }
                    else
                        throw new Error('invalid overload');
                }
            }
            TreeMap.Node = Node;
            Node["__class"] = "java.util.TreeMap.Node";
            Node["__interfaces"] = ["java.util.Map.Entry"];
            /**
             * A state object which is passed down the tree for both insert and remove.
             * All uses make use of the done flag to indicate when no further rebalancing
             * of the tree is required. Remove methods use the found flag to indicate when
             * the desired key has been found. value is used both to return the value of a
             * removed node as well as to pass in a value which must match (used for
             * entrySet().remove(entry)), and the matchValue flag is used to request this
             * behavior.
             *
             * @param <V> value type
             * @class
             */
            class State {
                constructor() {
                    if (this.done === undefined)
                        this.done = false;
                    if (this.found === undefined)
                        this.found = false;
                    if (this.matchValue === undefined)
                        this.matchValue = false;
                    if (this.value === undefined)
                        this.value = null;
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    return "State: mv=" + this.matchValue + " value=" + this.value + " done=" + this.done + " found=" + this.found;
                }
            }
            TreeMap.State = State;
            State["__class"] = "java.util.TreeMap.State";
            class SubMap extends java.util.AbstractNavigableMap {
                constructor(__parent, type, fromKey, fromInclusive, toKey, toInclusive) {
                    super();
                    this.__parent = __parent;
                    if (this.fromInclusive === undefined)
                        this.fromInclusive = false;
                    if (this.fromKey === undefined)
                        this.fromKey = null;
                    if (this.toInclusive === undefined)
                        this.toInclusive = false;
                    if (this.toKey === undefined)
                        this.toKey = null;
                    if (this.type === undefined)
                        this.type = null;
                    if (type === java.util.TreeMap.SubMapType_Range_$LI$()) {
                        if (__parent.cmp.compare(toKey, fromKey) < 0) {
                            throw new java.lang.IllegalArgumentException("subMap: " + toKey + " less than " + fromKey);
                        }
                    }
                    if (type === java.util.TreeMap.SubMapType_Head_$LI$()) {
                        __parent.cmp.compare(toKey, toKey);
                    }
                    if (type === java.util.TreeMap.SubMapType_Tail_$LI$()) {
                        __parent.cmp.compare(fromKey, fromKey);
                    }
                    if (type === java.util.TreeMap.SubMapType_All_$LI$()) {
                    }
                    this.type = type;
                    this.fromKey = fromKey;
                    this.fromInclusive = fromInclusive;
                    this.toKey = toKey;
                    this.toInclusive = toInclusive;
                }
                /**
                 *
                 * @return {*}
                 */
                comparator() {
                    return this.comparator();
                }
                /**
                 *
                 * @return {*}
                 */
                entrySet() {
                    return new SubMap.SubMap$0(this);
                }
                headMap$java_lang_Object$boolean(toKey, toInclusive) {
                    if (this.type.toKeyValid() && this.__parent.cmp.compare(toKey, this.toKey) > 0) {
                        throw new java.lang.IllegalArgumentException("subMap: " + toKey + " greater than " + this.toKey);
                    }
                    if (this.type.fromKeyValid()) {
                        return this.subMap(this.fromKey, this.fromInclusive, toKey, toInclusive);
                    }
                    else {
                        return this.headMap(toKey, toInclusive);
                    }
                }
                /**
                 *
                 * @param {*} toKey
                 * @param {boolean} toInclusive
                 * @return {*}
                 */
                headMap(toKey, toInclusive) {
                    if (((toKey != null) || toKey === null) && ((typeof toInclusive === 'boolean') || toInclusive === null)) {
                        return this.headMap$java_lang_Object$boolean(toKey, toInclusive);
                    }
                    else if (((toKey != null) || toKey === null) && toInclusive === undefined) {
                        return this.headMap$java_lang_Object(toKey);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 *
                 * @return {boolean}
                 */
                isEmpty() {
                    return this.getFirstEntry() == null;
                }
                /**
                 *
                 * @param {*} key
                 * @param {*} value
                 * @return {*}
                 */
                put(key, value) {
                    if (!this.inRange(key)) {
                        throw new java.lang.IllegalArgumentException(key + " outside the range " + this.fromKey + " to " + this.toKey);
                    }
                    return this.put(key, value);
                }
                /**
                 *
                 * @param {*} k
                 * @return {*}
                 */
                remove(k) {
                    let key = k;
                    if (!this.inRange(key)) {
                        return null;
                    }
                    return this.remove(key);
                }
                /**
                 *
                 * @return {number}
                 */
                size() {
                    let count = 0;
                    for (let it = this.entryIterator(); it.hasNext(); it.next()) {
                        {
                            count++;
                        }
                        ;
                    }
                    return count;
                }
                subMap$java_lang_Object$boolean$java_lang_Object$boolean(newFromKey, newFromInclusive, newToKey, newToInclusive) {
                    if (this.type.fromKeyValid() && this.__parent.cmp.compare(newFromKey, this.fromKey) < 0) {
                        throw new java.lang.IllegalArgumentException("subMap: " + newFromKey + " less than " + this.fromKey);
                    }
                    if (this.type.toKeyValid() && this.__parent.cmp.compare(newToKey, this.toKey) > 0) {
                        throw new java.lang.IllegalArgumentException("subMap: " + newToKey + " greater than " + this.toKey);
                    }
                    return this.subMap(newFromKey, newFromInclusive, newToKey, newToInclusive);
                }
                /**
                 *
                 * @param {*} newFromKey
                 * @param {boolean} newFromInclusive
                 * @param {*} newToKey
                 * @param {boolean} newToInclusive
                 * @return {*}
                 */
                subMap(newFromKey, newFromInclusive, newToKey, newToInclusive) {
                    if (((newFromKey != null) || newFromKey === null) && ((typeof newFromInclusive === 'boolean') || newFromInclusive === null) && ((newToKey != null) || newToKey === null) && ((typeof newToInclusive === 'boolean') || newToInclusive === null)) {
                        return this.subMap$java_lang_Object$boolean$java_lang_Object$boolean(newFromKey, newFromInclusive, newToKey, newToInclusive);
                    }
                    else if (((newFromKey != null) || newFromKey === null) && ((newFromInclusive != null) || newFromInclusive === null) && newToKey === undefined && newToInclusive === undefined) {
                        return this.subMap$java_lang_Object$java_lang_Object(newFromKey, newFromInclusive);
                    }
                    else
                        throw new Error('invalid overload');
                }
                tailMap$java_lang_Object$boolean(fromKey, fromInclusive) {
                    if (this.type.fromKeyValid() && this.__parent.cmp.compare(fromKey, this.fromKey) < 0) {
                        throw new java.lang.IllegalArgumentException("subMap: " + fromKey + " less than " + this.fromKey);
                    }
                    if (this.type.toKeyValid()) {
                        return this.subMap(fromKey, fromInclusive, this.toKey, this.toInclusive);
                    }
                    else {
                        return this.tailMap(fromKey, fromInclusive);
                    }
                }
                /**
                 *
                 * @param {*} fromKey
                 * @param {boolean} fromInclusive
                 * @return {*}
                 */
                tailMap(fromKey, fromInclusive) {
                    if (((fromKey != null) || fromKey === null) && ((typeof fromInclusive === 'boolean') || fromInclusive === null)) {
                        return this.tailMap$java_lang_Object$boolean(fromKey, fromInclusive);
                    }
                    else if (((fromKey != null) || fromKey === null) && fromInclusive === undefined) {
                        return this.tailMap$java_lang_Object(fromKey);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /**
                 *
                 * @return {*}
                 */
                descendingEntryIterator() {
                    return new TreeMap.DescendingEntryIterator(this.__parent, this.type, this.fromKey, this.fromInclusive, this.toKey, this.toInclusive);
                }
                /**
                 *
                 * @return {*}
                 */
                entryIterator() {
                    return new TreeMap.EntryIterator(this.__parent, this.type, this.fromKey, this.fromInclusive, this.toKey, this.toInclusive);
                }
                /**
                 *
                 * @param {*} key
                 * @return {*}
                 */
                getEntry(key) {
                    return this.guardInRange(this.getEntry(key));
                }
                /**
                 *
                 * @return {*}
                 */
                getFirstEntry() {
                    let entry;
                    if (this.type.fromKeyValid()) {
                        if (this.fromInclusive) {
                            entry = this.getCeilingEntry(this.fromKey);
                        }
                        else {
                            entry = this.getHigherEntry(this.fromKey);
                        }
                    }
                    else {
                        entry = this.getFirstEntry();
                    }
                    return this.guardInRange(entry);
                }
                /**
                 *
                 * @return {*}
                 */
                getLastEntry() {
                    let entry;
                    if (this.type.toKeyValid()) {
                        if (this.toInclusive) {
                            entry = this.getFloorEntry(this.toKey);
                        }
                        else {
                            entry = this.getLowerEntry(this.toKey);
                        }
                    }
                    else {
                        entry = this.getLastEntry();
                    }
                    return this.guardInRange(entry);
                }
                /**
                 *
                 * @param {*} key
                 * @return {*}
                 */
                getCeilingEntry(key) {
                    return this.guardInRange(this.getCeilingEntry(key));
                }
                /**
                 *
                 * @param {*} key
                 * @return {*}
                 */
                getFloorEntry(key) {
                    return this.guardInRange(this.getFloorEntry(key));
                }
                /**
                 *
                 * @param {*} key
                 * @return {*}
                 */
                getHigherEntry(key) {
                    return this.guardInRange(this.getHigherEntry(key));
                }
                /**
                 *
                 * @param {*} key
                 * @return {*}
                 */
                getLowerEntry(key) {
                    return this.guardInRange(this.getLowerEntry(key));
                }
                /**
                 *
                 * @param {*} entry
                 * @return {boolean}
                 */
                removeEntry(entry) {
                    return this.inRange(entry.getKey()) && this.removeEntry(entry);
                }
                guardInRange(entry) {
                    return entry != null && this.inRange(entry.getKey()) ? entry : null;
                }
                inRange(key) {
                    return this.__parent.inRange(this.type, key, this.fromKey, this.fromInclusive, this.toKey, this.toInclusive);
                }
            }
            TreeMap.SubMap = SubMap;
            SubMap["__class"] = "java.util.TreeMap.SubMap";
            SubMap["__interfaces"] = ["java.util.Map", "java.util.NavigableMap", "java.util.SortedMap"];
            (function (SubMap) {
                class SubMap$0 extends TreeMap.SubMap.EntrySet {
                    constructor(__parent) {
                        super(__parent);
                        this.__parent = __parent;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    isEmpty() {
                        return this.isEmpty();
                    }
                }
                SubMap.SubMap$0 = SubMap$0;
                SubMap$0["__interfaces"] = ["java.util.Collection", "java.util.Set", "java.lang.Iterable"];
            })(SubMap = TreeMap.SubMap || (TreeMap.SubMap = {}));
            class SubMapType {
                constructor() {
                }
                /**
                 * Returns true if this submap type uses a from-key.
                 * @return {boolean}
                 */
                fromKeyValid() {
                    return false;
                }
                /**
                 * Returns true if this submap type uses a to-key.
                 * @return {boolean}
                 */
                toKeyValid() {
                    return false;
                }
            }
            TreeMap.SubMapType = SubMapType;
            SubMapType["__class"] = "java.util.TreeMap.SubMapType";
            class SubMapTypeHead extends TreeMap.SubMapType {
                constructor() {
                    super();
                }
                /**
                 *
                 * @return {boolean}
                 */
                toKeyValid() {
                    return true;
                }
            }
            TreeMap.SubMapTypeHead = SubMapTypeHead;
            SubMapTypeHead["__class"] = "java.util.TreeMap.SubMapTypeHead";
            class SubMapTypeRange extends TreeMap.SubMapType {
                constructor() {
                    super();
                }
                /**
                 *
                 * @return {boolean}
                 */
                fromKeyValid() {
                    return true;
                }
                /**
                 *
                 * @return {boolean}
                 */
                toKeyValid() {
                    return true;
                }
            }
            TreeMap.SubMapTypeRange = SubMapTypeRange;
            SubMapTypeRange["__class"] = "java.util.TreeMap.SubMapTypeRange";
            class SubMapTypeTail extends TreeMap.SubMapType {
                constructor() {
                    super();
                }
                /**
                 *
                 * @return {boolean}
                 */
                fromKeyValid() {
                    return true;
                }
            }
            TreeMap.SubMapTypeTail = SubMapTypeTail;
            SubMapTypeTail["__class"] = "java.util.TreeMap.SubMapTypeTail";
        })(TreeMap = util.TreeMap || (util.TreeMap = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var lang;
    (function (lang) {
        class System {
            static __static_initialize() { if (!System.__static_initialized) {
                System.__static_initialized = true;
                System.__static_initializer_0();
            } }
            static ENVIRONMENT_IS_WEB_$LI$() { System.__static_initialize(); if (System.ENVIRONMENT_IS_WEB == null)
                System.ENVIRONMENT_IS_WEB = java.util.Objects.equals(typeof window, "object"); return System.ENVIRONMENT_IS_WEB; }
            ;
            static ENVIRONMENT_IS_WORKER_$LI$() { System.__static_initialize(); if (System.ENVIRONMENT_IS_WORKER == null)
                System.ENVIRONMENT_IS_WORKER = java.util.Objects.equals(typeof importScripts, "function"); return System.ENVIRONMENT_IS_WORKER; }
            ;
            static ENVIRONMENT_IS_NODE_$LI$() { System.__static_initialize(); if (System.ENVIRONMENT_IS_NODE == null)
                System.ENVIRONMENT_IS_NODE = !System.ENVIRONMENT_IS_WEB_$LI$() && !System.ENVIRONMENT_IS_WORKER_$LI$() && java.util.Objects.equals((eval("typeof process")), "object") && java.util.Objects.equals((eval("typeof require")), "function"); return System.ENVIRONMENT_IS_NODE; }
            ;
            static ENVIRONMENT_IS_SHELL_$LI$() { System.__static_initialize(); if (System.ENVIRONMENT_IS_SHELL == null)
                System.ENVIRONMENT_IS_SHELL = !System.ENVIRONMENT_IS_WEB_$LI$() && !System.ENVIRONMENT_IS_WORKER_$LI$() && !System.ENVIRONMENT_IS_NODE_$LI$(); return System.ENVIRONMENT_IS_SHELL; }
            ;
            static propertyMap_$LI$() { System.__static_initialize(); return System.propertyMap; }
            ;
            static err_$LI$() { System.__static_initialize(); return System.err; }
            ;
            static out_$LI$() { System.__static_initialize(); return System.out; }
            ;
            static in_$LI$() { System.__static_initialize(); return System.in; }
            ;
            static __static_initializer_0() {
                System.propertyMap = (new java.util.HashMap());
                System.propertyMap_$LI$().put("java.vendor", "JSweet");
                System.propertyMap_$LI$().put("java.vendor.url", "http://www.jsweet.org");
                System.propertyMap_$LI$().put("java.version", "jsweet");
                let tmpDir = "";
                let lineSeparator = "\n";
                let fileSeparator = "/";
                let userHome = "";
                let userName = "";
                let osArch = "";
                if (System.ENVIRONMENT_IS_WEB_$LI$() || System.ENVIRONMENT_IS_WORKER_$LI$()) {
                    System.propertyMap_$LI$().put("os.name", System.ENVIRONMENT_IS_WEB_$LI$() ? "WEB" : "WEB-WORKER");
                    System.propertyMap_$LI$().put("os.version", navigator.userAgent);
                    let pathname = document.location.pathname;
                    System.propertyMap_$LI$().put("user.dir", pathname.substring(0, pathname.lastIndexOf("/")));
                }
                else if (System.ENVIRONMENT_IS_NODE_$LI$()) {
                    let os = (eval("global.os || (global.os = require(\"os\"))"));
                    let path = (eval("global.path || (global.path = require(\"path\"))"));
                    System.propertyMap_$LI$().put("os.name", "NODE");
                    System.propertyMap_$LI$().put("os.version", (eval("process.version")));
                    System.propertyMap_$LI$().put("user.dir", (eval("process.cwd()")));
                    tmpDir = ((os["tmpdir"])());
                    lineSeparator = (os["EOL"]);
                    fileSeparator = (path["sep"]);
                    userHome = ((os["homedir"])());
                    userName = (((os["userInfo"])())["username"]);
                    osArch = ((os["arch"])());
                }
                else {
                    console = (new Object());
                    console["info"] = print;
                    console["error"] = java.util.Objects.equals((eval("typeof printErr")), "undefined") ? print : eval("printErr");
                    System.propertyMap_$LI$().put("os.name", "SHELL");
                    let runnerName = "UNKNOWN";
                    let userDir = ".";
                    if (java.util.Objects.equals((eval("typeof environment")), "object")) {
                        runnerName = "RHINO";
                        userDir = (eval("environment[\"user.dir\"]"));
                        lineSeparator = (eval("environment[\"line.separator\"]"));
                        fileSeparator = (eval("environment[\"file.separator\"]"));
                        userHome = (eval("environment[\"user.name\"]"));
                        userName = (eval("environment[\"user.home\"]"));
                        osArch = (eval("environment[\"os.arch\"]"));
                    }
                    else if (java.util.Objects.equals((eval("typeof jscOptions")), "function")) {
                        runnerName = "JSC";
                    }
                    System.propertyMap_$LI$().put("os.version", runnerName);
                    System.propertyMap_$LI$().put("user.dir", userDir);
                }
                System.propertyMap_$LI$().put("java.io.tmpdir", tmpDir);
                System.propertyMap_$LI$().put("line.separator", lineSeparator);
                System.propertyMap_$LI$().put("file.separator", fileSeparator);
                System.propertyMap_$LI$().put("user.home", userHome);
                System.propertyMap_$LI$().put("user.name", userName);
                System.propertyMap_$LI$().put("os.arch", osArch);
                System.out = new java.io.PrintStream(new System.System$0());
                System.err = new java.io.PrintStream(new System.System$1());
                System.in = new System.System$2();
            }
            static arraycopy(src, srcOfs, dest, destOfs, len) {
                javaemul.internal.InternalPreconditions.checkNotNull(src, "src");
                javaemul.internal.InternalPreconditions.checkNotNull(dest, "dest");
                let srclen = javaemul.internal.ArrayHelper.getLength(src);
                let destlen = javaemul.internal.ArrayHelper.getLength(dest);
                if (srcOfs < 0 || destOfs < 0 || len < 0 || srcOfs + len > srclen || destOfs + len > destlen) {
                    throw new java.lang.IndexOutOfBoundsException();
                }
                if (len > 0) {
                    javaemul.internal.ArrayHelper.copy$java_lang_Object$int$java_lang_Object$int$int(src, srcOfs, dest, destOfs, len);
                }
            }
            static currentTimeMillis() {
                return (n => n < 0 ? Math.ceil(n) : Math.floor(n))(javaemul.internal.DateUtil.now());
            }
            static gc() {
                (() => {
                    let gcFun = (eval("this.gc"));
                    if (java.util.Objects.equals(typeof gcFun, "function")) {
                        gcFun();
                    }
                }).apply(null);
            }
            static getProperty$java_lang_String(key) {
                return System.propertyMap_$LI$() == null ? null : System.propertyMap_$LI$().get(key);
            }
            static getProperty$java_lang_String$java_lang_String(key, def) {
                let prop = System.getProperty$java_lang_String(key);
                return prop == null ? def : prop;
            }
            static getProperty(key, def) {
                if (((typeof key === 'string') || key === null) && ((typeof def === 'string') || def === null)) {
                    return java.lang.System.getProperty$java_lang_String$java_lang_String(key, def);
                }
                else if (((typeof key === 'string') || key === null) && def === undefined) {
                    return java.lang.System.getProperty$java_lang_String(key);
                }
                else
                    throw new Error('invalid overload');
            }
            static identityHashCode(o) {
                return javaemul.internal.HashCodes.getIdentityHashCode(o);
            }
            static setErr(err) {
                java.lang.System.err = err;
            }
            static setOut(out) {
                java.lang.System.out = out;
            }
            static lineSeparator() {
                return System.getProperty$java_lang_String("line.separator");
            }
            static exit(status) {
                if (System.ENVIRONMENT_IS_NODE_$LI$()) {
                    eval("process.exit(" + status + ")");
                }
                else if (System.ENVIRONMENT_IS_WEB_$LI$()) {
                    window.close();
                }
                else if (System.ENVIRONMENT_IS_WORKER_$LI$()) {
                    self.close();
                }
                else {
                    if (java.util.Objects.equals(typeof eval("quit"), "function")) {
                        eval("quit(" + status + ")");
                    }
                    if (java.util.Objects.equals(typeof eval("exit"), "function")) {
                        eval("exit(" + status + ")");
                    }
                }
            }
        }
        System.__static_initialized = false;
        lang.System = System;
        System["__class"] = "java.lang.System";
        (function (System) {
            class System$0 extends java.io.OutputStream {
                constructor() {
                    super();
                    this.sep = java.lang.System.propertyMap_$LI$().get("line.separator");
                    this.toOut = "";
                }
                write(buffer, offset, count) {
                    if (((buffer != null && buffer instanceof Array && (buffer.length == 0 || buffer[0] == null || (typeof buffer[0] === 'number'))) || buffer === null) && ((typeof offset === 'number') || offset === null) && ((typeof count === 'number') || count === null)) {
                        super.write(buffer, offset, count);
                    }
                    else if (((buffer != null && buffer instanceof Array && (buffer.length == 0 || buffer[0] == null || (typeof buffer[0] === 'number'))) || buffer === null) && offset === undefined && count === undefined) {
                        return this.write$byte_A(buffer);
                    }
                    else if (((typeof buffer === 'number') || buffer === null) && offset === undefined && count === undefined) {
                        return this.write$int(buffer);
                    }
                    else
                        throw new Error('invalid overload');
                }
                write$int(i) {
                    this.toOut += String.fromCharCode(i);
                    if (((str, searchString) => { let pos = str.length - searchString.length; let lastIndex = str.indexOf(searchString, pos); return lastIndex !== -1 && lastIndex === pos; })(this.toOut, this.sep)) {
                        this.flush();
                    }
                }
                /**
                 *
                 */
                flush() {
                    super.flush();
                    if (!(this.toOut.length === 0)) {
                        if (((str, searchString) => { let pos = str.length - searchString.length; let lastIndex = str.indexOf(searchString, pos); return lastIndex !== -1 && lastIndex === pos; })(this.toOut, this.sep)) {
                            this.toOut = this.toOut.substring(0, this.toOut.length - this.sep.length);
                        }
                        console.info(this.toOut);
                        this.toOut = "";
                    }
                }
            }
            System.System$0 = System$0;
            System$0["__interfaces"] = ["java.io.Closeable", "java.lang.AutoCloseable", "java.io.Flushable"];
            class System$1 extends java.io.OutputStream {
                constructor() {
                    super();
                    this.sep = java.lang.System.propertyMap_$LI$().get("line.separator");
                    this.toOut = "";
                }
                write(buffer, offset, count) {
                    if (((buffer != null && buffer instanceof Array && (buffer.length == 0 || buffer[0] == null || (typeof buffer[0] === 'number'))) || buffer === null) && ((typeof offset === 'number') || offset === null) && ((typeof count === 'number') || count === null)) {
                        super.write(buffer, offset, count);
                    }
                    else if (((buffer != null && buffer instanceof Array && (buffer.length == 0 || buffer[0] == null || (typeof buffer[0] === 'number'))) || buffer === null) && offset === undefined && count === undefined) {
                        return this.write$byte_A(buffer);
                    }
                    else if (((typeof buffer === 'number') || buffer === null) && offset === undefined && count === undefined) {
                        return this.write$int(buffer);
                    }
                    else
                        throw new Error('invalid overload');
                }
                write$int(i) {
                    this.toOut += String.fromCharCode(i);
                    if (((str, searchString) => { let pos = str.length - searchString.length; let lastIndex = str.indexOf(searchString, pos); return lastIndex !== -1 && lastIndex === pos; })(this.toOut, this.sep)) {
                        this.flush();
                    }
                }
                /**
                 *
                 */
                flush() {
                    super.flush();
                    if (!(this.toOut.length === 0)) {
                        if (((str, searchString) => { let pos = str.length - searchString.length; let lastIndex = str.indexOf(searchString, pos); return lastIndex !== -1 && lastIndex === pos; })(this.toOut, this.sep)) {
                            this.toOut = this.toOut.substring(0, this.toOut.length - this.sep.length);
                        }
                        console.error(this.toOut);
                        this.toOut = "";
                    }
                }
            }
            System.System$1 = System$1;
            System$1["__interfaces"] = ["java.io.Closeable", "java.lang.AutoCloseable", "java.io.Flushable"];
            class System$2 extends java.io.InputStream {
                constructor() {
                    super();
                    this.where = 0;
                    this.sep = java.lang.System.propertyMap_$LI$().get("line.separator");
                    this.readerFunction = () => {
                        let result = null;
                        if (java.lang.System.ENVIRONMENT_IS_NODE_$LI$()) {
                            let fs = (eval("global.fs || (global.fs = require(\"fs\"))"));
                            let BUFSIZE = 256;
                            let buf = (new (eval("Buffer"))(BUFSIZE));
                            let fd = (eval("process.stdin.fd"));
                            let usingDevice = false;
                            try {
                                fd = ((fs["openSync"])(("/dev/stdin"), ("r")));
                                usingDevice = true;
                            }
                            catch (ignored) {
                            }
                            ;
                            let bytesRead = 0;
                            try {
                                bytesRead = ((fs["readSync"])(((fd)), buf, ((0)), ((BUFSIZE)), null));
                            }
                            catch (e) {
                                if (e.toString().indexOf("EOF") === -1)
                                    throw e;
                            }
                            ;
                            if (usingDevice)
                                (fs["closeSync"])(((fd)));
                            if (bytesRead > 0)
                                result = (buf).slice(0, bytesRead).toString();
                        }
                        else if (java.lang.System.ENVIRONMENT_IS_WEB_$LI$() || java.lang.System.ENVIRONMENT_IS_WORKER_$LI$()) {
                            if (java.util.Objects.equals(typeof window["prompt"], "function")) {
                                result = window.prompt("Input: ");
                                if (result != null) {
                                    result += this.sep;
                                }
                            }
                        }
                        else if (java.util.Objects.equals(typeof eval("readline"), "function")) {
                            result = (eval("readline()"));
                            if (result != null) {
                                result += this.sep;
                            }
                        }
                        return result;
                    };
                    if (this.readData === undefined)
                        this.readData = null;
                }
                read(buffer, byteOffset, byteCount) {
                    if (((buffer != null && buffer instanceof Array && (buffer.length == 0 || buffer[0] == null || (typeof buffer[0] === 'number'))) || buffer === null) && ((typeof byteOffset === 'number') || byteOffset === null) && ((typeof byteCount === 'number') || byteCount === null)) {
                        super.read(buffer, byteOffset, byteCount);
                    }
                    else if (((buffer != null && buffer instanceof Array && (buffer.length == 0 || buffer[0] == null || (typeof buffer[0] === 'number'))) || buffer === null) && byteOffset === undefined && byteCount === undefined) {
                        return this.read$byte_A(buffer);
                    }
                    else if (buffer === undefined && byteOffset === undefined && byteCount === undefined) {
                        return this.read$();
                    }
                    else
                        throw new Error('invalid overload');
                }
                read$() {
                    if (this.readData == null) {
                        this.readData = ((target => (typeof target === 'function') ? target() : target.get())(this.readerFunction)).split('');
                        this.where = 0;
                    }
                    else {
                        ++this.where;
                    }
                    if (this.where === this.readData.length) {
                        this.readData = null;
                        this.where = 0;
                        return -1;
                    }
                    return (this.readData[this.where]).charCodeAt(0);
                }
            }
            System.System$2 = System$2;
            System$2["__interfaces"] = ["java.io.Closeable", "java.lang.AutoCloseable"];
        })(System = lang.System || (lang.System = {}));
    })(lang = java.lang || (java.lang = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        class Hashtable extends java.util.HashMap {
            constructor(ignored, alsoIgnored) {
                if (((typeof ignored === 'number') || ignored === null) && ((typeof alsoIgnored === 'number') || alsoIgnored === null)) {
                    let __args = arguments;
                    super(ignored, alsoIgnored);
                }
                else if (((ignored != null && (ignored["__interfaces"] != null && ignored["__interfaces"].indexOf("java.util.Map") >= 0 || ignored.constructor != null && ignored.constructor["__interfaces"] != null && ignored.constructor["__interfaces"].indexOf("java.util.Map") >= 0)) || ignored === null) && alsoIgnored === undefined) {
                    let __args = arguments;
                    let toBeCopied = __args[0];
                    super(toBeCopied);
                }
                else if (((typeof ignored === 'number') || ignored === null) && alsoIgnored === undefined) {
                    let __args = arguments;
                    super(ignored);
                }
                else if (ignored === undefined && alsoIgnored === undefined) {
                    let __args = arguments;
                    super();
                }
                else
                    throw new Error('invalid overload');
            }
            keys() {
                let it = this.keySet().iterator();
                return new Hashtable.Hashtable$0(this, it);
            }
            elements() {
                let it = this.values().iterator();
                return new Hashtable.Hashtable$1(this, it);
            }
        }
        Hashtable.serialVersionUID = 1;
        util.Hashtable = Hashtable;
        Hashtable["__class"] = "java.util.Hashtable";
        Hashtable["__interfaces"] = ["java.lang.Cloneable", "java.util.Map", "java.util.Dictionary", "java.io.Serializable"];
        (function (Hashtable) {
            class Hashtable$0 {
                constructor(__parent, it) {
                    this.it = it;
                    this.__parent = __parent;
                }
                /**
                 *
                 * @return {boolean}
                 */
                hasMoreElements() {
                    return this.it.hasNext();
                }
                /**
                 *
                 * @return {*}
                 */
                nextElement() {
                    return this.it.next();
                }
            }
            Hashtable.Hashtable$0 = Hashtable$0;
            Hashtable$0["__interfaces"] = ["java.util.Enumeration"];
            class Hashtable$1 {
                constructor(__parent, it) {
                    this.it = it;
                    this.__parent = __parent;
                }
                /**
                 *
                 * @return {boolean}
                 */
                hasMoreElements() {
                    return this.it.hasNext();
                }
                /**
                 *
                 * @return {*}
                 */
                nextElement() {
                    return this.it.next();
                }
            }
            Hashtable.Hashtable$1 = Hashtable$1;
            Hashtable$1["__interfaces"] = ["java.util.Enumeration"];
        })(Hashtable = util.Hashtable || (util.Hashtable = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        /**
         * Hash table implementation of the Map interface with predictable iteration
         * order. <a href=
         * "http://java.sun.com/j2se/1.5.0/docs/api/java/util/LinkedHashMap.html">[Sun
         * docs]</a>
         *
         * @param <K>
         * key type.
         * @param <V>
         * value type.
         * @param {number} ignored
         * @param {number} alsoIgnored
         * @param {boolean} accessOrder
         * @class
         * @extends java.util.HashMap
         */
        class LinkedHashMap extends java.util.HashMap {
            constructor(ignored, alsoIgnored, accessOrder) {
                if (((typeof ignored === 'number') || ignored === null) && ((typeof alsoIgnored === 'number') || alsoIgnored === null) && ((typeof accessOrder === 'boolean') || accessOrder === null)) {
                    let __args = arguments;
                    super(ignored, alsoIgnored);
                    if (this.accessOrder === undefined)
                        this.accessOrder = false;
                    if (this.head === undefined)
                        this.head = null;
                    if (this.map === undefined)
                        this.map = null;
                    if (this.accessOrder === undefined)
                        this.accessOrder = false;
                    if (this.head === undefined)
                        this.head = null;
                    if (this.map === undefined)
                        this.map = null;
                    (() => {
                        this.head = new LinkedHashMap.ChainEntry(this);
                        this.map = (new java.util.HashMap());
                        this.accessOrder = accessOrder;
                        this.resetChainEntries();
                    })();
                }
                else if (((typeof ignored === 'number') || ignored === null) && ((typeof alsoIgnored === 'number') || alsoIgnored === null) && accessOrder === undefined) {
                    let __args = arguments;
                    super(ignored, alsoIgnored);
                    if (this.accessOrder === undefined)
                        this.accessOrder = false;
                    if (this.head === undefined)
                        this.head = null;
                    if (this.map === undefined)
                        this.map = null;
                    if (this.accessOrder === undefined)
                        this.accessOrder = false;
                    if (this.head === undefined)
                        this.head = null;
                    if (this.map === undefined)
                        this.map = null;
                    (() => {
                        this.head = new LinkedHashMap.ChainEntry(this);
                        this.map = (new java.util.HashMap());
                        this.resetChainEntries();
                    })();
                }
                else if (((ignored != null && (ignored["__interfaces"] != null && ignored["__interfaces"].indexOf("java.util.Map") >= 0 || ignored.constructor != null && ignored.constructor["__interfaces"] != null && ignored.constructor["__interfaces"].indexOf("java.util.Map") >= 0)) || ignored === null) && alsoIgnored === undefined && accessOrder === undefined) {
                    let __args = arguments;
                    let toBeCopied = __args[0];
                    super();
                    if (this.accessOrder === undefined)
                        this.accessOrder = false;
                    if (this.head === undefined)
                        this.head = null;
                    if (this.map === undefined)
                        this.map = null;
                    if (this.accessOrder === undefined)
                        this.accessOrder = false;
                    if (this.head === undefined)
                        this.head = null;
                    if (this.map === undefined)
                        this.map = null;
                    (() => {
                        this.head = new LinkedHashMap.ChainEntry(this);
                        this.map = (new java.util.HashMap());
                        this.resetChainEntries();
                        this.putAll(toBeCopied);
                    })();
                }
                else if (((typeof ignored === 'number') || ignored === null) && alsoIgnored === undefined && accessOrder === undefined) {
                    let __args = arguments;
                    {
                        let __args = arguments;
                        let alsoIgnored = 0;
                        super(ignored, alsoIgnored);
                        if (this.accessOrder === undefined)
                            this.accessOrder = false;
                        if (this.head === undefined)
                            this.head = null;
                        if (this.map === undefined)
                            this.map = null;
                        if (this.accessOrder === undefined)
                            this.accessOrder = false;
                        if (this.head === undefined)
                            this.head = null;
                        if (this.map === undefined)
                            this.map = null;
                        (() => {
                            this.head = new LinkedHashMap.ChainEntry(this);
                            this.map = (new java.util.HashMap());
                            this.resetChainEntries();
                        })();
                    }
                }
                else if (ignored === undefined && alsoIgnored === undefined && accessOrder === undefined) {
                    let __args = arguments;
                    super();
                    if (this.accessOrder === undefined)
                        this.accessOrder = false;
                    if (this.head === undefined)
                        this.head = null;
                    if (this.map === undefined)
                        this.map = null;
                    if (this.accessOrder === undefined)
                        this.accessOrder = false;
                    if (this.head === undefined)
                        this.head = null;
                    if (this.map === undefined)
                        this.map = null;
                    (() => {
                        this.head = new LinkedHashMap.ChainEntry(this);
                        this.map = (new java.util.HashMap());
                        this.resetChainEntries();
                    })();
                }
                else
                    throw new Error('invalid overload');
            }
            merge(key, value, map) {
                let old = this.get(key);
                let next = (old == null) ? value : (target => (typeof target === 'function') ? target(old, value) : target.apply(old, value))(map);
                if (next == null) {
                    this.remove(key);
                }
                else {
                    this.put(key, next);
                }
                return next;
            }
            computeIfAbsent(key, mappingFunction) {
                let result;
                if ((result = this.get(key)) == null) {
                    result = (target => (typeof target === 'function') ? target(key) : target.apply(key))(mappingFunction);
                    if (result != null)
                        this.put(key, result);
                }
                return result;
            }
            /**
             *
             */
            clear() {
                this.map.clear();
                this.resetChainEntries();
            }
            resetChainEntries() {
                this.head.prev = this.head;
                this.head.next = this.head;
            }
            /**
             *
             * @return {*}
             */
            clone() {
                return (new LinkedHashMap(this));
            }
            /**
             *
             * @param {*} key
             * @return {boolean}
             */
            containsKey(key) {
                return this.map.containsKey(key);
            }
            /**
             *
             * @param {*} value
             * @return {boolean}
             */
            containsValue(value) {
                let node = this.head.next;
                while ((node !== this.head)) {
                    {
                        if (java.util.Objects.equals(node.getValue(), value)) {
                            return true;
                        }
                        node = node.next;
                    }
                }
                ;
                return false;
            }
            /**
             *
             * @return {*}
             */
            entrySet() {
                return new LinkedHashMap.__java_util_LinkedHashMap_EntrySet(this);
            }
            /**
             *
             * @param {*} key
             * @return {*}
             */
            get(key) {
                let entry = this.map.get(key);
                if (entry != null) {
                    this.recordAccess(entry);
                    return entry.getValue();
                }
                return null;
            }
            /**
             *
             * @param {*} key
             * @param {*} value
             * @return {*}
             */
            put(key, value) {
                let old = this.map.get(key);
                if (old == null) {
                    let newEntry = new LinkedHashMap.ChainEntry(this, key, value);
                    this.map.put(key, newEntry);
                    newEntry.addToEnd();
                    let eldest = this.head.next;
                    if (this.removeEldestEntry(eldest)) {
                        eldest.remove();
                        this.map.remove(eldest.getKey());
                    }
                    return null;
                }
                else {
                    let oldValue = old.setValue(value);
                    this.recordAccess(old);
                    return oldValue;
                }
            }
            /**
             *
             * @param {*} key
             * @return {*}
             */
            remove(key) {
                let entry = this.map.remove(key);
                if (entry != null) {
                    entry.remove();
                    return entry.getValue();
                }
                return null;
            }
            /**
             *
             * @return {number}
             */
            size() {
                return this.map.size();
            }
            removeEldestEntry(eldest) {
                return false;
            }
            recordAccess(entry) {
                if (this.accessOrder) {
                    entry.remove();
                    entry.addToEnd();
                }
            }
        }
        util.LinkedHashMap = LinkedHashMap;
        LinkedHashMap["__class"] = "java.util.LinkedHashMap";
        LinkedHashMap["__interfaces"] = ["java.lang.Cloneable", "java.util.Map", "java.io.Serializable"];
        (function (LinkedHashMap) {
            /**
             * The entry we use includes next/prev pointers for a doubly-linked circular
             * list with a head node. This reduces the special cases we have to deal
             * with in the list operations.
             *
             * Note that we duplicate the key from the underlying hash map so we can
             * find the eldest entry. The alternative would have been to modify HashMap
             * so more of the code was directly usable here, but this would have added
             * some overhead to HashMap, or to reimplement most of the HashMap code here
             * with small modifications. Paying a small storage cost only if you use
             * LinkedHashMap and minimizing code size seemed like a better tradeoff
             * @param {*} key
             * @param {*} value
             * @class
             * @extends java.util.AbstractMap.SimpleEntry
             */
            class ChainEntry extends util.AbstractMap.SimpleEntry {
                constructor(__parent, key = null, value = null) {
                    super(key, value);
                    this.__parent = __parent;
                    if (this.next === undefined)
                        this.next = null;
                    if (this.prev === undefined)
                        this.prev = null;
                }
                /**
                 * Add this node to the end of the chain.
                 */
                addToEnd() {
                    let tail = this.__parent.head.prev;
                    this.prev = tail;
                    this.next = this.__parent.head;
                    tail.next = this.__parent.head.prev = this;
                }
                /**
                 * Remove this node from any list it may be a part of.
                 */
                remove() {
                    this.next.prev = this.prev;
                    this.prev.next = this.next;
                    this.next = this.prev = null;
                }
            }
            LinkedHashMap.ChainEntry = ChainEntry;
            ChainEntry["__class"] = "java.util.LinkedHashMap.ChainEntry";
            ChainEntry["__interfaces"] = ["java.util.Map.Entry"];
            class __java_util_LinkedHashMap_EntrySet extends java.util.AbstractSet {
                constructor(__parent) {
                    super();
                    this.__parent = __parent;
                }
                /**
                 *
                 */
                clear() {
                    this.clear();
                }
                /**
                 *
                 * @param {*} o
                 * @return {boolean}
                 */
                contains(o) {
                    if (o != null && (o["__interfaces"] != null && o["__interfaces"].indexOf("java.util.Map.Entry") >= 0 || o.constructor != null && o.constructor["__interfaces"] != null && o.constructor["__interfaces"].indexOf("java.util.Map.Entry") >= 0)) {
                        return this.__parent.containsEntry(o);
                    }
                    return false;
                }
                /**
                 *
                 * @return {*}
                 */
                iterator() {
                    return new __java_util_LinkedHashMap_EntrySet.EntryIterator(this);
                }
                /**
                 *
                 * @param {*} entry
                 * @return {boolean}
                 */
                remove(entry) {
                    if (this.contains(entry)) {
                        let key = entry.getKey();
                        this.remove(key);
                        return true;
                    }
                    return false;
                }
                /**
                 *
                 * @return {number}
                 */
                size() {
                    return this.size();
                }
            }
            LinkedHashMap.__java_util_LinkedHashMap_EntrySet = __java_util_LinkedHashMap_EntrySet;
            __java_util_LinkedHashMap_EntrySet["__class"] = "java.util.LinkedHashMap.EntrySet";
            __java_util_LinkedHashMap_EntrySet["__interfaces"] = ["java.util.Collection", "java.util.Set", "java.lang.Iterable"];
            (function (__java_util_LinkedHashMap_EntrySet) {
                class EntryIterator {
                    constructor(__parent) {
                        this.__parent = __parent;
                        if (this.last === undefined)
                            this.last = null;
                        if (this.__next === undefined)
                            this.__next = null;
                        this.__next = __parent.__parent.head.next;
                        java.util.ConcurrentModificationDetector.recordLastKnownStructure(__parent.__parent.map, this);
                    }
                    forEachRemaining(consumer) {
                        javaemul.internal.InternalPreconditions.checkNotNull((consumer));
                        while ((this.hasNext())) {
                            {
                                (target => (typeof target === 'function') ? target(this.next()) : target.accept(this.next()))(consumer);
                            }
                        }
                        ;
                    }
                    /**
                     *
                     * @return {boolean}
                     */
                    hasNext() {
                        return this.__next !== this.__parent.__parent.head;
                    }
                    /**
                     *
                     * @return {*}
                     */
                    next() {
                        java.util.ConcurrentModificationDetector.checkStructuralChange(this.__parent.__parent.map, this);
                        javaemul.internal.InternalPreconditions.checkCriticalElement(this.hasNext());
                        this.last = this.__next;
                        this.__next = this.__next.next;
                        return this.last;
                    }
                    /**
                     *
                     */
                    remove() {
                        javaemul.internal.InternalPreconditions.checkState(this.last != null);
                        java.util.ConcurrentModificationDetector.checkStructuralChange(this.__parent.__parent.map, this);
                        this.last.remove();
                        this.__parent.__parent.map.remove(this.last.getKey());
                        java.util.ConcurrentModificationDetector.recordLastKnownStructure(this.__parent.__parent.map, this);
                        this.last = null;
                    }
                }
                __java_util_LinkedHashMap_EntrySet.EntryIterator = EntryIterator;
                EntryIterator["__class"] = "java.util.LinkedHashMap.EntrySet.EntryIterator";
                EntryIterator["__interfaces"] = ["java.util.Iterator"];
            })(__java_util_LinkedHashMap_EntrySet = LinkedHashMap.__java_util_LinkedHashMap_EntrySet || (LinkedHashMap.__java_util_LinkedHashMap_EntrySet = {}));
        })(LinkedHashMap = util.LinkedHashMap || (util.LinkedHashMap = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var nio;
    (function (nio) {
        var file;
        (function (file) {
            class Path {
                constructor(fullPath) {
                    if (this.fullPath === undefined)
                        this.fullPath = null;
                    this.fullPath = fullPath;
                }
                forEach(action) {
                    javaemul.internal.InternalPreconditions.checkNotNull((action));
                    for (let index187 = this.iterator(); index187.hasNext();) {
                        let t = index187.next();
                        {
                            (target => (typeof target === 'function') ? target(t) : target.accept(t))(action);
                        }
                    }
                }
                static PATH_SEPARATOR_$LI$() { if (Path.PATH_SEPARATOR == null)
                    Path.PATH_SEPARATOR = java.lang.System.getProperty("file.separator"); return Path.PATH_SEPARATOR; }
                ;
                compareTo$java_nio_file_Path(path) {
                    return this.toString().localeCompare(path.toString());
                }
                /**
                 *
                 * @param {java.nio.file.Path} path
                 * @return {number}
                 */
                compareTo(path) {
                    if (((path != null && path instanceof java.nio.file.Path) || path === null)) {
                        return this.compareTo$java_nio_file_Path(path);
                    }
                    else
                        throw new Error('invalid overload');
                }
                isAbsolute() {
                    return java.util.Objects.equals(Path.PATH_SEPARATOR_$LI$(), "/") ? this.fullPath.length > 0 && java.util.Objects.equals(this.fullPath.substring(0, 1), Path.PATH_SEPARATOR_$LI$()) : this.fullPath.length >= 3 && java.util.Objects.equals(this.fullPath.substring(1, 3), ":\\");
                }
                getFileName() {
                    return new Path(this.fullPath.substring(this.fullPath.lastIndexOf(Path.PATH_SEPARATOR_$LI$()) + Path.PATH_SEPARATOR_$LI$().length));
                }
                getParent() {
                    return new Path(this.fullPath.substring(0, this.fullPath.lastIndexOf(Path.PATH_SEPARATOR_$LI$())));
                }
                resolve$java_nio_file_Path(other) {
                    if (other.isAbsolute())
                        return other;
                    return new Path(this.fullPath + "/" + other.fullPath);
                }
                resolve(other) {
                    if (((other != null && other instanceof java.nio.file.Path) || other === null)) {
                        return this.resolve$java_nio_file_Path(other);
                    }
                    else if (((typeof other === 'string') || other === null)) {
                        return this.resolve$java_lang_String(other);
                    }
                    else
                        throw new Error('invalid overload');
                }
                resolve$java_lang_String(other) {
                    return this.resolve$java_nio_file_Path(java.nio.file.Paths.get(other));
                }
                toAbsolutePath() {
                    return java.nio.file.Paths.get(java.lang.System.getProperty$java_lang_String("user.dir")).resolve$java_nio_file_Path(this);
                }
                /**
                 *
                 * @return {*}
                 */
                iterator() {
                    return java.util.Arrays.asList(((this.fullPath).split(Path.PATH_SEPARATOR_$LI$()).map((str, i, arr) => this.isAbsolute() && i === 0 ? new Path(str + Path.PATH_SEPARATOR_$LI$()) : new Path(str)))).iterator();
                }
                /**
                 *
                 * @return {string}
                 */
                toString() {
                    return this.fullPath;
                }
            }
            file.Path = Path;
            Path["__class"] = "java.nio.file.Path";
            Path["__interfaces"] = ["java.lang.Comparable", "java.lang.Iterable"];
        })(file = nio.file || (nio.file = {}));
    })(nio = java.nio || (java.nio = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        /**
         * A helper to detect concurrent modifications to collections. This is implemented as a helper
         * utility so that we could remove the checks easily by a flag.
         * @class
         */
        class ConcurrentModificationDetector {
            static API_CHECK_$LI$() { if (ConcurrentModificationDetector.API_CHECK == null)
                ConcurrentModificationDetector.API_CHECK = ((o1, o2) => { if (o1 && o1.equals) {
                    return o1.equals(o2);
                }
                else {
                    return o1 === o2;
                } })(java.lang.System.getProperty("jre.checks.api", "ENABLED"), "ENABLED"); return ConcurrentModificationDetector.API_CHECK; }
            ;
            static structureChanged(map) {
                if (!ConcurrentModificationDetector.API_CHECK_$LI$()) {
                    return;
                }
                let modCount = javaemul.internal.JsUtils.getIntProperty(map, ConcurrentModificationDetector.MOD_COUNT_PROPERTY) | 0;
                javaemul.internal.JsUtils.setIntProperty(map, ConcurrentModificationDetector.MOD_COUNT_PROPERTY, modCount + 1);
            }
            static recordLastKnownStructure(host, iterator) {
                if (!ConcurrentModificationDetector.API_CHECK_$LI$()) {
                    return;
                }
                let modCount = javaemul.internal.JsUtils.getIntProperty(host, ConcurrentModificationDetector.MOD_COUNT_PROPERTY);
                javaemul.internal.JsUtils.setIntProperty(iterator, ConcurrentModificationDetector.MOD_COUNT_PROPERTY, modCount);
            }
            static checkStructuralChange(host, iterator) {
                if (!ConcurrentModificationDetector.API_CHECK_$LI$()) {
                    return;
                }
                if (javaemul.internal.JsUtils.getIntProperty(iterator, ConcurrentModificationDetector.MOD_COUNT_PROPERTY) !== javaemul.internal.JsUtils.getIntProperty(host, ConcurrentModificationDetector.MOD_COUNT_PROPERTY)) {
                    throw new java.util.ConcurrentModificationException();
                }
            }
        }
        ConcurrentModificationDetector.MOD_COUNT_PROPERTY = "_gwt_modCount";
        util.ConcurrentModificationDetector = ConcurrentModificationDetector;
        ConcurrentModificationDetector["__class"] = "java.util.ConcurrentModificationDetector";
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (java) {
    var util;
    (function (util) {
        var logging;
        (function (logging) {
            /**
             * An emulation of the java.util.logging.Logger class. See
             * <a href="http://java.sun.com/j2se/1.4.2/docs/api/java/util/logging/Logger.html">
             * The Java API doc for details</a>
             * @class
             */
            class Logger {
                constructor(name, resourceName) {
                    /*private*/ this.level = null;
                    if (this.handlers === undefined)
                        this.handlers = null;
                    if (this.name === undefined)
                        this.name = null;
                    if (this.parent === undefined)
                        this.parent = null;
                    if (this.useParentHandlers === undefined)
                        this.useParentHandlers = false;
                    if (Logger.LOGGING_FALSE_$LI$()) {
                        return;
                    }
                    this.name = name;
                    this.useParentHandlers = true;
                    this.handlers = (new java.util.ArrayList());
                }
                static __static_initialize() { if (!Logger.__static_initialized) {
                    Logger.__static_initialized = true;
                    Logger.__static_initializer_0();
                } }
                static LOGGING_ENABLED_$LI$() { Logger.__static_initialize(); if (Logger.LOGGING_ENABLED == null)
                    Logger.LOGGING_ENABLED = java.lang.System.getProperty("gwt.logging.enabled", "TRUE"); return Logger.LOGGING_ENABLED; }
                ;
                static LOGGING_WARNING_$LI$() { Logger.__static_initialize(); if (Logger.LOGGING_WARNING == null)
                    Logger.LOGGING_WARNING = ((o1, o2) => { if (o1 && o1.equals) {
                        return o1.equals(o2);
                    }
                    else {
                        return o1 === o2;
                    } })(Logger.LOGGING_ENABLED_$LI$(), "WARNING"); return Logger.LOGGING_WARNING; }
                ;
                static LOGGING_SEVERE_$LI$() { Logger.__static_initialize(); if (Logger.LOGGING_SEVERE == null)
                    Logger.LOGGING_SEVERE = ((o1, o2) => { if (o1 && o1.equals) {
                        return o1.equals(o2);
                    }
                    else {
                        return o1 === o2;
                    } })(Logger.LOGGING_ENABLED_$LI$(), "SEVERE"); return Logger.LOGGING_SEVERE; }
                ;
                static LOGGING_FALSE_$LI$() { Logger.__static_initialize(); if (Logger.LOGGING_FALSE == null)
                    Logger.LOGGING_FALSE = ((o1, o2) => { if (o1 && o1.equals) {
                        return o1.equals(o2);
                    }
                    else {
                        return o1 === o2;
                    } })(Logger.LOGGING_ENABLED_$LI$(), "FALSE"); return Logger.LOGGING_FALSE; }
                ;
                static __static_initializer_0() {
                    Logger.assertLoggingValues();
                }
                static getGlobal() {
                    return Logger.getLogger(Logger.GLOBAL_LOGGER_NAME);
                }
                static getLogger(name) {
                    if (Logger.LOGGING_FALSE_$LI$()) {
                        return new Logger(name, null);
                    }
                    return java.util.logging.LogManager.getLogManager().ensureLogger(name);
                }
                static assertLoggingValues() {
                    if (((o1, o2) => { if (o1 && o1.equals) {
                        return o1.equals(o2);
                    }
                    else {
                        return o1 === o2;
                    } })(Logger.LOGGING_ENABLED_$LI$(), "FALSE") || ((o1, o2) => { if (o1 && o1.equals) {
                        return o1.equals(o2);
                    }
                    else {
                        return o1 === o2;
                    } })(Logger.LOGGING_ENABLED_$LI$(), "TRUE") || ((o1, o2) => { if (o1 && o1.equals) {
                        return o1.equals(o2);
                    }
                    else {
                        return o1 === o2;
                    } })(Logger.LOGGING_ENABLED_$LI$(), "SEVERE") || ((o1, o2) => { if (o1 && o1.equals) {
                        return o1.equals(o2);
                    }
                    else {
                        return o1 === o2;
                    } })(Logger.LOGGING_ENABLED_$LI$(), "WARNING")) {
                        return;
                    }
                    throw new java.lang.RuntimeException("Undefined value for gwt.logging.enabled: \'" + Logger.LOGGING_ENABLED_$LI$() + "\'. Allowed values are TRUE, FALSE, SEVERE, WARNING");
                }
                addHandler(handler) {
                    if (Logger.LOGGING_FALSE_$LI$()) {
                        return;
                    }
                    this.handlers.add(handler);
                }
                config(msg) {
                    if (Logger.LOGGING_FALSE_$LI$() || Logger.LOGGING_SEVERE_$LI$() || Logger.LOGGING_WARNING_$LI$()) {
                        return;
                    }
                    this.log$java_util_logging_Level$java_lang_String(java.util.logging.Level.CONFIG_$LI$(), msg);
                }
                fine(msg) {
                    if (Logger.LOGGING_FALSE_$LI$() || Logger.LOGGING_SEVERE_$LI$() || Logger.LOGGING_WARNING_$LI$()) {
                        return;
                    }
                    this.log$java_util_logging_Level$java_lang_String(java.util.logging.Level.FINE_$LI$(), msg);
                }
                finer(msg) {
                    if (Logger.LOGGING_FALSE_$LI$() || Logger.LOGGING_SEVERE_$LI$() || Logger.LOGGING_WARNING_$LI$()) {
                        return;
                    }
                    this.log$java_util_logging_Level$java_lang_String(java.util.logging.Level.FINER_$LI$(), msg);
                }
                finest(msg) {
                    if (Logger.LOGGING_FALSE_$LI$() || Logger.LOGGING_SEVERE_$LI$() || Logger.LOGGING_WARNING_$LI$()) {
                        return;
                    }
                    this.log$java_util_logging_Level$java_lang_String(java.util.logging.Level.FINEST_$LI$(), msg);
                }
                info(msg) {
                    if (Logger.LOGGING_FALSE_$LI$() || Logger.LOGGING_SEVERE_$LI$() || Logger.LOGGING_WARNING_$LI$()) {
                        return;
                    }
                    this.log$java_util_logging_Level$java_lang_String(java.util.logging.Level.INFO_$LI$(), msg);
                }
                warning(msg) {
                    if (Logger.LOGGING_FALSE_$LI$() || Logger.LOGGING_SEVERE_$LI$()) {
                        return;
                    }
                    this.log$java_util_logging_Level$java_lang_String(java.util.logging.Level.WARNING_$LI$(), msg);
                }
                severe(msg) {
                    if (Logger.LOGGING_FALSE_$LI$()) {
                        return;
                    }
                    this.log$java_util_logging_Level$java_lang_String(java.util.logging.Level.SEVERE_$LI$(), msg);
                }
                getHandlers() {
                    if (Logger.LOGGING_FALSE_$LI$()) {
                        return [];
                    }
                    return this.handlers['toArray$java_lang_Object_A']((s => { let a = []; while (s-- > 0)
                        a.push(null); return a; })(this.handlers.size()));
                }
                getLevel() {
                    return Logger.LOGGING_FALSE_$LI$() ? null : this.level;
                }
                getName() {
                    return Logger.LOGGING_FALSE_$LI$() ? null : this.name;
                }
                getParent() {
                    return Logger.LOGGING_FALSE_$LI$() ? null : this.parent;
                }
                getUseParentHandlers() {
                    return Logger.LOGGING_FALSE_$LI$() ? false : this.useParentHandlers;
                }
                isLoggable(messageLevel) {
                    return Logger.LOGGING_FALSE_$LI$() ? false : this.getEffectiveLevel().intValue() <= messageLevel.intValue();
                }
                log$java_util_logging_Level$java_lang_String(level, msg) {
                    this.log$java_util_logging_Level$java_lang_String$java_lang_Throwable(level, msg, null);
                }
                log$java_util_logging_Level$java_lang_String$java_lang_Throwable(level, msg, thrown) {
                    if (Logger.LOGGING_FALSE_$LI$()) {
                        return;
                    }
                    if (Logger.LOGGING_SEVERE_$LI$()) {
                        if (level.intValue() >= 1000) {
                            this.actuallyLog$java_util_logging_Level$java_lang_String$java_lang_Throwable(level, msg, thrown);
                        }
                    }
                    else if (Logger.LOGGING_WARNING_$LI$()) {
                        if (level.intValue() >= java.util.logging.Level.WARNING_$LI$().intValue()) {
                            this.actuallyLog$java_util_logging_Level$java_lang_String$java_lang_Throwable(level, msg, thrown);
                        }
                    }
                    else {
                        this.actuallyLog$java_util_logging_Level$java_lang_String$java_lang_Throwable(level, msg, thrown);
                    }
                }
                log(level, msg, thrown) {
                    if (((level != null && level instanceof java.util.logging.Level) || level === null) && ((typeof msg === 'string') || msg === null) && ((thrown != null && thrown instanceof Error) || thrown === null)) {
                        return this.log$java_util_logging_Level$java_lang_String$java_lang_Throwable(level, msg, thrown);
                    }
                    else if (((level != null && level instanceof java.util.logging.Level) || level === null) && ((typeof msg === 'string') || msg === null) && thrown === undefined) {
                        return this.log$java_util_logging_Level$java_lang_String(level, msg);
                    }
                    else if (((level != null && level instanceof java.util.logging.LogRecord) || level === null) && msg === undefined && thrown === undefined) {
                        return this.log$java_util_logging_LogRecord(level);
                    }
                    else
                        throw new Error('invalid overload');
                }
                log$java_util_logging_LogRecord(record) {
                    if (Logger.LOGGING_FALSE_$LI$()) {
                        return;
                    }
                    if (Logger.LOGGING_SEVERE_$LI$()) {
                        if (record.getLevel().intValue() >= 1000) {
                            this.actuallyLog$java_util_logging_LogRecord(record);
                        }
                    }
                    else if (Logger.LOGGING_WARNING_$LI$()) {
                        if (record.getLevel().intValue() >= java.util.logging.Level.WARNING_$LI$().intValue()) {
                            this.actuallyLog$java_util_logging_LogRecord(record);
                        }
                    }
                    else {
                        this.actuallyLog$java_util_logging_LogRecord(record);
                    }
                }
                removeHandler(handler) {
                    if (Logger.LOGGING_FALSE_$LI$()) {
                        return;
                    }
                    this.handlers['remove$java_lang_Object'](handler);
                }
                setLevel(newLevel) {
                    if (Logger.LOGGING_FALSE_$LI$()) {
                        return;
                    }
                    this.level = newLevel;
                }
                setParent(newParent) {
                    if (Logger.LOGGING_FALSE_$LI$()) {
                        return;
                    }
                    if (newParent != null) {
                        this.parent = newParent;
                    }
                }
                setUseParentHandlers(newUseParentHandlers) {
                    if (Logger.LOGGING_FALSE_$LI$()) {
                        return;
                    }
                    this.useParentHandlers = newUseParentHandlers;
                }
                /*private*/ getEffectiveLevel() {
                    if (this.level != null) {
                        return this.level;
                    }
                    let logger = this.getParent();
                    while ((logger != null)) {
                        {
                            let effectiveLevel = logger.getLevel();
                            if (effectiveLevel != null) {
                                return effectiveLevel;
                            }
                            logger = logger.getParent();
                        }
                    }
                    ;
                    return java.util.logging.Level.INFO_$LI$();
                }
                actuallyLog$java_util_logging_Level$java_lang_String$java_lang_Throwable(level, msg, thrown) {
                    if (this.isLoggable(level)) {
                        let record = new java.util.logging.LogRecord(level, msg);
                        record.setThrown(thrown);
                        record.setLoggerName(this.getName());
                        this.actuallyLog$java_util_logging_LogRecord(record);
                    }
                }
                actuallyLog(level, msg, thrown) {
                    if (((level != null && level instanceof java.util.logging.Level) || level === null) && ((typeof msg === 'string') || msg === null) && ((thrown != null && thrown instanceof Error) || thrown === null)) {
                        return this.actuallyLog$java_util_logging_Level$java_lang_String$java_lang_Throwable(level, msg, thrown);
                    }
                    else if (((level != null && level instanceof java.util.logging.LogRecord) || level === null) && msg === undefined && thrown === undefined) {
                        return this.actuallyLog$java_util_logging_LogRecord(level);
                    }
                    else
                        throw new Error('invalid overload');
                }
                /*private*/ actuallyLog$java_util_logging_LogRecord(record) {
                    if (this.isLoggable(record.getLevel())) {
                        {
                            let array189 = this.getHandlers();
                            for (let index188 = 0; index188 < array189.length; index188++) {
                                let handler = array189[index188];
                                {
                                    handler.publish(record);
                                }
                            }
                        }
                        let logger = this.getUseParentHandlers() ? this.getParent() : null;
                        while ((logger != null)) {
                            {
                                {
                                    let array191 = logger.getHandlers();
                                    for (let index190 = 0; index190 < array191.length; index190++) {
                                        let handler = array191[index190];
                                        {
                                            handler.publish(record);
                                        }
                                    }
                                }
                                logger = logger.getUseParentHandlers() ? logger.getParent() : null;
                            }
                        }
                        ;
                    }
                }
            }
            Logger.__static_initialized = false;
            Logger.GLOBAL_LOGGER_NAME = "global";
            logging.Logger = Logger;
            Logger["__class"] = "java.util.logging.Logger";
        })(logging = util.logging || (util.logging = {}));
    })(util = java.util || (java.util = {}));
})(java || (java = {}));
(function (javaemul) {
    var internal;
    (function (internal) {
        /**
         * A utility class that provides utility functions to do precondition checks inside GWT-SDK.
         * @class
         */
        class InternalPreconditions {
            constructor() {
            }
            static CHECKED_MODE_$LI$() { if (InternalPreconditions.CHECKED_MODE == null)
                InternalPreconditions.CHECKED_MODE = ((o1, o2) => { if (o1 && o1.equals) {
                    return o1.equals(o2);
                }
                else {
                    return o1 === o2;
                } })(java.lang.System.getProperty("jre.checkedMode", "ENABLED"), "ENABLED"); return InternalPreconditions.CHECKED_MODE; }
            ;
            static TYPE_CHECK_$LI$() { if (InternalPreconditions.TYPE_CHECK == null)
                InternalPreconditions.TYPE_CHECK = ((o1, o2) => { if (o1 && o1.equals) {
                    return o1.equals(o2);
                }
                else {
                    return o1 === o2;
                } })(java.lang.System.getProperty("jre.checks.type", "ENABLED"), "ENABLED"); return InternalPreconditions.TYPE_CHECK; }
            ;
            static API_CHECK_$LI$() { if (InternalPreconditions.API_CHECK == null)
                InternalPreconditions.API_CHECK = ((o1, o2) => { if (o1 && o1.equals) {
                    return o1.equals(o2);
                }
                else {
                    return o1 === o2;
                } })(java.lang.System.getProperty("jre.checks.api", "ENABLED"), "ENABLED"); return InternalPreconditions.API_CHECK; }
            ;
            static BOUND_CHECK_$LI$() { if (InternalPreconditions.BOUND_CHECK == null)
                InternalPreconditions.BOUND_CHECK = ((o1, o2) => { if (o1 && o1.equals) {
                    return o1.equals(o2);
                }
                else {
                    return o1 === o2;
                } })(java.lang.System.getProperty("jre.checks.bounds", "ENABLED"), "ENABLED"); return InternalPreconditions.BOUND_CHECK; }
            ;
            static checkType(expression) {
                if (InternalPreconditions.TYPE_CHECK_$LI$()) {
                    InternalPreconditions.checkCriticalType(expression);
                }
                else if (InternalPreconditions.CHECKED_MODE_$LI$()) {
                    try {
                        InternalPreconditions.checkCriticalType(expression);
                    }
                    catch (e) {
                        throw new java.lang.AssertionError(e);
                    }
                    ;
                }
            }
            static checkCriticalType(expression) {
                if (!expression) {
                    throw new java.lang.ClassCastException();
                }
            }
            static checkArrayType$boolean(expression) {
                if (InternalPreconditions.TYPE_CHECK_$LI$()) {
                    InternalPreconditions.checkCriticalArrayType$boolean(expression);
                }
                else if (InternalPreconditions.CHECKED_MODE_$LI$()) {
                    try {
                        InternalPreconditions.checkCriticalArrayType$boolean(expression);
                    }
                    catch (e) {
                        throw new java.lang.AssertionError(e);
                    }
                    ;
                }
            }
            static checkCriticalArrayType$boolean(expression) {
                if (!expression) {
                    throw new java.lang.ArrayStoreException();
                }
            }
            static checkArrayType$boolean$java_lang_Object(expression, errorMessage) {
                if (InternalPreconditions.TYPE_CHECK_$LI$()) {
                    InternalPreconditions.checkCriticalArrayType$boolean$java_lang_Object(expression, errorMessage);
                }
                else if (InternalPreconditions.CHECKED_MODE_$LI$()) {
                    try {
                        InternalPreconditions.checkCriticalArrayType$boolean$java_lang_Object(expression, errorMessage);
                    }
                    catch (e) {
                        throw new java.lang.AssertionError(e);
                    }
                    ;
                }
            }
            /**
             * Ensures the truth of an expression that verifies array type.
             * @param {boolean} expression
             * @param {*} errorMessage
             */
            static checkArrayType(expression, errorMessage) {
                if (((typeof expression === 'boolean') || expression === null) && ((errorMessage != null) || errorMessage === null)) {
                    return javaemul.internal.InternalPreconditions.checkArrayType$boolean$java_lang_Object(expression, errorMessage);
                }
                else if (((typeof expression === 'boolean') || expression === null) && errorMessage === undefined) {
                    return javaemul.internal.InternalPreconditions.checkArrayType$boolean(expression);
                }
                else
                    throw new Error('invalid overload');
            }
            static checkCriticalArrayType$boolean$java_lang_Object(expression, errorMessage) {
                if (!expression) {
                    throw new java.lang.ArrayStoreException(/* valueOf */ new String(errorMessage).toString());
                }
            }
            static checkCriticalArrayType(expression, errorMessage) {
                if (((typeof expression === 'boolean') || expression === null) && ((errorMessage != null) || errorMessage === null)) {
                    return javaemul.internal.InternalPreconditions.checkCriticalArrayType$boolean$java_lang_Object(expression, errorMessage);
                }
                else if (((typeof expression === 'boolean') || expression === null) && errorMessage === undefined) {
                    return javaemul.internal.InternalPreconditions.checkCriticalArrayType$boolean(expression);
                }
                else
                    throw new Error('invalid overload');
            }
            static checkElement$boolean(expression) {
                if (InternalPreconditions.API_CHECK_$LI$()) {
                    InternalPreconditions.checkCriticalElement$boolean(expression);
                }
                else if (InternalPreconditions.CHECKED_MODE_$LI$()) {
                    try {
                        InternalPreconditions.checkCriticalElement$boolean(expression);
                    }
                    catch (e) {
                        throw new java.lang.AssertionError(e);
                    }
                    ;
                }
            }
            static checkCriticalElement$boolean(expression) {
                if (!expression) {
                    throw new java.util.NoSuchElementException();
                }
            }
            static checkElement$boolean$java_lang_Object(expression, errorMessage) {
                if (InternalPreconditions.API_CHECK_$LI$()) {
                    InternalPreconditions.checkCriticalElement$boolean$java_lang_Object(expression, errorMessage);
                }
                else if (InternalPreconditions.CHECKED_MODE_$LI$()) {
                    try {
                        InternalPreconditions.checkCriticalElement$boolean$java_lang_Object(expression, errorMessage);
                    }
                    catch (e) {
                        throw new java.lang.AssertionError(e);
                    }
                    ;
                }
            }
            /**
             * Ensures the truth of an expression involving existence of an element.
             * @param {boolean} expression
             * @param {*} errorMessage
             */
            static checkElement(expression, errorMessage) {
                if (((typeof expression === 'boolean') || expression === null) && ((errorMessage != null) || errorMessage === null)) {
                    return javaemul.internal.InternalPreconditions.checkElement$boolean$java_lang_Object(expression, errorMessage);
                }
                else if (((typeof expression === 'boolean') || expression === null) && errorMessage === undefined) {
                    return javaemul.internal.InternalPreconditions.checkElement$boolean(expression);
                }
                else
                    throw new Error('invalid overload');
            }
            static checkCriticalElement$boolean$java_lang_Object(expression, errorMessage) {
                if (!expression) {
                    throw new java.util.NoSuchElementException(/* valueOf */ new String(errorMessage).toString());
                }
            }
            /**
             * Ensures the truth of an expression involving existence of an element.
             * <p>
             * For cases where failing fast is pretty important and not failing early could cause bugs that
             * are much harder to debug.
             * @param {boolean} expression
             * @param {*} errorMessage
             */
            static checkCriticalElement(expression, errorMessage) {
                if (((typeof expression === 'boolean') || expression === null) && ((errorMessage != null) || errorMessage === null)) {
                    return javaemul.internal.InternalPreconditions.checkCriticalElement$boolean$java_lang_Object(expression, errorMessage);
                }
                else if (((typeof expression === 'boolean') || expression === null) && errorMessage === undefined) {
                    return javaemul.internal.InternalPreconditions.checkCriticalElement$boolean(expression);
                }
                else
                    throw new Error('invalid overload');
            }
            static checkArgument$boolean(expression) {
                if (InternalPreconditions.API_CHECK_$LI$()) {
                    InternalPreconditions.checkCriticalArgument$boolean(expression);
                }
                else if (InternalPreconditions.CHECKED_MODE_$LI$()) {
                    try {
                        InternalPreconditions.checkCriticalArgument$boolean(expression);
                    }
                    catch (e) {
                        throw new java.lang.AssertionError(e);
                    }
                    ;
                }
            }
            static checkCriticalArgument$boolean(expression) {
                if (!expression) {
                    throw new java.lang.IllegalArgumentException();
                }
            }
            static checkArgument$boolean$java_lang_Object(expression, errorMessage) {
                if (InternalPreconditions.API_CHECK_$LI$()) {
                    InternalPreconditions.checkCriticalArgument$boolean$java_lang_Object(expression, errorMessage);
                }
                else if (InternalPreconditions.CHECKED_MODE_$LI$()) {
                    try {
                        InternalPreconditions.checkCriticalArgument$boolean$java_lang_Object(expression, errorMessage);
                    }
                    catch (e) {
                        throw new java.lang.AssertionError(e);
                    }
                    ;
                }
            }
            static checkCriticalArgument$boolean$java_lang_Object(expression, errorMessage) {
                if (!expression) {
                    throw new java.lang.IllegalArgumentException(/* valueOf */ new String(errorMessage).toString());
                }
            }
            static checkArgument$boolean$java_lang_String$java_lang_Object_A(expression, errorMessageTemplate, ...errorMessageArgs) {
                if (InternalPreconditions.API_CHECK_$LI$()) {
                    InternalPreconditions.checkCriticalArgument.apply(this, [expression, errorMessageTemplate].concat(errorMessageArgs));
                }
                else if (InternalPreconditions.CHECKED_MODE_$LI$()) {
                    try {
                        InternalPreconditions.checkCriticalArgument.apply(this, [expression, errorMessageTemplate].concat(errorMessageArgs));
                    }
                    catch (e) {
                        throw new java.lang.AssertionError(e);
                    }
                    ;
                }
            }
            /**
             * Ensures the truth of an expression involving one or more parameters to the calling method.
             * @param {boolean} expression
             * @param {string} errorMessageTemplate
             * @param {Array} errorMessageArgs
             */
            static checkArgument(expression, errorMessageTemplate, ...errorMessageArgs) {
                if (((typeof expression === 'boolean') || expression === null) && ((typeof errorMessageTemplate === 'string') || errorMessageTemplate === null) && ((errorMessageArgs != null && errorMessageArgs instanceof Array && (errorMessageArgs.length == 0 || errorMessageArgs[0] == null || (errorMessageArgs[0] != null))) || errorMessageArgs === null)) {
                    return javaemul.internal.InternalPreconditions.checkArgument$boolean$java_lang_String$java_lang_Object_A(expression, errorMessageTemplate, errorMessageArgs);
                }
                else if (((typeof expression === 'boolean') || expression === null) && ((errorMessageTemplate != null) || errorMessageTemplate === null) && errorMessageArgs === undefined) {
                    return javaemul.internal.InternalPreconditions.checkArgument$boolean$java_lang_Object(expression, errorMessageTemplate);
                }
                else if (((typeof expression === 'boolean') || expression === null) && errorMessageTemplate === undefined && errorMessageArgs === undefined) {
                    return javaemul.internal.InternalPreconditions.checkArgument$boolean(expression);
                }
                else
                    throw new Error('invalid overload');
            }
            static checkCriticalArgument$boolean$java_lang_String$java_lang_Object_A(expression, errorMessageTemplate, ...errorMessageArgs) {
                if (!expression) {
                    throw new java.lang.IllegalArgumentException(InternalPreconditions.format.apply(this, [errorMessageTemplate].concat(errorMessageArgs)));
                }
            }
            /**
             * Ensures the truth of an expression involving one or more parameters to the calling method.
             * <p>
             * For cases where failing fast is pretty important and not failing early could cause bugs that
             * are much harder to debug.
             * @param {boolean} expression
             * @param {string} errorMessageTemplate
             * @param {Array} errorMessageArgs
             */
            static checkCriticalArgument(expression, errorMessageTemplate, ...errorMessageArgs) {
                if (((typeof expression === 'boolean') || expression === null) && ((typeof errorMessageTemplate === 'string') || errorMessageTemplate === null) && ((errorMessageArgs != null && errorMessageArgs instanceof Array && (errorMessageArgs.length == 0 || errorMessageArgs[0] == null || (errorMessageArgs[0] != null))) || errorMessageArgs === null)) {
                    return javaemul.internal.InternalPreconditions.checkCriticalArgument$boolean$java_lang_String$java_lang_Object_A(expression, errorMessageTemplate, errorMessageArgs);
                }
                else if (((typeof expression === 'boolean') || expression === null) && ((errorMessageTemplate != null) || errorMessageTemplate === null) && errorMessageArgs === undefined) {
                    return javaemul.internal.InternalPreconditions.checkCriticalArgument$boolean$java_lang_Object(expression, errorMessageTemplate);
                }
                else if (((typeof expression === 'boolean') || expression === null) && errorMessageTemplate === undefined && errorMessageArgs === undefined) {
                    return javaemul.internal.InternalPreconditions.checkCriticalArgument$boolean(expression);
                }
                else
                    throw new Error('invalid overload');
            }
            static checkState$boolean(expression) {
                if (InternalPreconditions.API_CHECK_$LI$()) {
                    InternalPreconditions.checkCritcalState(expression);
                }
                else if (InternalPreconditions.CHECKED_MODE_$LI$()) {
                    try {
                        InternalPreconditions.checkCritcalState(expression);
                    }
                    catch (e) {
                        throw new java.lang.AssertionError(e);
                    }
                    ;
                }
            }
            /**
             * Ensures the truth of an expression involving the state of the calling instance, but not
             * involving any parameters to the calling method.
             * <p>
             * For cases where failing fast is pretty important and not failing early could cause bugs that
             * are much harder to debug.
             * @param {boolean} expression
             */
            static checkCritcalState(expression) {
                if (!expression) {
                    throw new java.lang.IllegalStateException();
                }
            }
            static checkState$boolean$java_lang_Object(expression, errorMessage) {
                if (InternalPreconditions.API_CHECK_$LI$()) {
                    InternalPreconditions.checkCriticalState(expression, errorMessage);
                }
                else if (InternalPreconditions.CHECKED_MODE_$LI$()) {
                    try {
                        InternalPreconditions.checkCriticalState(expression, errorMessage);
                    }
                    catch (e) {
                        throw new java.lang.AssertionError(e);
                    }
                    ;
                }
            }
            /**
             * Ensures the truth of an expression involving the state of the calling instance, but not
             * involving any parameters to the calling method.
             * @param {boolean} expression
             * @param {*} errorMessage
             */
            static checkState(expression, errorMessage) {
                if (((typeof expression === 'boolean') || expression === null) && ((errorMessage != null) || errorMessage === null)) {
                    return javaemul.internal.InternalPreconditions.checkState$boolean$java_lang_Object(expression, errorMessage);
                }
                else if (((typeof expression === 'boolean') || expression === null) && errorMessage === undefined) {
                    return javaemul.internal.InternalPreconditions.checkState$boolean(expression);
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             * Ensures the truth of an expression involving the state of the calling instance, but not
             * involving any parameters to the calling method.
             * @param {boolean} expression
             * @param {*} errorMessage
             */
            static checkCriticalState(expression, errorMessage) {
                if (!expression) {
                    throw new java.lang.IllegalStateException(/* valueOf */ new String(errorMessage).toString());
                }
            }
            static checkNotNull$java_lang_Object(reference) {
                if (InternalPreconditions.API_CHECK_$LI$()) {
                    InternalPreconditions.checkCriticalNotNull(reference);
                }
                else if (InternalPreconditions.CHECKED_MODE_$LI$()) {
                    try {
                        InternalPreconditions.checkCriticalNotNull(reference);
                    }
                    catch (e) {
                        throw new java.lang.AssertionError(e);
                    }
                    ;
                }
                return reference;
            }
            static checkCriticalNotNull$java_lang_Object(reference) {
                if (reference == null) {
                    throw new java.lang.NullPointerException();
                }
                return reference;
            }
            static checkNotNull$java_lang_Object$java_lang_Object(reference, errorMessage) {
                if (InternalPreconditions.API_CHECK_$LI$()) {
                    InternalPreconditions.checkCriticalNotNull$java_lang_Object$java_lang_Object(reference, errorMessage);
                }
                else if (InternalPreconditions.CHECKED_MODE_$LI$()) {
                    try {
                        InternalPreconditions.checkCriticalNotNull$java_lang_Object$java_lang_Object(reference, errorMessage);
                    }
                    catch (e) {
                        throw new java.lang.AssertionError(e);
                    }
                    ;
                }
            }
            /**
             * Ensures that an object reference passed as a parameter to the calling method is not null.
             * @param {*} reference
             * @param {*} errorMessage
             */
            static checkNotNull(reference, errorMessage) {
                if (((reference != null) || reference === null) && ((errorMessage != null) || errorMessage === null)) {
                    return javaemul.internal.InternalPreconditions.checkNotNull$java_lang_Object$java_lang_Object(reference, errorMessage);
                }
                else if (((reference != null) || reference === null) && errorMessage === undefined) {
                    return javaemul.internal.InternalPreconditions.checkNotNull$java_lang_Object(reference);
                }
                else
                    throw new Error('invalid overload');
            }
            static checkCriticalNotNull$java_lang_Object$java_lang_Object(reference, errorMessage) {
                if (reference == null) {
                    throw new java.lang.NullPointerException(/* valueOf */ new String(errorMessage).toString());
                }
            }
            static checkCriticalNotNull(reference, errorMessage) {
                if (((reference != null) || reference === null) && ((errorMessage != null) || errorMessage === null)) {
                    return javaemul.internal.InternalPreconditions.checkCriticalNotNull$java_lang_Object$java_lang_Object(reference, errorMessage);
                }
                else if (((reference != null) || reference === null) && errorMessage === undefined) {
                    return javaemul.internal.InternalPreconditions.checkCriticalNotNull$java_lang_Object(reference);
                }
                else
                    throw new Error('invalid overload');
            }
            /**
             * Ensures that {@code size} specifies a valid array size (i.e. non-negative).
             * @param {number} size
             */
            static checkArraySize(size) {
                if (InternalPreconditions.API_CHECK_$LI$()) {
                    InternalPreconditions.checkCriticalArraySize(size);
                }
                else if (InternalPreconditions.CHECKED_MODE_$LI$()) {
                    try {
                        InternalPreconditions.checkCriticalArraySize(size);
                    }
                    catch (e) {
                        throw new java.lang.AssertionError(e);
                    }
                    ;
                }
            }
            static checkCriticalArraySize(size) {
                if (size < 0) {
                    throw new java.lang.NegativeArraySizeException("Negative array size: " + size);
                }
            }
            /**
             * Ensures that {@code index} specifies a valid <i>element</i> in an array, list or string of size
             * {@code size}. An element index may range from zero, inclusive, to {@code size}, exclusive.
             * @param {number} index
             * @param {number} size
             */
            static checkElementIndex(index, size) {
                if (InternalPreconditions.BOUND_CHECK_$LI$()) {
                    InternalPreconditions.checkCriticalElementIndex(index, size);
                }
                else if (InternalPreconditions.CHECKED_MODE_$LI$()) {
                    try {
                        InternalPreconditions.checkCriticalElementIndex(index, size);
                    }
                    catch (e) {
                        throw new java.lang.AssertionError(e);
                    }
                    ;
                }
            }
            static checkCriticalElementIndex(index, size) {
                if (index < 0 || index >= size) {
                    throw new java.lang.IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
                }
            }
            /**
             * Ensures that {@code index} specifies a valid <i>position</i> in an array, list or string of
             * size {@code size}. A position index may range from zero to {@code size}, inclusive.
             * @param {number} index
             * @param {number} size
             */
            static checkPositionIndex(index, size) {
                if (InternalPreconditions.BOUND_CHECK_$LI$()) {
                    InternalPreconditions.checkCriticalPositionIndex(index, size);
                }
                else if (InternalPreconditions.CHECKED_MODE_$LI$()) {
                    try {
                        InternalPreconditions.checkCriticalPositionIndex(index, size);
                    }
                    catch (e) {
                        throw new java.lang.AssertionError(e);
                    }
                    ;
                }
            }
            static checkCriticalPositionIndex(index, size) {
                if (index < 0 || index > size) {
                    throw new java.lang.IndexOutOfBoundsException("Index: " + index + ", Size: " + size);
                }
            }
            /**
             * Ensures that {@code start} and {@code end} specify a valid <i>positions</i> in an array, list
             * or string of size {@code size}, and are in order. A position index may range from zero to
             * {@code size}, inclusive.
             * @param {number} start
             * @param {number} end
             * @param {number} size
             */
            static checkPositionIndexes(start, end, size) {
                if (InternalPreconditions.BOUND_CHECK_$LI$()) {
                    InternalPreconditions.checkCriticalPositionIndexes(start, end, size);
                }
                else if (InternalPreconditions.CHECKED_MODE_$LI$()) {
                    try {
                        InternalPreconditions.checkCriticalPositionIndexes(start, end, size);
                    }
                    catch (e) {
                        throw new java.lang.AssertionError(e);
                    }
                    ;
                }
            }
            /**
             * Ensures that {@code start} and {@code end} specify a valid <i>positions</i> in an array, list
             * or string of size {@code size}, and are in order. A position index may range from zero to
             * {@code size}, inclusive.
             * @param {number} start
             * @param {number} end
             * @param {number} size
             */
            static checkCriticalPositionIndexes(start, end, size) {
                if (start < 0) {
                    throw new java.lang.IndexOutOfBoundsException("fromIndex: " + start + " < 0");
                }
                if (end > size) {
                    throw new java.lang.IndexOutOfBoundsException("toIndex: " + end + " > size " + size);
                }
                if (start > end) {
                    throw new java.lang.IllegalArgumentException("fromIndex: " + start + " > toIndex: " + end);
                }
            }
            /**
             * Checks that bounds are correct.
             *
             * @throw StringIndexOutOfBoundsException if the range is not legal
             * @param {number} start
             * @param {number} end
             * @param {number} size
             */
            static checkStringBounds(start, end, size) {
                if (start < 0) {
                    throw new java.lang.StringIndexOutOfBoundsException("fromIndex: " + start + " < 0");
                }
                if (end > size) {
                    throw new java.lang.StringIndexOutOfBoundsException("toIndex: " + end + " > size " + size);
                }
                if (end < start) {
                    throw new java.lang.StringIndexOutOfBoundsException("fromIndex: " + start + " > toIndex: " + end);
                }
            }
            /**
             * Substitutes each {@code %s} in {@code template} with an argument. These are matched by
             * position: the first {@code %s} gets {@code args[0]}, etc.  If there are more arguments than
             * placeholders, the unmatched arguments will be appended to the end of the formatted message in
             * square braces.
             * @param {string} template
             * @param {Array} args
             * @return {string}
             * @private
             */
            /*private*/ static format(template, ...args) {
                template = new String(template).toString();
                let builder = new java.lang.StringBuilder(template.length + 16 * args.length);
                let templateStart = 0;
                let i = 0;
                while ((i < args.length)) {
                    {
                        let placeholderStart = template.indexOf("%s", templateStart);
                        if (placeholderStart === -1) {
                            break;
                        }
                        builder.append$java_lang_String(template.substring(templateStart, placeholderStart));
                        builder.append$java_lang_Object(args[i++]);
                        templateStart = placeholderStart + 2;
                    }
                }
                ;
                builder.append$java_lang_String(template.substring(templateStart));
                if (i < args.length) {
                    builder.append$java_lang_String(" [");
                    builder.append$java_lang_Object(args[i++]);
                    while ((i < args.length)) {
                        {
                            builder.append$java_lang_String(", ");
                            builder.append$java_lang_Object(args[i++]);
                        }
                    }
                    ;
                    builder.append$char(']');
                }
                return builder.toString();
            }
        }
        internal.InternalPreconditions = InternalPreconditions;
        InternalPreconditions["__class"] = "javaemul.internal.InternalPreconditions";
    })(internal = javaemul.internal || (javaemul.internal = {}));
})(javaemul || (javaemul = {}));
javaemul.internal.InternalPreconditions.BOUND_CHECK_$LI$();
javaemul.internal.InternalPreconditions.API_CHECK_$LI$();
javaemul.internal.InternalPreconditions.TYPE_CHECK_$LI$();
javaemul.internal.InternalPreconditions.CHECKED_MODE_$LI$();
java.util.logging.Logger.LOGGING_FALSE_$LI$();
java.util.logging.Logger.LOGGING_SEVERE_$LI$();
java.util.logging.Logger.LOGGING_WARNING_$LI$();
java.util.logging.Logger.LOGGING_ENABLED_$LI$();
java.util.logging.Logger.__static_initialize();
java.util.ConcurrentModificationDetector.API_CHECK_$LI$();
java.nio.file.Path.PATH_SEPARATOR_$LI$();
java.lang.System.in_$LI$();
java.lang.System.out_$LI$();
java.lang.System.err_$LI$();
java.lang.System.propertyMap_$LI$();
java.lang.System.ENVIRONMENT_IS_SHELL_$LI$();
java.lang.System.ENVIRONMENT_IS_NODE_$LI$();
java.lang.System.ENVIRONMENT_IS_WORKER_$LI$();
java.lang.System.ENVIRONMENT_IS_WEB_$LI$();
java.lang.System.__static_initialize();
java.util.TreeMap.SubMapType_Tail_$LI$();
java.util.TreeMap.SubMapType_Range_$LI$();
java.util.TreeMap.SubMapType_Head_$LI$();
java.util.TreeMap.SubMapType_All_$LI$();
java.util.Collections.RandomHolder.rnd_$LI$();
java.util.Collections.ReverseComparator.INSTANCE_$LI$();
java.util.Collections.EmptyListIterator.INSTANCE_$LI$();
java.util.Collections.EMPTY_SET_$LI$();
java.util.Collections.EMPTY_MAP_$LI$();
java.util.Collections.EMPTY_LIST_$LI$();
java.nio.charset.StandardCharsets.UTF_8_$LI$();
java.nio.charset.StandardCharsets.ISO_8859_1_$LI$();
javaemul.internal.ShortHelper.BoxedValues.boxedValues_$LI$();
javaemul.internal.ShortHelper.TYPE_$LI$();
javaemul.internal.ShortHelper.MAX_VALUE_$LI$();
javaemul.internal.ShortHelper.MIN_VALUE_$LI$();
javaemul.internal.LongHelper.BoxedValues.boxedValues_$LI$();
javaemul.internal.IntegerHelper.ReverseNibbles.reverseNibbles_$LI$();
javaemul.internal.IntegerHelper.BoxedValues.boxedValues_$LI$();
javaemul.internal.DoubleHelper.PowersTable.invPowers_$LI$();
javaemul.internal.DoubleHelper.PowersTable.powers_$LI$();
javaemul.internal.ByteHelper.BoxedValues.boxedValues_$LI$();
javaemul.internal.ByteHelper.TYPE_$LI$();
javaemul.internal.ByteHelper.MAX_VALUE_$LI$();
javaemul.internal.ByteHelper.MIN_VALUE_$LI$();
java.util.Scanner.whiteSpacePattern_$LI$();
java.util.Scanner.endLinePattern_$LI$();
java.util.Scanner.floatPattern_$LI$();
java.util.Scanner.integerPattern_$LI$();
java.util.Scanner.booleanPattern_$LI$();
java.util.Scanner.signedNonNumber_$LI$();
java.util.Scanner.decimal_$LI$();
java.util.Scanner.exponent_$LI$();
java.util.Scanner.decimalNumeral_$LI$();
java.util.Scanner.numeral_$LI$();
javaemul.internal.StringHelper.CASE_INSENSITIVE_ORDER_$LI$();
java.security.MessageDigest.Md5Digest.padding_$LI$();
javaemul.internal.EmulatedCharset.ISO_8859_1_$LI$();
javaemul.internal.EmulatedCharset.ISO_LATIN_1_$LI$();
javaemul.internal.EmulatedCharset.UTF_8_$LI$();
javaemul.internal.StringHashCache.front_$LI$();
javaemul.internal.StringHashCache.back_$LI$();
javaemul.internal.stream.VoidRunnable.dryRun_$LI$();
javaemul.internal.NumberHelper.__ParseLong.maxValueForRadix_$LI$();
javaemul.internal.NumberHelper.__ParseLong.maxLengthForRadix_$LI$();
javaemul.internal.NumberHelper.__ParseLong.maxDigitsRadixPower_$LI$();
javaemul.internal.NumberHelper.__ParseLong.maxDigitsForRadix_$LI$();
javaemul.internal.NumberHelper.__ParseLong.__static_initialize();
javaemul.internal.MathHelper.PI_UNDER_180_$LI$();
javaemul.internal.MathHelper.PI_OVER_180_$LI$();
javaemul.internal.MathHelper.MIN_VALUE_$LI$();
javaemul.internal.MathHelper.MAX_VALUE_$LI$();
javaemul.internal.MathHelper.EPSILON_$LI$();
javaemul.internal.JreHelper.LOG10E_$LI$();
javaemul.internal.CharacterHelper.BoxedValues.boxedValues_$LI$();
javaemul.internal.CharacterHelper.TYPE_$LI$();
javaemul.internal.BooleanHelper.TYPE_$LI$();
java.util.Random.twoToTheXMinus48_$LI$();
java.util.Random.twoToTheXMinus24_$LI$();
java.util.Random.__static_initialize();
java.util.OptionalLong.EMPTY_$LI$();
java.util.OptionalInt.EMPTY_$LI$();
java.util.OptionalDouble.EMPTY_$LI$();
java.util.Optional.EMPTY_$LI$();
java.util.logging.Level.WARNING_$LI$();
java.util.logging.Level.SEVERE_$LI$();
java.util.logging.Level.OFF_$LI$();
java.util.logging.Level.INFO_$LI$();
java.util.logging.Level.FINEST_$LI$();
java.util.logging.Level.FINER_$LI$();
java.util.logging.Level.FINE_$LI$();
java.util.logging.Level.CONFIG_$LI$();
java.util.logging.Level.ALL_$LI$();
java.util.Locale.defaultLocale_$LI$();
java.util.Locale.US_$LI$();
java.util.Locale.ENGLISH_$LI$();
java.util.Locale.ROOT_$LI$();
java.util.InternalJsMapFactory.jsMapCtor_$LI$();
java.util.Date.StringData.MONTHS_$LI$();
java.util.Date.StringData.DAYS_$LI$();
java.util.Comparators.NATURAL_$LI$();
java.nio.ByteOrder.LITTLE_ENDIAN_$LI$();
java.nio.ByteOrder.BIG_ENDIAN_$LI$();
java.net.InternalJsURLFactory.jsURLCtor_$LI$();
java.lang.Class.classes_$LI$();
java.lang.Class.constructors_$LI$();
test.Test.main(null);
